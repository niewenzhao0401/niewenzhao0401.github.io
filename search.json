[{"title":"JQuery-02JQuery选择器(重点)","url":"http://example.com/2021/01/08/JQuery-02/","content":"JQuery选择器(重点)基本选择器(重点)\n#ID             选择器: 根据id查找标签对象\n.class         选择器: 根据class查找标签对象\nelement     选择器: 根据标签名查找标签对象\n*                  选择器 表示任意的,所有元素\nselector1，selector2 组合选择器：合并选择器 1，选择器 2 的结果并返回\n\n层级选择器(重点)\n\n\nancestor descendant 后代选择器 ：在给定的祖先元素下匹配所有的后代元素 \nparent&gt; child 子选择器: 在给定的父元素下匹配所有子元素\nprev + next     相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素 \nprev~ sibings 之后的元素选择器:匹配 prev 元素之后的所有 siblings 元素\n\n过滤选择器\n:first                     获取第一个元素\n: last                     获取最后一个元素\n: not(selector)     去除所有与给定选择器匹配的元素 \n:even                 匹配所有索引值为偶数的元素，从 0 开始计数\n:odd                     匹配所有索引值为奇数的元素，从 0 开始计数\n:eq(index)         匹配一个给定索引值的元素\n:gt(index)         匹配所有大于给定索引值的元素\n:lt(index)         匹配所有小于给定索引值的元素\n:header        匹配如 h1, h2, h3 \n:animated   匹配所有正在执行动画效果的元素\n\n内容过滤器\n:contions(text)          匹配包含给定文本的元素\n: empty                     匹配所有不包含子元素或者文本的空元素\n:parent                     匹配含有子元素或者文本的元素\n:has(selector)         匹配含有选择器所匹配的元素的元素\n\n属性过滤器\n[attribute]                    匹配包含给定属性的元素。\n[attribute=value]         匹配给定的属性是某个特定值的元素\n[attribute!=value]     匹配所有不含有指定的属性，或者属性不等于特定值的元素。 \n[attribute^=value]     匹配给定的属性是以某些值开始的元素 \n[attribute$=value]     匹配给定的属性是以某些值结尾的元素 \n[attribute*=value]     匹配给定的属性是以包含某些值的元素 \n[attrSel1][attrSel2][attrSelN]     复合属性选择器，需要同时满足多个条件时使用\n\n表单过滤器\n:input             匹配所有 input, textarea, select 和 button 元素 \n:text                 匹配所有 文本输入框 \n:password     匹配所有的密码输入框 \n:radio             匹配所有的单选框 \n**:checkbox    **     匹配所有的复选框 \n:submit             匹配所有提交按钮 \n:image             匹配所有 img 标签 \n:reset             匹配所有重置按钮 \n:button             匹配所有 input type=button 按钮 \n:file             匹配所有 input type=file 文件上传 \n:hidden             匹配所有不可见元素 display:none 或 input type=hidden\n\n表单对象属性过滤器\n:enabled     匹配所有可用元素 \n:disabled     匹配所有不可用元素 \n:checked     匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象 \n:selected    ** **匹配所有选中的 option\n\njQuery 元素筛选\neq()             获取给定索引的元素                 功能跟 :eq() 一样 \nfirst()         获取第一个元素                         功能跟 :first 一样 \nlast()         获取最后一个元素                     功能跟 :last 一样 \nfilter(exp) 留下匹配的元素 \nis(exp)         判断是否匹配给定的选择器，只要有一个匹配就返回，true \nhas(exp)         返回包含有匹配选择器的元素的元素             功能跟 :has 一 样\nnot(exp)         删除匹配选择器的元素                                     功能跟 :not 一样     \nchildren(exp) 返回匹配给定选择器的子元素                         功能跟 parent&gt;child 一样 \nfind(exp)         返回匹配给定选择器的后代元素                     功能跟 ancestor descendant 一样\nnext()             返回当前元素的下一个兄弟元素                     功能跟 prev + next 功能一样 \nnextAll()         返回当前元素后面所有的兄弟元素                 功能跟 prev ~ siblings 功能一样 \nnextUntil()     返回当前元素到指定匹配的元素为止的后面元素 \nparent()         返回父元素 \nprev(exp)     返回当前元素的上一个兄弟元素 \nprevAll()         返回当前元素前面所有的兄弟元素 \nprevUnit(exp) 返回当前元素到指定匹配的元素为止的前面元素 \nsiblings(exp) 返回所有兄弟元素 \nadd() 把 add 匹配的选择器的元素添加到当前 jquery 对象中\n\n对应代码案例基本选择器&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function () &#123;        //1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot;        $(&quot;#btn1&quot;).click(function () &#123;            //css() 方法可以设置和获取方式            $(&quot;#one&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;);        &#125;);        //2.选择 class 为 mini 的所有元素        $(&quot;#btn2&quot;).click(function () &#123;            $(&quot;.mini&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;);        &#125;)        //3.选择 元素名是 div 的所有元素        $(&quot;#btn3&quot;).click(function () &#123;            $(&quot;div&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;);        &#125;)        //4.选择所有的元素        $(&quot;#btn4&quot;).click(function () &#123;            $(&quot;*&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;);        &#125;)        //5.选择所有的 span 元素和id为two的元素        $(&quot;#btn5&quot;).click(function () &#123;            $(&quot;span, #two&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;);        &#125;)    &#125;)&lt;/script&gt;\n\n层次选择器&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t$(document).ready(function()&#123;\t\t\t\t//1.选择 body 内的所有 div 元素 \t\t\t\t$(&quot;#btn1&quot;).click(function()&#123;\t\t\t\t\t$(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t\t\t&#125;);\t\t\t\t//2.在 body 内, 选择div子元素  \t\t\t\t$(&quot;#btn2&quot;).click(function()&#123;\t\t\t\t\t$(&quot;body&gt;div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t\t\t&#125;);\t\t\t\t//3.选择 id 为 one 的下一个 div 元素 \t\t\t\t$(&quot;#btn3&quot;).click(function()&#123;\t\t\t\t\t$(&quot;#one + div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t\t\t&#125;);\t\t\t\t//4.选择 id 为 two 的元素后面的所有 div 兄弟元素\t\t\t\t$(&quot;#btn4&quot;).click(function()&#123;\t\t\t\t\t$(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;java);\t\t\t\t&#125;);\t\t\t&#125;);\t\t&lt;/script&gt;\n\n基本过滤选择器&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;   &lt;script type=&quot;text/javascript&quot;&gt;       $(document).ready(function () &#123;           function anmateIt() &#123;               $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt);           &#125;           anmateIt();       &#125;);       $(document).ready(function () &#123;           //1.选择第一个 div 元素           $(&quot;#btn1&quot;).click(function () &#123;               $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //2.选择最后一个 div 元素           $(&quot;#btn2&quot;).click(function () &#123;               $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //3.选择class不为 one 的所有 div 元素           $(&quot;#btn3&quot;).click(function () &#123;               $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //4.选择索引值为偶数的 div 元素           $(&quot;#btn4&quot;).click(function () &#123;               $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //5.选择索引值为奇数的 div 元素           $(&quot;#btn5&quot;).click(function () &#123;               $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //6.选择索引值为大于 3 的 div 元素           $(&quot;#btn6&quot;).click(function () &#123;               $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //7.选择索引值为等于 3 的 div 元素           $(&quot;#btn7&quot;).click(function () &#123;               $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //8.选择索引值为小于 3 的 div 元素           $(&quot;#btn8&quot;).click(function () &#123;               $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //9.选择所有的标题元素           $(&quot;#btn9&quot;).click(function () &#123;               $(&quot;:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //10.选择当前正在执行动画的所有元素           $(&quot;#btn10&quot;).click(function () &#123;               $(&quot;:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);           //11 选择没有执行动画的最后一个div           $(&quot;#btn11&quot;).click(function () &#123;               $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);           &#125;);       &#125;);   &lt;/script&gt;\n\n内容选择器&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;\t$(document).ready(function()&#123;\t\tfunction anmateIt()&#123;\t\t\t$(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt);\t\t&#125;\t\t\tanmateIt();\t\t\t\t\t&#125;);\t\t/** \t:contains(text)   \t:empty \t\t\t  \t:has(selector) \t\t:parent \t\t\t\t*/\t$(document).ready(function()&#123;\t\t//1.选择 含有文本 &#x27;di&#x27; 的 div 元素\t\t$(&quot;#btn1&quot;).click(function()&#123;\t\t\t$(&quot;div:contains(&#x27;id&#x27;)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t&#125;);\t\t//2.选择不包含子元素(或者文本元素) 的 div 空元素\t\t$(&quot;#btn2&quot;).click(function()&#123;\t\t\t$(&quot;div:empty&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t&#125;);\t\t//3.选择含有 class 为 mini 元素的 div 元素\t\t$(&quot;#btn3&quot;).click(function()&#123;\t\t\t$(&quot;div:has(.mini)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t&#125;);\t\t//4.选择含有子元素(或者文本元素)的div元素\t\t$(&quot;#btn4&quot;).click(function()&#123;\t\t\t$(&quot;div:parent&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);\t\t&#125;);\t&#125;);&lt;/script&gt;\n\n属性过滤选择器&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;      /**       [attribute]       [attribute=value]       [attribute!=value]       [attribute^=value]       [attribute$=value]       [attribute*=value]       [attrSel1][attrSel2][attrSelN]       */      $(function () &#123;          //1.选取含有 属性title 的div元素          $(&quot;#btn1&quot;).click(function () &#123;              $(&quot;div[title]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //2.选取 属性title值等于&#x27;test&#x27;的div元素          $(&quot;#btn2&quot;).click(function () &#123;              $(&quot;div[title=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //3.选取 属性title值不等于&#x27;test&#x27;的div元素(*没有属性title的也将被选中)          $(&quot;#btn3&quot;).click(function () &#123;              $(&quot;div[title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //4.选取 属性title值 以&#x27;te&#x27;开始 的div元素          $(&quot;#btn4&quot;).click(function () &#123;              $(&quot;div[title^=&#x27;te&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //5.选取 属性title值 以&#x27;est&#x27;结束 的div元素          $(&quot;#btn5&quot;).click(function () &#123;              $(&quot;div[title$=&#x27;est&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //6.选取 属性title值 含有&#x27;es&#x27;的div元素          $(&quot;#btn6&quot;).click(function () &#123;              $(&quot;div[title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素          $(&quot;#btn7&quot;).click(function () &#123;              $(&quot;div[id][title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);          //8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素          $(&quot;#btn8&quot;).click(function () &#123;              $(&quot;div[title][title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;);          &#125;);      &#125;);  &lt;/script&gt;\n\n表单对象属性过滤选择器&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;     $(function () &#123;                  /**          :input          :text          :password          :radio          :checkbox          :submit          :image          :reset          :button          :file          :hidden          表单对象的属性          :enabled          :disabled          :checked          :selected          */         //1.对表单内 可用input 赋值操作         $(&quot;#btn1&quot;).click(function () &#123;             $(&quot;:text:enabled&quot;).val(&quot;New Value&quot;);         &#125;);         //2.对表单内 不可用input 赋值操作         $(&quot;#btn2&quot;).click(function () &#123;             $(&quot;:text:disabled&quot;).val(&quot;New Value Too&quot;);         &#125;);         //3.获取多选框选中的个数  使用size()方法获取选取到的元素集合的元素个数         $(&quot;#btn3&quot;).click(function () &#123;             alert($(&quot;:checkbox:checked&quot;).size())         &#125;);         //4.获取多选框，每个选中的value值         $(&quot;#btn4&quot;).click(function () &#123;             //获取全部选中的复选框标签内容             var $check = $(&quot;:checkbox:checked&quot;);             //老式遍历             // for (var i = 0; i &lt; $check.length; i++)&#123;             // \talert( $check[i].value );             // &#125;             alert($check.length)             $check.each(function () &#123;                 alert(this.value);             &#125;)         &#125;);         //5.获取下拉框选中的内容         $(&quot;#btn5&quot;).click(function () &#123;             //获取选中的option标签对象             var $option = $(&quot;select option:selected&quot;);             //遍历获取文本内容             $option.each(function () &#123;                 //在each遍历时的function函数中,有一个this对象 这个this对象是当前正在遍历的dom对象                 alert(this.innerHTML)             &#125;)         &#125;);     &#125;) &lt;/script&gt;\n\n元素筛选法&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(document).ready(function () &#123;        function anmateIt() &#123;            $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt);        &#125;        anmateIt();        /**         过滤         eq(index|-index)         first()         last()         hasClass(class)         filter(expr|obj|ele|fn)         is(expr|obj|ele|fn)1.6*         has(expr|ele)         not(expr|ele|fn)         slice(start,[end])         查找         children([expr])         closest(expr,[con]|obj|ele)1.6*         find(expr|obj|ele)         next([expr])         nextall([expr])         nextUntil([exp|ele][,fil])1.6*         parent([expr])         parents([expr])         parentsUntil([exp|ele][,fil])1.6*         prev([expr])         prevall([expr])         prevUntil([exp|ele][,fil])1.6*         siblings([expr])         串联         add(expr|ele|html|obj[,con])         */        //(1)eq()  选择索引值为等于 3 的 div 元素        $(&quot;#btn1&quot;).click(function () &#123;            $(&quot;div&quot;).eq(3).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(2)first()选择第一个 div 元素        $(&quot;#btn2&quot;).click(function () &#123;            //first()   选取第一个元素            $(&quot;div&quot;).first().css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(3)last()选择最后一个 div 元素        $(&quot;#btn3&quot;).click(function () &#123;            //last()  选取最后一个元素            $(&quot;div&quot;).last().css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(4)filter()在div中选择索引为偶数的        $(&quot;#btn4&quot;).click(function () &#123;            //filter()  过滤   传入的是选择器字符串            $(&quot;div&quot;).filter(&quot;:even&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(5)is()判断#one是否为:empty或:parent        //is用来检测jq对象是否符合指定的选择器        $(&quot;#btn5&quot;).click(function () &#123;            alert($(&quot;#one&quot;).is(&quot;:empty&quot;));        &#125;);        //(6)has()选择div中包含.mini的        $(&quot;#btn6&quot;).click(function () &#123;            //has(selector)  选择器字符串    是否包含selector            $(&quot;div&quot;).has(&quot;.mini&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(7)not()选择div中class不为one的        $(&quot;#btn7&quot;).click(function () &#123;            //not(selector)  选择不是selector的元素            $(&quot;div&quot;).not(&#x27;.one&#x27;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(8)children()在body中选择所有class为one的div子元素        $(&quot;#btn8&quot;).click(function () &#123;            //children()  选出所有的子元素            $(&quot;body&quot;).children(&quot;div.one&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(9)find()在body中选择所有class为mini的div元素        $(&quot;#btn9&quot;).click(function () &#123;            //find()  选出所有的后代元素            $(&quot;body&quot;).find(&quot;div.mini&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(10)next() #one的下一个div        $(&quot;#btn10&quot;).click(function () &#123;            //next()  选择下一个兄弟元素            $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(11)nextAll() #one后面所有的span元素        $(&quot;#btn11&quot;).click(function () &#123;            //nextAll()   选出后面所有的元素            $(&quot;#one&quot;).nextAll(&quot;span&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(12)nextUntil() #one和span之间的元素        $(&quot;#btn12&quot;).click(function () &#123;            //            $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;)        &#125;);        //(13)parent() .mini的父元素        $(&quot;#btn13&quot;).click(function () &#123;            $(&quot;.mini&quot;).parent().css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);        //(14)prev() #two的上一个div        $(&quot;#btn14&quot;).click(function () &#123;            //prev()            $(&quot;#two&quot;).prev(&quot;div&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;)        &#125;);        //(15)prevAll() span前面所有的div        $(&quot;#btn15&quot;).click(function () &#123;            //prevAll()   选出前面所有的元素            $(&quot;span&quot;).prevAll(&quot;div&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;)        &#125;);        //(16)prevUntil() span向前直到#one的元素        $(&quot;#btn16&quot;).click(function () &#123;            //prevUntil(exp)   找到之前所有的兄弟元素直到找到exp停止            $(&quot;span&quot;).prevUntil(&quot;#one&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;)        &#125;);        //(17)siblings() #two的所有兄弟元素        $(&quot;#btn17&quot;).click(function () &#123;            //siblings()    找到所有的兄弟元素，包括前面的和后面的            $(&quot;#two&quot;).siblings().css(&quot;background-color&quot;, &quot;#bfa&quot;)        &#125;);        //(18)add()选择所有的 span 元素和id为two的元素        $(&quot;#btn18&quot;).click(function () &#123;          //            $(&quot;span&quot;).add(&quot;#two&quot;).add(&quot;#one&quot;).css(&quot;background-color&quot;, &quot;#bfa&quot;);        &#125;);    &#125;);&lt;/script&gt;\n\n","categories":["-JQuery"],"tags":["JQuery"]},{"title":"JQuery-01概论","url":"http://example.com/2021/01/07/JQuery-01/","content":"JQuery什么是JQuery\n\n顾名思义就是JavaScript和查询(Query),它就是辅助JavaScript开发的JS类库\n\njQuery 核心思想\n\n核心思想:写得少,做的等多,实现了很多浏览器兼容的问题\n\njQuery 流行程度  \n\n有超过 55%在使用jQuery  \n\njQuery 好处\n\njQuery开源,免费,jQuery语法设计可以使得开发更加便捷,例如操作文档对象,选择DOM元素,制作动画效果.时间处理,使用Ajax以及其他功能\n\n使用 jQuery 给一个按钮绑定单击事件\n\n\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t// window.onload = function () &#123;\t\t// \tvar btnObj = document.getElementById(&quot;btnId&quot;);\t\t// \t// alert(btnObj);//[object HTMLButtonElement]   ====&gt;&gt;&gt;  dom对象\t\t// \tbtnObj.onclick = function () &#123;\t\t// \t\talert(&quot;js 原生的单击事件&quot;);\t\t// \t&#125;\t\t// &#125;\t\t$(function () &#123; // 表示页面加载完成 之后，相当 window.onload = function () &#123;&#125;\t\t\tvar $btnObj = $(&quot;#btnId&quot;); // 表示按id查询标签对象\t\t\t$btnObj.click(function () &#123; // 绑定单击事件\t\t\t\talert(&quot;jQuery 的单击事件&quot;);\t\t\t&#125;);\t\t&#125;);\t&lt;/script&gt;&lt;/head&gt;&lt;body&gt;\t&lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\n常见问题:\n\n使用JQuery一定要引用JQuery库吗?    是必须的\n\nJQuery中的$到底是什么?    它是以一个函数\n\n怎么为按钮添加点击相应函数\n\n使用Jquery查询到标签对象 var $btnObj = $(“#btnId”); // 表示按id查询标签对象\n使用标签对象 $btnObj.click(function () { // 绑定单击事件\n\n\n\njQuery 核心函数$ 是JQuery的核心函数,完成JQuery的很多动能,​$()就是调用​$这个函数  \n传入参数为[ 函数 ] 时：  \n\n表示页面加载完成之后,相当于window.onload = function(){}  \n\n传入参数为 [ HTML 字符串 ] 时  \n\n会对我们创建这个 html 标签对象  \n\n传入参数为 [ 选择器字符串 ] 时  \n\n$(“#id 属性值”);        id 选择器， 根据 id 查询标签对象\n$(“标签名”);               标签名选择器， 根据指定的标签名查询标签对象\n$(“.class 属性值”);     类型选择器， 可以根据 class 属性查询标签对象  \n\n传入参数为[ DOM 对象 ] 时：  \n\n回把这个DOM对象转换为JQuery对象\n\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;                $(function () &#123;            // alert(&quot;页面加载完成后,自动调入&quot;)            $(&quot;    &lt;div&gt;&quot; +                &quot;        &lt;span&gt;div-span1&lt;/span&gt;&quot; +                &quot;        &lt;span&gt;div-span2&lt;/span&gt;&quot; +                &quot;    &lt;/div&gt;&quot;).appendTo(&quot;body&quot;);                        // alert($(&quot;button&quot;).length);            var btnObj=   document.getElementById(&quot;btn01&quot;);            // alert(btnObj);            // alert( $(btnObj) );            // alert( $(&quot;&lt;h1&gt;&lt;/h1&gt;&quot;) );            alert($(&quot;button&quot;));        &#125;)        //核心函数的4个作用        //传入参数为[函数]时：在文档加载完成后执行这个函数        //传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象        //传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象        //传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn01&quot;&gt; 按钮一&lt;/button&gt;&lt;button&gt; 按钮2&lt;/button&gt;&lt;button&gt; 按钮3&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\njQuery 对象和 dom 对象区分什么是jQuery 对象对象 什么是dom 对象Dom 对象\n通过 getElementById()查询出来的标签对象是 Dom 对象通过 getElementsByName()查询出来的标签对象是 Dom 对象通过 getElementsByTagName()查询出来的标签对象是 Dom 对象通过 createElement() 方法创建的对象， 是 Dom 对象  \nDOM 对象 Alert 出来的效果是： [object HTML 标签名 Element]  \n\njQuery 对象\n通过 JQuery 提供的 API 创建的对象， 是 JQuery 对象  \n通过JQuery包装的Dom对象,   也是Jquery对象\n通过JQuery提供的API查询到的对象,是 JQuery 对象 \njQuery 对象 Alert 出来的效果是： [object Object]  \n\nJquery对象本质是什么\n JQuery 对象是Dom对象的数组+JQuery提供的一系列功能函数\n\nJQuery对象和Dom对象的使用区别\njQuery 对象不能使用 DOM 对象的属性和方法  \nDOM 对象也不能使用 jQuery 对象的属性和方法  \n\nDom对象和JQUery对象转换dom 对象转化为 jQuery 对象（重点）\n\n现有DOM对象\n$(DOM对象)就可以转换成为JQure对象\n\njQuery 对象转为 dom 对象（重点）\n\n先有 jQuery 对象\njQuery 对象[下标]取出相应的 DOM 对象\n\ndocument.getElementById(&quot;testDiv&quot;);$document.getElementById(&quot;testDiv&quot;);$document.getElementById(&quot;testDiv&quot;)[0];\n\n\n\n\n\n\n\n\n\n\n\n","categories":["-JQuery"],"tags":["JQuery"]},{"title":"常用正则写法","url":"http://example.com/2021/01/06/常用正则/","content":"常用正则规则\n\n整数或者小数：^[0-9]+\\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$只能输入数字：”^[0-9]*$”只能输入n位的数字：”^\\d&#123;n&#125;$”只能输入至少n位的数字：”^\\d&#123;n,&#125;$”只能输入m~n位的数字：”^\\d&#123;m,n&#125;$”只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。只能输入有两位小数的正实数：”^[0-9]+(.[0-9]&#123;2&#125;)?$”。只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]&#123;1,3&#125;)?$”。只能输入非零的正整数：”^\\+?[1-9][0-9]*$”。只能输入非零的负整数：”^\\-[1-9][]0-9″*$。只能输入长度为3的字符：”^.&#123;3&#125;$”。只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。只能输入由数字和26个英文字母组成的字符串：”^[A-Za-z0-9]+$”。只能输入由数字、26个英文字母或者下划线组成的字符串：”^\\w+$”。验证用户密码：”^[a-zA-Z]\\w&#123;5,17&#125;$”正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;’,;&#x3D;?$\\”等字符：”[^%&amp;&#39;,;&#x3D;?$\\x22]+”。只能输入汉字：”^[\\u4e00-\\u9fa5]&#123;0,&#125;$”验证Email地址：”^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$”。验证InternetURL：”^http:&#x2F;&#x2F;([\\w-]+\\.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$”。验证电话号码：”^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$”正确格式为：”XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX”。验证身份证号（15位或18位数字）：”^\\d&#123;15&#125;|\\d&#123;18&#125;$”。验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01″～”09″和”1″～”12″。验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01″～”09″和”1″～”31″。匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len&#x3D;function()&#123;return this.replace(&#x2F;[^\\x00-\\xff]&#x2F;g,”aa”).length;&#125;匹配空行的正则表达式：\\n[\\s| ]*\\r匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\\&#x2F;(.*)&gt;|&lt;(.*)\\&#x2F;&gt;匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim &#x3D; function()&#123;return this.replace(&#x2F;(^\\s*)|(\\s*$)&#x2F;g, “”);&#125;利用正则表达式分解和转换IP地址：下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：function IP2V(ip)&#123;re&#x3D;&#x2F;(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)&#x2F;g &#x2F;&#x2F;匹配IP地址的正则表达式if(re.test(ip))&#123;return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1&#125;else&#123;throw new Error(“Not a valid IP address!”)&#125;&#125;不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：var ip&#x3D;”10.100.20.168″ip&#x3D;ip.split(“.”)alert(“IP值是：”+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1))匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*匹配网址URL的正则表达式：http:&#x2F;&#x2F;([\\w-]+\\.)+[\\w-]+(&#x2F;[\\w- .&#x2F;?%&amp;&#x3D;]*)?利用正则表达式限制网页表单里的文本框输入内容：用正则表达式限制只能输入中文：onkeyup&#x3D;”value&#x3D;value.replace(&#x2F;[^\\u4E00-\\u9FA5]&#x2F;g,”)” onbeforepaste&#x3D;”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(&#x2F;[^\\u4E00-\\u9FA5]&#x2F;g,”))”用正则表达式限制只能输入全角字符： onkeyup&#x3D;”value&#x3D;value.replace(&#x2F;[^\\uFF00-\\uFFFF]&#x2F;g,”)” onbeforepaste&#x3D;”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(&#x2F;[^\\uFF00-\\uFFFF]&#x2F;g,”))”用正则表达式限制只能输入数字：onkeyup&#x3D;”value&#x3D;value.replace(&#x2F;[^\\d]&#x2F;g,”) “onbeforepaste&#x3D;”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(&#x2F;[^\\d]&#x2F;g,”))”用正则表达式限制只能输入数字和英文：onkeyup&#x3D;”value&#x3D;value.replace(&#x2F;[\\W]&#x2F;g,”) “onbeforepaste&#x3D;”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(&#x2F;[^\\d]&#x2F;g,”))”匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：\\n\\s*\\r评注：可以用来删除空白行匹配HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? &#x2F;&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力匹配首尾空白字符的正则表达式：^\\s*|\\s*$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*评注：表单验证时很实用匹配网址URL的正则表达式：[a-zA-z]+:&#x2F;&#x2F;[^\\s]*评注：网上流传的版本功能很有限，上面这个基本可以满足需求匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$评注：表单验证时很实用匹配国内电话号码：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;评注：匹配形式如 0511-4405222 或 021-87888822匹配腾讯QQ号：[1-9][0-9]&#123;4,&#125;评注：腾讯QQ号从10000开始匹配中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d)评注：中国邮政编码为6位数字匹配身份证：\\d&#123;15&#125;|\\d&#123;18&#125;评注：中国的身份证为15位或18位匹配ip地址：\\d+\\.\\d+\\.\\d+\\.\\d+评注：提取ip地址时有用匹配特定数字：^[1-9]\\d*$&#x2F;&#x2F;匹配正整数^-[1-9]\\d*$&#x2F;&#x2F;匹配负整数^-?[1-9]\\d*$&#x2F;&#x2F;匹配整数^[1-9]\\d*|0$&#x2F;&#x2F;匹配非负整数（正整数 + 0）^-[1-9]\\d*|0$&#x2F;&#x2F;匹配非正整数（负整数 + 0）^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$&#x2F;&#x2F;匹配正浮点数^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$&#x2F;&#x2F;匹配负浮点数^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$&#x2F;&#x2F;匹配浮点数^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$&#x2F;&#x2F;匹配非负浮点数（正浮点数 + 0）^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$　　&#x2F;&#x2F;匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：^[A-Za-z]+$&#x2F;&#x2F;匹配由26个英文字母组成的字符串^[A-Z]+$&#x2F;&#x2F;匹配由26个英文字母的大写组成的字符串^[a-z]+$&#x2F;&#x2F;匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$&#x2F;&#x2F;匹配由数字和26个英文字母组成的字符串^\\w+$&#x2F;&#x2F;匹配由数字、26个英文字母或者下划线组成的字符串评注：最基本也是最常用的一些表达式整理出来的一些常用的正则表达式 所属分类: JScript(三)Email : &#x2F;^\\w+([-+.]\\w+)*@\\w+([-.]\\\\w+)*\\.\\w+([-.]\\w+)*$&#x2F;isEmail1 : &#x2F;^\\w+([\\.\\-]\\w+)*\\@\\w+([\\.\\-]\\w+)*\\.\\w+$&#x2F;;isEmail2 : &#x2F;^.*@[^_]*$&#x2F;;Phone : &#x2F;^((\\(\\d&#123;3&#125;\\))|(\\d&#123;3&#125;\\-))?(\\(0\\d&#123;2,3&#125;\\)|0\\d&#123;2,3&#125;-)?[1-9]\\d&#123;6,7&#125;$&#x2F;Mobile : &#x2F;^((\\(\\d&#123;3&#125;\\))|(\\d&#123;3&#125;\\-))?13\\d&#123;9&#125;$&#x2F;Url : &#x2F;^http:\\&#x2F;\\&#x2F;[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\&#x2F;&#x3D;\\?%\\-&amp;_~&#96;@[\\]\\’:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$&#x2F;IdCard : &#x2F;^\\d&#123;15&#125;(\\d&#123;2&#125;[A-Za-z0-9])?$&#x2F;Currency : &#x2F;^\\d+(\\.\\d+)?$&#x2F;Number : &#x2F;^\\d+$&#x2F;Code : &#x2F;^[1-9]\\d&#123;5&#125;$&#x2F;QQ : &#x2F;^[1-9]\\d&#123;4,8&#125;$&#x2F;Integer : &#x2F;^[-\\+]?\\d+$&#x2F;Double : &#x2F;^[-\\+]?\\d+(\\.\\d+)?$&#x2F;English : &#x2F;^[A-Za-z]+$&#x2F;Chinese : &#x2F;^[\\u0391-\\uFFE5]+$&#x2F;UnSafe : &#x2F;^(([A-Z]*|[a-z]*|\\d*|[-_\\~!@#\\$%\\^&amp;\\*\\.\\(\\)\\[\\]\\&#123;\\&#125;&lt;&gt;\\?\\\\\\&#x2F;\\’\\”]*)|.&#123;0,5&#125;)$|\\s&#x2F;PassWord :^[\\\\w]&#123;6,12&#125;$ZipCode : ^[\\\\d]&#123;6&#125;&#x2F;^(\\+\\d+ )?(\\(\\d+\\) )?[\\d ]+$&#x2F;;&#x2F;&#x2F;这个是国际通用的电话号码判断&#x2F;^(1[0-2]\\d|\\d&#123;1,2&#125;)$&#x2F;;&#x2F;&#x2F;这个是年龄的判断&#x2F;^\\d+\\.\\d&#123;2&#125;$&#x2F;;&#x2F;&#x2F;这个是判断输入的是否为货币值应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len&#x3D;function()&#123;return this.replace([^\\x00-\\xff]&#x2F;g,”aa”).length;&#125;应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim &#x3D; function()&#123;return this.replace(&#x2F;(^\\s*)|(\\s*$)&#x2F;g, “”);&#125;匹配空行的正则表达式：\\n[\\s| ]*\\r匹配HTML标记的正则表达式：&#x2F;&lt;(.*)&gt;.*&lt;\\&#x2F;\\1&gt;|&lt;(.*) \\&#x2F;&gt;&#x2F;匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*匹配网址URL的正则表达式：http:&#x2F;&#x2F;([\\w-]+\\.)+[\\w-]+(&#x2F;[\\w- .&#x2F;?%&amp;&#x3D;]*)?^\\d+$　　&#x2F;&#x2F;匹配非负整数（正整数 + 0）^[0-9]*[1-9][0-9]*$　　&#x2F;&#x2F;匹配正整数^((-\\d+)|(0+))$　　&#x2F;&#x2F;匹配非正整数（负整数 + 0）^-[0-9]*[1-9][0-9]*$　　&#x2F;&#x2F;匹配负整数^-?\\d+$　　　　&#x2F;&#x2F;匹配整数^\\d+(\\.\\d+)?$　　&#x2F;&#x2F;匹配非负浮点数（正浮点数 + 0）^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$　&#x2F;&#x2F;匹配正浮点数^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$　　&#x2F;&#x2F;匹配非正浮点数（负浮点数 + 0）^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ &#x2F;&#x2F;匹配负浮点数^(-?\\d+)(\\.\\d+)?$\n\n\n\n","categories":["-工具栏"],"tags":["正则表达式","工具栏"]},{"title":"JS-05-JavaScript 正则表达式","url":"http://example.com/2021/01/05/JS-05/","content":"JavaScript 正则表达式\n\\d 匹配数字[4-9] 控制区间[4567] 只能匹配出现数字的一次X? 一次或者一次也没有X* 零次或者多次X+ 一次或者多次[即不能为空]\n\n//表示次数X{n] 恰好n次X{n,} 至少n次x{n,m} 至少n次,最多m次\n\n$ X  字符串必须以结尾\n\n^a 字符串必须以a打头\n\n\n\n\nJS中判断用test\n\nalert(patt.test(str));\n\n表示要求 字符串必须以a结尾\n\nvar patt = /a$/;\n\n表示要求 字符串必须以a打头\n\nvar patt = /^a/;\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //表示要求字符串中,是否包含字母e        // var patt = new RegExp(&quot;e&quot;);        //var patt = /e/;//也就是正则表达式                //要求字符串是否包含字母a 或者 字母b  或者 字母c        // var  patt=/[abc]/        //表示要求字符串是否包含小写字母        // var  patt=/[a-z]/        //表示要求字符串是否包含小写字母        //var patt = /[A-Z]/        // 表示要求字符串，是否包含字母，数字，下划线        // var patt = /\\w/;        //表示要求字符串,是否包含任意数字        // var  patt=/[0-9]/        // 表示要求 字符串中是否包含至少一个a        //  var patt = /a+/;        //表示要求字符串中是否* 包含* 零个或者 多个 a        // var patt = /a*/        // 表示要求 字符串是否包含一个或零个a        // var patt = /a?/;        // 表示要求 字符串是否包含连续三个a       // var patt = /a&#123;3&#125;/;        // 表示要求 字符串是否包 至少3个连续的a，最多5个连续的a        // var patt = /a&#123;3,5&#125;/;        // 表示要求 字符串是否包 至少3个连续的a，        //  var patt = /a&#123;3,&#125;/;        // 表示要求 字符串必须以a结尾        // var patt = /a$/;        //        //        // 表示要求 字符串必须以a打头        // var patt = /^a/;        // 要求字符串中是否*包含* 至少3个连续的a        // var patt = /a&#123;3,5&#125;/;        // 要求字符串，从头到尾都必须完全匹配        // var patt = /^a&#123;3,5&#125;$/;        var patt = /^\\w&#123;5,12&#125;$/;        var str = &quot;asdasdad&quot;;        alert(patt.test(str));    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["-JavaScript"],"tags":["JavaScript","JavaWeb","正则表达式"]},{"title":"JS-04-JavaScript DOM模型","url":"http://example.com/2021/01/04/JS-04/","content":"DOM模型DOM全称是 Document Object Model  文档对象模型\n\n就是把文档中的标签,属性,文本,转型成为对象来管理\n\nDocument对象的理解\nDocument它管理了所有的HTML文档内容\n\nDocument它是一种树形结构文档,有层级关系\n\n把所有的标签都对象化\n\n可以通过document访问所有的标签对象\n\n\n\n\nDocument对象\n\n\n\n\n\nHTML标签要对象化&lt;body&gt;\t&lt;div id=&quot;div01&quot;&gt;div01&lt;/div&gt; &lt;/body&gt;\n\n模拟对象化,相当于class Dom&#123;     private String id; // id 属性     private String tagName; //表示标签名     private Dom parentNode; //父亲     private List&lt;Dom&gt; children; // 孩子结点     private String innerHTML; // 起始标签和结束标签中间的内容 &#125;\n\nDocument 对象中的方法介绍\nDocument.getElementById(elementId)     通过标签的id属性查找标签dom对象,elementId 是标签的 id 属性值\ndocument.getElementsByName(elementName)     通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值\ndocument.getElementsByTagName(tagname)  通过标签名查找标签 dom 对象。tagname 是标签名\ndocument.createElement( tagName) 方法，通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名\n\n注:\n\ndocument 对象的三个查询方法,有id,优先使用getElementById 方法来进行查询\n没有 id 属性，则优先使用 getElementsByName 方法来进行查询\n最后使用按标签名查 getElementsByTagName\n\n\n一定要在页面加载完成之后执行,才能查询到标签对象\n\ngetElementById 方法示例代码：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        /*        需求: 当用户点击校验按钮时.要获取输出框中的类容,然后验证其是否合法        验证的规则是: 必须由字母 数字 下划线组成   并且长度为5 到 12 位         */        function onclickFun() &#123;            //1. 当我们操作一个标签的时候, 一定要先获取这个标签对象            let usernameObj = document.getElementById(&quot;username&quot;);            //[object HTMLInputElement]   为dom对象            var usernameText = usernameObj.value;            // 验证的规则是: 必须由字母 数字 下划线组成   并且长度为5 到 12 位            var patt = /^\\w&#123;5,12&#125;$/;            let usernameSpanObj = document.getElementById(&quot;usernameSpan&quot;);            //innerHtml 表示起始标签和结束标签中 的内容            // innerHTML 这个属可读 可写            usernameSpanObj.innerHTML = &quot;可爱!&quot;;            if (patt.test(usernameText)) &#123;                // alert(&quot;用户名合法！&quot;);                //  usernameSpanObj.innerHTML = &quot;用户名合法！&quot;;                usernameSpanObj.innerHTML = &quot;&lt;img src=\\&quot;right.png\\&quot; width=\\&quot;18\\&quot; height=\\&quot;18\\&quot;&gt;&quot;;            &#125; else &#123;                // alert(&quot;用户名不合法！&quot;);                // usernameSpanObj.innerHTML = &quot;用户名不合法！&quot;;                usernameSpanObj.innerHTML = &quot;&lt;img src=\\&quot;wrong.png\\&quot; width=\\&quot;18\\&quot; height=\\&quot;18\\&quot;&gt;&quot;;            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--value=&quot;wzg&quot;  初始内容--&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;wzg&quot;&gt;&lt;span id=&quot;usernameSpan&quot; style=&quot;...&quot;&gt;&lt;/span&gt;&lt;button onclick=&quot;onclickFun()&quot;&gt; 校验&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\ngetElementsByName 方法示例代码,全选,全不选,反选&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //全选        function checkAll() &#123;//让所有复选框都选中            //document.getElementsByName();是根据 指定的name 属性 查询返回多个标签对象集合            //集合的作用和数组一样            //集合中的每个对象都是dom对象            //这个集中的元素顺序是他们的HTMl 页面中由上到下的顺序            var elementsByName = document.getElementsByName(&quot;hobby&quot;);            for (var i = 0; i &lt; elementsByName.length; i++) &#123;                elementsByName[i].checked = true;            &#125;        &#125;        //全不选        function checkNo() &#123;            var elementsByName = document.getElementsByName(&quot;hobby&quot;);            for (var i = 0; i &lt; elementsByName.length; i++) &#123;                elementsByName[i].checked = false;            &#125;        &#125;        //反选        function checkReverse() &#123;            var elementsByName = document.getElementsByName(&quot;hobby&quot;);            for (var i = 0; i &lt; elementsByName.length; i++) &#123;                elementsByName[i].checked = !elementsByName[i].checked;            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;兴趣爱好&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot; checked=&quot;checked&quot;&gt;c++&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;js&quot;&gt;javaScript&lt;br/&gt;&lt;button onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt;&lt;button onclick=&quot;checkNo()&quot;&gt;全不全&lt;/button&gt;&lt;button onclick=&quot;checkReverse()&quot;&gt;反选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\ngetElementsByTagName方法示例代码：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function()&#123;            // alert( document.getElementById(&quot;btn01&quot;) );        &#125;        // 全选        function checkAll() &#123;            // alert( document.getElementById(&quot;btn01&quot;) );            // document.getElementsByTagName(&quot;input&quot;);            // 是按照指定标签名来进行查询并返回集合            // 这个集合的操作跟数组 一样            // 集合中都是dom对象            // 集合中元素顺序 是他们在html页面中从上到下的顺序。                var elementsByTagName = document.getElementsByTagName(&quot;input&quot;);            for (var i = 0; i &lt;elementsByTagName.length ; i++) &#123;                elementsByTagName[i].checked=true;            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--as --&gt;    兴趣爱好：    &lt;input type=&quot;checkbox&quot; value=&quot;cpp&quot; checked=&quot;checked&quot;&gt;C++    &lt;input type=&quot;checkbox&quot; value=&quot;java&quot;&gt;Java    &lt;input type=&quot;checkbox&quot; value=&quot;js&quot;&gt;JavaScript    &lt;br/&gt;    &lt;button id=&quot;btn01&quot; onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\ncreateElement方法示例代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function () &#123;//现在需要我们使用js代码来创建html 标签 并显示在页面上            //标签内容就是&lt;div&gt; 大钊 牛逼&lt;/div&gt;            var divObj = document.createElement(&quot;div&quot;); // 在内存中 &lt;div&gt;&lt;/div&gt;            var textNodeObj = document.createTextNode(&quot;大钊 牛逼&quot;); // 有一个文本节点对象 #大钊 牛逼            divObj.appendChild(textNodeObj); //// &lt;div&gt;大钊 牛逼&lt;/div&gt;       //     divObj.innerHTML = &quot;大钊 牛逼&quot;; // &lt;div&gt;大钊 牛逼&lt;/div&gt;,            // 添加子元素            document.body.appendChild(divObj)        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n","categories":["-JavaScript"],"tags":["JavaScript","JavaWeb","DOM模型"]},{"title":"JS-03-JavaScript 事件","url":"http://example.com/2021/01/03/JS-03/","content":"JavaScript中的事件什么是事件?事件是电脑输入设备与页面进行交互的响应.我们称之为事件\n常用的事件:\nonload 加载完成事件   页面加载完成之后,常用于做页面JS代码初始化操作\nonclick 单击事件         常用于按钮的点击相应操作\nonblur 失去焦点事件   常用于输入框失去焦点后验证其输入内容是否合法\nonchange 内容发生事件   常用于下拉列表和输入框类容发生改变后操作\nonsubmit 表单提交事件   常用于表单提交前,验证所有表单项是否合法\n\n事件的注册静态注册和动态注册两种\n \n\n什么是事件的注册(绑定)\n\n就是告诉浏览器,当事件响应后要执行哪些操作代码,叫事件注册或事件绑定。\n\n静态注册事件:\n\n通过HTML标签事件属性直接属于事件相应后的代码,这种方式我们叫静态注册.\n\n动态注册事件\n\n是只通过JS代码得到标签的DOM对象,然后再通过DOM对象.事件名= function(){}这种形式赋予事件响应后的代码,叫做动态注册\n\n动态注册基本步骤:\n\n获取标签对象\n标签对象.事件名= fucntion(){}\n\nwindow.onload = function () &#123;           //获取标签对象           let byId = document.getElementById(&quot;password&quot;);           // alert(byId);           //通过标签对象.事件名=function()&#123;&#125;           byId.onblur = function () &#123;               console.log(&quot;动态注册失去焦点事件&quot;);           &#125;       &#125;\n\n\n\nonload 加载完成事件\n页面加载完成之后， 常用于做页面 js 代码初始化操作\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;!--onload 加载完成事件： 页面加载完成之后， 常用于做页面 js 代码初始化操作onclick 单击事件： 常用于按钮的点击响应操作。onblur 失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。onchange 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作onsubmit 表单提交事件： 常用于表单提交前， 验证所有表单项是否合法--&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //onload事件的方法        function onloadFun() &#123;            alert(&quot;静态注册onload事件,所有代码&quot;)        &#125;        onloadFun();        //onload事件动态注册 是固定写法        window.onload = function () &#123;            alert(&quot;动态注册的onload事件&quot;);        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nonclick 单击事件\n常用于按钮的点击响应操作。\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;!--onload 加载完成事件： 页面加载完成之后， 常用于做页面 js 代码初始化操作onclick 单击事件： 常用于按钮的点击响应操作。onblur 失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。onchange 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作onsubmit 表单提交事件： 常用于表单提交前， 验证所有表单项是否合法--&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function onlickFun() &#123;            alert(&quot;静态注册onclick事件&quot;);        &#125;        //动态注册onclick事件        window.onload = function () &#123;            //1 获取标签对象            /*            document 是javaScript语言提供的对象(文档)            get 获取            Element  元素(就是标签)            By 通过..            id   id属性             getElementById通过id属性获取标签对象             */            let byId = document.getElementById(&quot;btn01&quot;);            //2 通过标签对象. 事件名=function            byId.onclick = function () &#123;                alert(&quot;动态注册的onclick事件&quot;);            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=&quot;onlickFun()&quot;&gt; 按钮一&lt;/button&gt;&lt;button id=&quot;btn01&quot;&gt; 按钮二&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nonblur 失去焦点事件\n常用于输入框失去焦点后验证其输入内容是否合法\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //静态注册失去焦点的事件        function onblurFun() &#123;            //console 是控制台对象  是由javaScript 语言提供 专门用来向浏览器的控制器打印输出,用于测试            //log()  打印方法            alert(&quot;静态注册失去焦点事件&quot;)            console.log(&quot;静态注册失去焦点事件&quot;)        &#125;        window.onload = function () &#123;            //获取标签对象            let byId = document.getElementById(&quot;password&quot;);            // alert(byId);            //通过标签对象.事件名=function()&#123;&#125;            byId.onblur = function () &#123;                console.log(&quot;动态注册失去焦点事件&quot;);            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;用户名:&lt;input type=&quot;text&quot; onabort=&quot;onblurFun();&quot;&gt; &lt;br/&gt;密码: &lt;input id=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/body&gt;&lt;/html&gt;\n\nonchange 内容发生改变事件\n常用于下拉列表和输入框类容发生改变后操作\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function onchangeFun() &#123;            alert(&quot;女神变了&quot;)        &#125;        window.onload = function () &#123;            //获取标签            let byId = document.getElementById(&quot;sel01&quot;);            //通过标签对象.事件名=function()&#123;&#125;            byId.onchange = function () &#123;                alert(&quot;男神已经改变了&quot;)            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;请选择你心中的女神&lt;!--静态注册onchange事件--&gt;&lt;select onchange=&quot;onchangeFun()&quot;&gt;    &lt;option&gt;-女神-&lt;/option&gt;    &lt;option&gt;芳芳&lt;/option&gt;    &lt;option&gt;佳佳&lt;/option&gt;    &lt;option&gt;娘娘&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;请选择你心中的男神&lt;!--静态注册onchange事件--&gt;&lt;select id=&quot;sel01&quot;&gt;    &lt;option&gt;-男神-&lt;/option&gt;    &lt;option&gt;大钊&lt;/option&gt;    &lt;option&gt;刘德华&lt;/option&gt;    &lt;option&gt;马德华&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nonsubmit 表单提交事件\n常用于表单提交前,验证所有表单项是否合法\n\n注意事项:\n\n表单事件发现不合化,有一个不合法就会阻止 表单的提交\n\n\n\n静态注册表单提交事务\n\nonsubmit=”return onsubmitFun();\n\n    function onsubmitFun() &#123;            //要验证所有表单项是否合法,如果,有一个不合法就会阻止 表单的提交            alert(&quot;静态注册表单提交事件----发现不合法&quot;);            return false;        &#125;&lt;!--return false 可以阻止 表单提交--&gt;&lt;form action=&quot;http://localhost:8080&quot; method=&quot;get&quot; onsubmit=&quot;return onsubmitFun();&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;&gt;&lt;/form&gt;\n\n\n\n动态注册表单提交事件\nwindow.onload = function () &#123;    //获取标签对象    let byId = document.getElementById(&quot;form01&quot;);    //通过标签对象.事件名=function    byId.onsubmit = function () &#123;        alert(&quot;动态注册表单提交事件----发现不合法&quot;);        return false    &#125;&#125;                &lt;form action=&quot;http://localhost:8080&quot; id=&quot;form01&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;动态注册&quot;&gt;&lt;/form&gt;\n\n\n\n\n\n整体代码\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //静态注册表单提交事务        function onsubmitFun() &#123;            //要验证所有表单项是否合法,如果,有一个不合法就会阻止 表单的提交            alert(&quot;静态注册表单提交事件----发现不合法&quot;);            return false;        &#125;        window.onload = function () &#123;            //获取标签对象            let byId = document.getElementById(&quot;form01&quot;);            //通过标签对象.事件名=function            byId.onsubmit = function () &#123;                alert(&quot;动态注册表单提交事件----发现不合法&quot;);                return false            &#125;        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--return false 可以阻止 表单提交--&gt;&lt;form action=&quot;http://localhost:8080&quot; method=&quot;get&quot; onsubmit=&quot;return onsubmitFun();&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;&gt;&lt;/form&gt;&lt;form action=&quot;http://localhost:8080&quot; id=&quot;form01&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;动态注册&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["-JavaScript"],"tags":["JavaScript","JavaWeb","JS事件"]},{"title":"JS-02-JavaScript 函数","url":"http://example.com/2021/01/02/JS-02/","content":"JavaScript 函数函数的二种定义方式第一种，可以使用function 关键字来定义函数\n使用的格式如下: \nfunction 函数名(形参列表)&#123; 函数体 &#125;\n\n\n在 JavaScript 语言中，如何定义带有返回值的函数？ \n只需要在函数体内直接使用 return 语句返回值即可！\n\n \n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //定义一个无参函数        function fun() &#123;            alert(&quot;无参函数fun()被调用&quot;)        &#125;        //函数调用才会执行        //    fun()        function fun2(a, b) &#123;            alert(&quot;有参函数fun2()被调用了 a=&gt;&quot; + a + &quot;,b=&gt;&quot; + b);        &#125;        // fun2(12,&quot;ad&quot;)                //定义带有返回值的函数        function sum(a, b) &#123;            var result = a + b;            return result;        &#125;        alert( sum(100,50))    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n函数的第二种定义方式，格式如下： \n使用格式如下： \nvar 函数名 = function(形参列表) &#123; 函数体 &#125;\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //定义一个无参函数        var fun = function () &#123;            alert(&quot;无参函数fun()被调用&quot;);        &#125;        //函数调用才会执行            fun()        var fun2 = function (a, b) &#123;            alert(&quot;有参函数fun2()被调用了 a=&gt;&quot; + a + &quot;,b=&gt;&quot; + b);        &#125;         fun2(12,&quot;ad&quot;)        //定义带有返回值的函数        var sum = function (a, b) &#123;            var result = a + b;            return result;        &#125;        alert(sum(100, 50))    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\nJS 中函数的重载在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function  fun(a,b) &#123;            alert(&quot;有参函数fun(a,b)&quot;);        &#125;        function fun() &#123;            alert(&quot;无参函数fun()&quot;);        &#125;        //按照最后一个函数        fun(1,&quot;ad&quot;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\narguments 隐形参数函数的 arguments 隐形参数（只在 function 函数内）\n\n就是在function函数中不需要定义,但却可以直接用来获取所有的参数的变量.我们管他叫隐形参数.\n隐形参数特别像 java 基础的可变长参数一样。\npublic void fun( Object … args );\n可变长参数其他是一个数组。\n那么 js 中的隐形参数也跟 java 的可变长参数一样。操作类似数组。\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function fun() &#123;            alert(arguments.length);//可看参数个数            alert(arguments[0]);            alert(arguments[1]);            alert(arguments[2]);            alert(typeof (arguments[3]));            for (var i = 0; i &lt; arguments.length; i++) &#123;                alert(arguments[i]);            &#125;            alert(&quot;无参函数fun()&quot;)        &#125;        // fun(1, &quot;ad&quot;, true);        //需求编写以恶个函数 用于计算所参数的值和并返回        function sum(a, b) &#123;            var result = 0;            for (var i = 0; i &lt; arguments.length; i++) &#123;                if (typeof (arguments[i] )== &quot;number&quot;) &#123;                    result += arguments[i];                &#125;            &#125;            return result;        &#125;        alert(sum(1, 2, 3, 4, &quot;abc&quot;, 5, 6, 7, 8, 9));    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\nJS 中的自定义对象Object 形式的自定义对象对象的定义： \nvar 变量名 = new Object();       // 对象实例（空对象） 变量名.属性名 = 值;  \t\t\t\t\t// 定义一个属性 变量名.函数名 = function()&#123;&#125;\t // 定义一个函数\n\n对象的访问： \n\n​    变量名.属性 / 函数名();\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        /**         * 对象的定义         * var 变量名= new OBject() //对象实例(空对象)         * 变量名.属性名=值  //定义属性         * 变量名.函数名= function  //定义函数         */        var obj = new Object();        obj.name = &quot;大钊&quot;        obj.aa = 13;        obj.fun = function () &#123;            alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.aa);        &#125;        //访问的对象        // 变量名.属性/函数名        alert(obj.aa)        // obj.fun()    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n{}花括号形式的自定义对象 对象的定义 var 变量名=&#123;  //空对象 属性名:值       //定义一个属性 属性名: 值      //定义一个属性函数名: function()&#123;&#125;  //定义一个函数\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        /*        对象的定义        var 变量名=&#123;  //空对象        属性名:值       //定义一个属性        属性名: 值      //定义一个属性       函数名: function()&#123;&#125;  //定义一个函数        &#125;;         */        var obj=&#123;            name:&quot;钊&quot;,            age:12,            fun:function () &#123;                alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.age);            &#125;        &#125;;        //对象的访问        alert(obj.name)        obj.fun();    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["-JavaScript"],"tags":["JavaScript","JavaWeb"]},{"title":"JS-01-JavaScript 语言入门","url":"http://example.com/2021/01/01/JS-01/","content":"JavaScript 语言入门JavaScript 介绍Javascript 语言诞生主要是完成页面的数据验证。 因此它运行在客户端， 需要运行浏览器来解析执行 JavaScript 代码。  \nJS 是 Netscape 网景公司的产品， 最早取名为 LiveScript;为了吸引更多 java 程序员。 更名为 JavaScript。  \nJS 是弱类型， Java 是强类型。  \n特点:\n\n交互性（它可以做的就是信息的动态交互） \n安全性 （不允许直接访问本地硬盘）\n跨平台性 （只要是可以解释 JS 的浏览器都可以执行，和平台无关）\n\n \n\nJavaScript 和 html 代码的结合方式\n现在需要使用script 引用外部的JS文件Src 属性专门来引用js文件路径(相对绝对 都可)\n\n\nscript 标签可以用来定义js代码 也可以用来引用js文件但是 两个功能二选一使用  不饿能同使用两个功能\n\n第一种方式 \n只需要在 head 标签中，或者在 body 标签中， 使用 script 标签 来书写 JavaScript 代码\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        alert(&quot;Hello javaScript&quot;)    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n第二种方式 \n使用 script 标签引入 单独的 JavaScript 代码文件\n1.js\nalert(&quot;123 hello&quot;);\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;!--现在需要使用script 引用外部的JS文件Src 属性专门来引用js文件路径(相对绝对 都可)script 标签可以用来定义js代码 也可以用来引用js文件但是 两个功能二选一使用  不饿能同使用两个功能--&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;1.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        alert(&quot;大钊 牛逼&quot;)    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n变量JavaScript 的变量类型：\n数值类型： number \n字符串类型： string \n对象类型： object \n布尔类型： boolean \n函数类型： function \n\nJavaScript 里特殊的值：\nundefined     未定义，所有 js 变量未赋于初始值的时候，默认值都是 undefined. \nnull      空值 \nNaN     全称是：Not a Number。非数字。非数值。\n\nJS 中的定义变量格式：\nvar 变量名; \nvar 变量名 = 值;\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var i;        // alert(i);        i = 12;        //typeof() 是JavaScript语言提供的一个函数        alert(typeof (i));//// number        i = &quot;abc&quot;;        // alert(typeof (i));// String        var a = 12;        var b = &quot;ad&quot;;        alert(a * b);// NaN是非数字，非数值。        //NaN是非数字  非数值    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;\n\n关系（比较）运算\n等于： ==   等于是简单的做字面值的比较 \n全等于：  ===    除了做字面值的比较之外，还会比较两个变量的数据类型\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var a = &quot;12&quot;;        var b = 12;        alert(a==b);        alert(a===b);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n逻辑运算\n且运算： &amp;&amp; \n或运算： || \n取反运算： !\n\n\n在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用。\n0 、null、 undefined、””(空串) 都认为是 false；\n\n&amp;&amp; 且运算。有两种情况： \n\n第一种：当表达式全为真的时候。返回最后一个表达式的值。 \n第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值\n\n|| 或运算\n第一种情况：当表达式全为假时，返回最后一个表达式的值 \n第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值\n\n\n并且 &amp;&amp; 与运算 和 ||或运算 有短路。 \n短路就是说，当这个&amp;&amp;或||运算有结果了之后 。后面的表达式不再执行\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //javaScript语言中,所有的变量,都可以作一个boolean 类型的变量使用        //0 null  undefined &quot;&quot;(空串)  都默认为false        // alert(&quot;Hello javaScript&quot;)        /*        var a = 0;                if (a) &#123;                    alert(&quot;零为真&quot;);                &#125; else &#123;                    alert(&quot;零为假&quot;)                &#125;*/        /*       var a = null;               if (a) &#123;                   alert(&quot;null为真&quot;);               &#125; else &#123;                   alert(&quot;null为假&quot;);               &#125;*/        // var a = undefined;        // if (a) &#123;        //     alert(&quot;undefined为真&quot;);        // &#125; else &#123;        //     alert(&quot;undefined为假&quot;)        // &#125;        // var d = &quot;&quot;;        // if (d) &#123;        //     alert(&quot;空串为真&quot;);        // &#125; else &#123;        //     alert(&quot;空串为假&quot;);        // &#125;        /*        &amp;&amp; 且运算        两种情况        1 当表达式全为真的时候,返回最后一个表达式的值        2 在表达式中,有一个为假的时候,返回第一个为假的值         */        var a = &quot;abc&quot;;        var b = true;        var d = false;        var c = null;        // alert(a &amp;&amp; b);//true        // alert(b &amp;&amp; a);//abc        // alert(a &amp;&amp; d);//false        // alert(a &amp;&amp; c);//null        /*        || 或运算        1 当表达式全为假时, 返回第一个表达的值        2 只要有有一个表达式为真,就会把第一个为真的值返回         */        alert(d || c);// null        alert(c || d); //false        alert(a || c); //abc        alert(b || c); //true    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n数组（重点）JS 中 数组的定义： \n格式： \n\nvar 数组名 = [];                         // 空数组 \nvar 数组名 = [1 , ’abc’ , true];  // 定义数组同时赋值元素\n\n\njavaScript 语言中的数组 只要我们通过下标赋值,那么最大的下标值,就会自动的给数组做扩容操作。\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var  arr=[true,12,12];        alert(arr.length);        arr[0] = 12;        // alert( arr[0] );//12        //javaScript 语言中的数组 只要我们通过下标赋值,那么最大的下标值,就会自动的给数组做扩容操作。        arr[8]=&quot;Ad&quot;        // alert(arr.length);        // alert(arr[1]);// undefined        // 数组的遍历        for (var i = 0; i &lt; arr.length; i++)&#123;            alert(arr[i]);        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["-JavaScript"],"tags":["JavaScript","JavaWeb"]},{"title":"LC590-N叉树的后序遍历","url":"http://example.com/2020/12/30/LC590/","content":"590. N叉树的后序遍历难度简单119\n给定一个 N 叉树，返回其节点值的后序遍历。\n例如，给定一个 3叉树 :\n\n\n\n\n返回其后序遍历: [5,6,3,2,4,1]\n递归 \n\nLinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();public List&lt;Integer&gt; postorder(Node root) &#123;    dfs(root);    return  list;&#125;private void dfs(Node root) &#123;    if (root==null)&#123;        return;    &#125;    for (Node chlid : root.children) &#123;        dfs(chlid);    &#125;    list.add(root.val);&#125;\n\n迭代\n使用一个栈来得到后序遍历\n首先把跟节点放入栈中,当我们每次从栈顶取出一个节点u点,,就把就把 u 的所有子节点顺序推入栈中。\nu 的子节点从左到右为 v1, v2, v3,,那么推入栈的顺序为 v1, v2, v3，\n就保证了下一个遍历到的节点（即 u 的第一个子节点 v3）出现在栈顶的位置。在遍历结束之后，我们把遍历结果反转，就可以得到后序遍历。\n\n/** * N叉树的后序遍历 */public class LEE590 &#123;    public List&lt;Integer&gt; postorder11(Node root) &#123;        LinkedList&lt;Node&gt; stack = new LinkedList&lt;&gt;();        LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();        if (root == null) &#123;            return output;        &#125;        stack.add(root);        while (!stack.isEmpty()) &#123;            Node node = stack.pollLast();            output.addFirst(node.val);            for (Node item : node.children) &#123;                if (item != null) &#123;                    stack.add(item);                &#125;            &#125;        &#125;        return output;    &#125;\n\n","categories":["-算法"],"tags":["二叉树","LeetCode","DFS"]},{"title":"LC589-N叉树的前序遍历","url":"http://example.com/2020/12/29/LC589/","content":"589. N叉树的前序遍历难度简单128给定一个 N 叉树，返回其节点值的前序遍历。\n例如，给定一个 3叉树 :\n\n\n\n\n返回其前序遍历: [1,3,5,6,2,4]。\n递归  \n\nLinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();  public List&lt;Integer&gt; preorder(Node root) &#123;      dfs(root);      return list;  &#125;  private void dfs(Node root) &#123;      if (root == null) &#123;          return;      &#125;      list.add(root.val);      if (root.children == null) &#123;          return;      &#125;      for (Node chlid : root.children) &#123;          dfs(chlid);      &#125;  &#125;\n\n\n\n\n\n迭代\n\n使用一个栈来帮助我们得到前序遍历,需要保证栈顶的节点就是我们要遍历到的节点,,\n首先使用跟节点入栈,因为根节点是前序遍历中的第一个节点,随后每次我们从栈顶取出一个节点u   他就是我们当前遍历到的节点,并把u 的所有结点逆序推入栈中\n例如u 的子结点从 v1, v2, v3，那么推入栈的顺序应当为 v3, v2, v1， 这样就保证了下一个遍历到的节点即 u 的第一个子节点 v1）出现在栈顶的位置。\n\npublic List&lt;Integer&gt; preorder1(Node root) &#123;    LinkedList&lt;Node&gt; stack = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();    if (root == null) &#123;        return output;    &#125;    stack.push(root);    while (!stack.isEmpty()) &#123;        Node node = stack.pop();        output.add(node.val);        Collections.reverse(node.children);        for (Node item : node.children) &#123;            stack.push(item);        &#125;    &#125;    return output;&#125;\n\n","categories":["-算法"],"tags":["二叉树","LeetCode","DFS"]},{"title":"LC102-二叉树的层序遍历","url":"http://example.com/2020/12/28/LC102/","content":"102. 二叉树的层序遍历难度中等740\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n示例：二叉树：[3,9,20,null,null,15,7],\n  3 &#x2F; \\9  20  &#x2F;  \\ 15   7\n\n返回其层序遍历结果：\n \n\n[  [3],  [9,20],  [15,7]]\n\n迭代实现,广度优先遍历是按层层推进的方式，遍历每一层的节点。\n题目要求的是返回每一层的节点值，所以这题用广度优先来做非常合适。广度优先需要用队列作为辅助结构，我们先将根节点放到队列中，然后不断遍历队列。\nimport java.util.*;\tclass Solution &#123;\tpublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\t\tif(root==null) &#123;\t\t\treturn new ArrayList&lt;List&lt;Integer&gt;&gt;();\t\t&#125;\t\t\t\tList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\t\tLinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\t\t//将根节点放入队列中，然后不断遍历队列\t\tqueue.add(root);\t\twhile(queue.size()&gt;0) &#123;\t\t\t//获取当前队列的长度，这个长度相当于 当前这一层的节点个数\t\t\tint size = queue.size();\t\t\tArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();\t\t\t//将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中\t\t\t//如果节点的左/右子树不为空，也放入队列中\t\t\tfor(int i=0;i&lt;size;++i) &#123;\t\t\t\tTreeNode t = queue.remove();\t\t\t\ttmp.add(t.val);\t\t\t\tif(t.left!=null) &#123;\t\t\t\t\tqueue.add(t.left);\t\t\t\t&#125;\t\t\t\tif(t.right!=null) &#123;\t\t\t\t\tqueue.add(t.right);\t\t\t\t&#125;\t\t\t&#125;\t\t\t//将临时list加入最终返回结果中\t\t\tres.add(tmp);\t\t&#125;\t\treturn res;\t&#125;&#125;\n\n\n\n递归实现深度优先用广度优先处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。\n\n我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个 list。\n\n按照深度优先的处理顺序，会先访问节点 1，再访问节点 2，接着是节点 3。之后是第二列的 4 和 5，最后是第三列的 6。\n每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。\n\nimport java.util.*;\tclass Solution &#123;\tpublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\t\tif(root==null) &#123;\t\t\treturn new ArrayList&lt;List&lt;Integer&gt;&gt;();\t\t&#125;\t\t//用来存放最终结果\t\tList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\t\tdfs(1,root,res);\t\treturn res;\t&#125;\t\tvoid dfs(int index,TreeNode root, List&lt;List&lt;Integer&gt;&gt; res) &#123;\t\t//假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中\t\tif(res.size()&lt;index) &#123;\t\t\tres.add(new ArrayList&lt;Integer&gt;());\t\t&#125;\t\t//将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99\t\t//res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]\t\tres.get(index-1).add(root.val);\t\t//递归的处理左子树，右子树，同时将层数index+1\t\tif(root.left!=null) &#123;\t\t\tdfs(index+1, root.left, res);\t\t&#125;\t\tif(root.right!=null) &#123;\t\t\tdfs(index+1, root.right, res);\t\t&#125;\t&#125;&#125;\n\n","categories":["-算法"],"tags":["二叉树","LeetCode","BFS","DFS"]},{"title":"LC429-N 叉树的层序遍历","url":"http://example.com/2020/12/27/LC429/","content":"429. N 叉树的层序遍历难度中等126\n给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n示例 1：\n\n\n输入：root &#x3D; [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]]\n\n \n\n官方详细图解\n基本算法。利用队列实现广度优先搜索\n树上使用基于队列的遍历算法，看看它的作用。这是你应该记住的一个基本算法。\n我们要构造一个 sub-lists 列表，其中每个 sub-list 是树中一行的值。行应该按从上到下的顺序排列。\n由根节点开始遍历树,然后向下搜索接近根节点的节点, 这就是广度优先搜索\n使用队列来进行广度优先搜索,队列具有先进先出的特性\n在这里使用栈是错误的选择，栈应用于深度优先搜索。\n\nList&lt;Integer&gt; values = new ArrayList&lt;&gt;();Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();queue.add(root);while (!queue.isEmpty()) &#123;    Node nextNode = queue.remove();    values.add(nextNode.val);    for (Node child : nextNode.children) &#123;        queue.add(child);    &#125;&#125;\n\n\n\n\n\n算法:\n需要保存每一层的列表,并且在根节点为空时正常工作\n在构造下一层的列表时,我们需要创建新的子列表，然后将该层的所有节点的值插入到列表中。\nwhile 循环体开始时记录队列的当前大小 size。 然后用另外一个循环来处理size 数量的节点。这样可以保证 while 循环在每一次迭代处理一层。\npublic List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        if (root == null) return result;        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();        queue.add(root);        while (!queue.isEmpty()) &#123;            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            int size = queue.size();            for (int i = 0; i &lt; size; i++) &#123;                Node node = queue.poll();                level.add(node.val);                for (Node item : node.children) &#123;                        queue.add(item);                &#125;            &#125;            result.add(level);        &#125;        return result;    &#125;\n\n复杂度分析\n\n时间复杂度：O(n)。n指的是节点的数量。\n空间复杂度：O(n)\n\n方法二：简化的广度优先搜索\\看官方题解\n官方详细图解\n方法三：递归深度优先搜索但是在本题中，我们可以以不同的顺序添加到最终列表中，只要我们知道节点在哪一层并确保在那一层的列表顺序正确就可以了。\n官方详细图解\nclass Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;        if (root != null) traverseNode(root, 0);        return result;    &#125;    private void traverseNode(Node node, int level) &#123;        if (result.size() &lt;= level) &#123;            result.add(new ArrayList&lt;&gt;());        &#125;        result.get(level).add(node.val);        for (Node child : node.children) &#123;            traverseNode(child, level + 1);        &#125;    &#125;&#125;\n\n","categories":["-算法"],"tags":["二叉树","LeetCode","BFS","DFS"]},{"title":"javaSE内部类","url":"http://example.com/2020/12/26/javaSE内部类/","content":"内部类内部类一般来说分为四种:\n\n成员内部类\n静态内部类\n局部内部类\n匿名内部类\n\n成员内部类成员内部类–就是位于外部类成员位置的类\n特点: 可以使用外部类中所有的成员变量和成员方法(包括private的)\n\n\nclass Outer &#123;      private int age = 20;            class Inner &#123;          public void show() &#123;              System.out.println(age);          &#125;      &#125;&#125;class Test &#123;      public static void main(String[] ages) &#123;      Outer.Inner oi = new Outer().new Inner();          oi.show();      &#125;  &#125;\n\n\n\nprivate修饰内部类\n如果我们的内部类不想轻易被任何人访问，可以选择使用private修饰内部类，这样我们就无法通过创建对象的方法来访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用。这样做的好处就是，我们可以在这个public方法中增加一些判断语句，起到数据安全的作用\nclass Outer &#123;      private class Inner &#123;          public void show() &#123;              System.out.println(“密码备份文件”);          &#125;      &#125;      //使用getXxx()获取成员内部类，可以增加校验语句（文中省略）      public Inner getInner() &#123;          return new Inner();      &#125;     &#125;  public static void main(String[] args) &#123;         Outer outer = new Outer();         Outer.Inner inner = outer.getInner();          \t\tinner.show();   &#125;\n\n静态内部类静态内部类\n这种被static坐修饰的内部类,按位置分,属于成员内部类,但也可以称为静态内部类,也常叫嵌套内部类.不能使用外部类的非static成员变量和成员方法\npublic class Outter &#123;      int age = 10;      static int  age2 = 20;      public Outter() &#123;              &#125;             static class Inner &#123;          public void method() &#123;              System.out.println(age);//错误              System.out.println(age2);//正确          &#125;      &#125;  &#125;  public class Test &#123;      public static void main(String[] args)  &#123;          Outter.Inner inner = new Outter.Inner();          inner.method();      &#125;  &#125;\n\n\n\n\n\n局部内部类局部内部类–就是定义在一个方法或者一个作用域里面的类\n特点:主要是作用域发生了变化，只能在自身所在方法和属性中被使用\nclass Outer &#123;      private int age = 20;      public void method() &#123;          final int age2 = 30;          class Inner &#123;              public void show() &#123;               System.out.println(age);                  //从内部类中访问方法内变量age2，需要将变量声明为最终类型。                  System.out.println(age2);              &#125;          &#125;                    Inner i = new Inner();//在method()方法中创建局部内部类对象                              i.show();      &#125;  &#125;\n\n匿名内部类匿名内部类一个没有名字的类，是内部类的简化写法\ninterface Inner &#123;      public abstract void show();&#125;  ​   class Outer &#123;      public void method()&#123;          new Inner() &#123;              public void show() &#123;                  System.out.println(&quot;HelloWorld&quot;);              &#125;          &#125;.show();      &#125;  &#125; class Test &#123;      public static void main(String[] args)  &#123;          Outer o = new Outer();                   o.method();      &#125;  &#125;\n\n内部类的特点\n内部类仍然是一个独立的类,在编译之后内部类会编译成独立的.class文件,但是前面冠以外部类的类名和$符号。\n内部类不能用普通的方式访问,内部类是外部类的一个成员,因此内部类可以自由访问外部类的成员变量，无论是否为 private 的。\n内部类声明成静态,就不能随便访问外部类的成员变量，仍然是只能访问外部类的静态成员变量\n\n内部类的意义\n封装性,内部类只服务于所在的外部类.\n\n实现多继承 \n\n\n\n儿子类     爸爸类   妈妈类\n儿子内部1 继承 爸爸类儿子内部2 继承 妈妈类\n\n\n用匿名内部类实现回调功能\n\n我们用通俗讲解就是说在Java中，通常就是编写一个接口，然后你来实现这个接口，然后把这个接口的一个对象作以参数的形式传到另一个程序方法中， 然后通过接口调用你的方法，匿名内部类就可以很好的展现了这一种回调功能\npublic interface Demo &#123;      void demoMethod();  &#125;    public class MyDemo&#123;      public test(Demo demo)&#123;          System.out.println(&quot;test method&quot;);      &#125;&#125;------------------------------------------------- public static void main(String[] args) &#123;          MyDemo md = new MyDemo();           md.test(new Demo)&#123;              public void demoMethod()&#123;                  System.out.println(&quot;具体实现接口&quot;)              &#125;          &#125;      &#125;  &#125;\n\n\n解决继承及实现接口出现同名方法的问题\n\n编写一个接口 Demo  public interface Demo &#123;      void test();  &#125;编写一个类 MyDemo  public class MyDemo &#123;      public void test() &#123;          System.out.println(&quot;父类的test方法&quot;);      &#125;   &#125;--------------------------------------------------public class DemoTest extends MyDemo  &#123;      private class inner implements Demo &#123;          public void test() &#123;              System.out.println(&quot;接口的test方法&quot;);          &#125;      &#125;     public Demo getIn() &#123;          return new inner();      &#125;&#125;\n\n","categories":["-javase"],"tags":["基础","内部类"]},{"title":"JDBC-数据库事务-事务的ACID属性-6.2","url":"http://example.com/2020/12/25/JDBC6-2数据事务ACID属性/","content":"事务的ACID属性\n原子性（Atomicity）原子性是指事务一个不可分的工作单位。事务中的操作要么都发生，要么都不发生\n\n一致性（Consistency）事务必须使数据库从一个一致性状态转换到另外以一个一致性状态\n\n隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务直接不能互相干扰\n\n持久性（Durability）持久性是指一个事务一旦被提交，他对数据库中数据打改变就是永久性的，接下来的而其他操作的数据库故障，不应该对其有任何影响\n\n\n\n\n数据库的并发问题对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制。就会出现各种并发的问题\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行\n\n数据库事务的隔离性数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。\n一个事务与其他事务隔离的程度称为隔离级别，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度。隔离级别越高，数据一致性就越好，并发性越差\n四种隔离级别\n数据库提供四种事务的隔离级别\n\n\n\n越往下并发性越差一致性越好，  Oracle 比mysql  并发性好  一致性差\n\nOracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。\nOracle 默认的事务隔离级别为: READ COMMITED （已读提交数据）\n\nMysql 支持 4 种事务隔离级别。\nMysql 默认的事务隔离级别为: REPEATABLE READ。（可重复的读）\n\n\n在java语言中设置隔离操作\n设置数据库的隔离级别：conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n\n获取当前连接的隔离级别\n System.out.println(conn.getTransactionIsolation());\n\n\n\n在MySql中设置隔离级别\n每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。\n\n查看当前的隔离级别: \nSELECT @@tx_isolation;\n\n设置当前 mySQL 连接的隔离级别:  \nset  transaction isolation level read committed;\n\n设置数据库系统的全局的隔离级别:\nset global transaction isolation level read committed;\n\n补充操作：\n\n创建mysql数据库用户：\ncreate user tom identified by &#39;abc123&#39;;\n\n授予权限\n#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;;  #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; \n\n\n\n\n\n\n\n\n\n\n\n代码测试：//*****************************************************@Testpublic  void testTransactionSelect() throws Exception &#123;    Connection conn = JDBCUtils.getConnection();    //获取当前连接的隔离级别    System.out.println(conn.getTransactionIsolation());    //设置数据库的隔离级别：    conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);    System.out.println(conn.getTransactionIsolation());    conn.setAutoCommit(false);    String sql = &quot;select user,password,balance from user_table where user = ?&quot;;    User user = getInstance(conn, User.class, sql, &quot;CC&quot;);    System.out.println(user);&#125;@Testpublic void testTransactionUpdate() throws Exception&#123;    Connection conn = JDBCUtils.getConnection();    //取消自动提交数据    conn.setAutoCommit(false);    String sql = &quot;update user_table set balance = ? where user = ?&quot;;    update1(conn, sql, 5000,&quot;CC&quot;);    Thread.sleep(15000);    System.out.println(&quot;修改结束&quot;);&#125;//通用查询数据库 用于返回数据库表中的一条数据（version 2.0：考虑上事务）public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) throws Exception &#123;    PreparedStatement ps = null;    ResultSet rs = null;    try &#123;        ps = conn.prepareStatement(sql);        for (int i = 0; i &lt; args.length; i++) &#123;            ps.setObject(i + 1, args[i]);        &#125;        rs = ps.executeQuery();        //获取结果集的元数据        ResultSetMetaData rsmd = rs.getMetaData();        //通过ResultSetMetaData 获取到结果集的列数        int columnCount = rsmd.getColumnCount();        if (rs.next()) &#123;            T t = clazz.newInstance();            for (int i = 0; i &lt; columnCount; i++) &#123;                Object columValue = rs.getObject(i + 1);                //获取每个列名                String columnLabel = rsmd.getColumnLabel(i + 1);                //// 给t对象指定的columnName属性，赋值为columValue：通过反射                // 给t对象指定的columnName属性，赋值为columValue：通过反射                Field field = clazz.getDeclaredField(columnLabel);                field.setAccessible(true);                field.set(t, columValue);            &#125;            return t;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        JDBCUtils.closeResource(null, ps, rs);    &#125;    return null;&#125;\n\n","categories":["-JDBC"],"tags":["事务处理","JDBC","数据库"]},{"title":"JDBC-数据库事务-JDBC事务处理-6.1","url":"http://example.com/2020/12/24/JDBC6-1数据库事务/","content":"数据库事务什么叫数据库事务\n事务:一组逻辑操作单元,使数据从一种状态到另外一种状态,一组逻辑操作单元,一个或者多个DML操作\n\n事务处理的原则:\n保证所有事务都为一个工作单元执行  即使出现了故障,都不能改变这种方式当一个事务中执行了多个操作时,要么所有的事务都被提交(**commit) , 那么这些修改就永久保存下来: 要么数据库管理系统将放弃所作的所有修改,整个事务回滚**(roolBack) 到最初始状态\n\nJDBC事务处理\n数据一旦提交 就不会发生回滚\n\n\n\n那些操作会导致数据的自动提交?DDL数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言\n\nDDL操作一旦执行,就会自动提交    set autocommit = false 对DDL操作失效\n\nDML数据操作语言，SQL中处理数据等操作统称为数据操纵语言\n\nDML默认情况下,一旦执行,就会自动提交\n\n我们通过set autocommit= false 的方式 取消DML操作的自动提交\n\n默认在关闭连接时,会自动的提交数据\n\nJDBC程序中为了让多个 SQL 语句作为一个事务执行\n调用Connection对象的setAutoCommit(flase): 以取消自动提交事务\n在所有的sql语句都成功执行后,调用commit(); 方法提交事务\n出现异常时.调用rollback(); 进行回滚事务\n\n\n若此时connection没有被关闭,还可能被被重复使用,则需要恢复其自动提交的状态\nsetAutoCommit(true) 尤其时使用数据库连接池技术时,执行close()方法前,建议恢复自动提交状态\n\n案例用户AA向用户BB转账100未考虑数据库事务情况下的转账操作:   @Test    public void testUpdate() &#123;        String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;        update(sql1, &quot;AA&quot;);        //模拟网络异常//        System.out.println(10 / 0);        String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;        update(sql2, &quot;BB&quot;);        System.out.println(&quot;转账成功&quot;);    &#125;    // 通用的增删改操作---version 1.0    public int update(String sql, Object... args) &#123;        Connection conn = null;        PreparedStatement ps = null;        try &#123;            //1, 获取数据库连接            conn = JDBCUtils.getConnection();            //2 预编译sql语句 返回PreparedStatement的实例            ps = conn.prepareStatement(sql);            //填充占位符            for (int i = 0; i &lt; args.length; i++) &#123;                ps.setObject(i + 1, args[i]);            &#125;            //执行            return ps.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //修改其为自动提交数据            //主要针对于使用数据库连接池的使用            try &#123;                conn.setAutoCommit(true);            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;            //关闭资源            JDBCUtils.closeResource(conn, ps);        &#125;        return 0;    &#125;\n\n出现问题:当模拟网络异常时,AA的钱扣除了,但是没有加到B中\n解决问题:考虑数据库事务后进行转账操作\n*1.什么叫数据库事务*  事务:一组逻辑操作单元,使数据从一种状态到另外一种状态*         &gt; 一组逻辑操作单元,一个或者多个DML操作*2. 事务处理的原则:保证所有事务都为一个工作单元执行  即使出现了故障,都不能改变这种方式* 当一个事务中执行了多个操作时,要么所有的事务都被提交(commit)  那么这些修改就永久保存下来* : 要么数据库管理系统将放弃所作的所有修改,整个事务回滚(roolBack) 到最初始状态\n\n\n\n\n\n\n\n\n\n考虑数据库事务后的转账操作注意:\n为了数据报错正常产生回滚\n\nupdate1(Connection conn, String sql, Object... args) 连接数据库由外部测试提供,也即是关闭连接是JDBCUtils.closeResource(null, ps);\n.取消自动提conn.setAutoCommit(false);\n所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务\n出现异常 调用 rollback(); 方法回滚事务\n\n\n @Test    public void testUpdateWithTx() &#123;        Connection conn = null;        try &#123;            conn = JDBCUtils.getConnection();            //1.取消自动提交            conn.setAutoCommit(false);            String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;            update1(conn, sql1, &quot;AA&quot;);            //模拟网路异常//            System.out.println(10 / 0);            String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;            update1(conn, sql2, &quot;BB&quot;);            System.out.println(&quot;转账成功&quot;);            //2 提交数据            conn.commit();        &#125; catch (Exception e) &#123;            e.printStackTrace();            //3 数据回滚            try &#123;                conn.rollback();            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;        &#125; finally &#123;            JDBCUtils.closeResource(conn, null);        &#125;    &#125;    // 通用的增删改操作---version 2.0    public int update1(Connection conn, String sql, Object... args) &#123;        PreparedStatement ps = null;        try &#123;            //1 预编译sql语句 返回PreparedStatement的实例            ps = conn.prepareStatement(sql);            //2 填充占位符            for (int i = 0; i &lt; args.length; i++) &#123;                ps.setObject(i + 1, args[i]);            &#125;            //3 执行            return ps.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;           //4 关闭资源            JDBCUtils.closeResource(null, ps);        &#125;        return 0;    &#125;\n\n连接数据库相关操作操作数据库的工具类package com.nie1.transaction.util;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * @Description 操作数据库的工具类 */public class JDBCUtils &#123;    /**     * @return     * @throws Exception     * @Description 获取数据库的连接     */    public static Connection getConnection() throws Exception &#123;        // 1.读取配置文件中的4个基本信息        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);        Properties pros = new Properties();        pros.load(is);        //2获取四个配置        String user = pros.getProperty(&quot;user&quot;);        String password = pros.getProperty(&quot;password&quot;);        String url = pros.getProperty(&quot;url&quot;);        String driverClass = pros.getProperty(&quot;driverClass&quot;);        // 3.加载驱动        Class.forName(driverClass);        // 4.获取连接        Connection conn = DriverManager.getConnection(url, user, password);        return conn;    &#125;    /**     * @Description 关闭连接和Statement的操作     */    public static void closeResource(Connection conn, Statement ps) &#123;        try &#123;            if (ps != null)                ps.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        try &#123;            if (conn != null)                conn.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * @Description 关闭资源操作     */    public static void closeResource(Connection conn, Statement ps, ResultSet rs) &#123;        try &#123;            if (ps != null)                ps.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        try &#123;            if (conn != null)                conn.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        try &#123;            if (rs != null)                rs.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n配置文件jdbc.properties#获取user=rootpassword=123123url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=truedriverClass=com.mysql.jdbc.Driver\n\n","categories":["-JDBC"],"tags":["事务处理","JDBC","数据库"]},{"title":"线索化二叉树","url":"http://example.com/2020/12/23/线索化二叉树/","content":"线索化二叉树将数列{1,3,6,8,10,14} 构成一个二叉树 : n+1=7\n问题分析:\n\n当我们对上面的二叉树进行中序遍历时,数列为{8,3,10,1,14,6}\n但是6,8,10,14 这几个节点的左右指针,并没有完全利用上\n如果我们希望充分的利用各个节点的左右指针,让各个节点可以指向自己的前后节点,\n解决方案—线索化二叉树\n\n线索化二叉树基本的介绍\nn个结点的二叉树中含有n+1 ____  [2n-(n-1)=n+1]个空指针域,利用二叉链表中的而空指针域,存放指向该结点在某种遍历次序下的前驱和后续结点的指针(这里的指针称为”线索”)\n这种加上了线索的二叉链表称为线索链表，   相应的二叉树称为线索二叉树,\n\n\n\n\n根据线索性质的不同,线索二叉树称为前序二叉树,中序二叉树,后续二叉树 \n一个结点的前一个结点,称为前驱结点\n一个结点的后一个结点,称为后续结点\n\n线索化二叉树应用案例\n\n案例说明: 将下的二叉树,进行中序线索二叉树,中序遍历的数列为{8,3,10,1,14,6}\n思路分析:中序遍历的结果为:{8, 3, 10, 1, 14, 6}  \n![73bcd26b6c0bbf05b07ac2123989558](C:/Users/LENOVO/AppData/Local/Temp/WeChat Files/73bcd26b6c0bbf05b07ac2123989558.png)\n说明:当前线索化二叉树后,node节点的属性 left和right  由一下情况\n\nleft指向的是左子树,也可能是值向的前驱节点,,,,,,比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.  \nright 指向的是右子树， 也可能是指向后继节点,,,,,,,比如 ① 节点 right 指向的是右子树， 而⑩ 节点的 right 指向的是后继节点  \n\n代码实现:准备工作1.如果遇到leftType&#x3D;&#x3D;0 表示指向左子树  如果是1  则表示前驱驱节点1.如果遇到rightTypeleftType&#x3D;&#x3D;0 表示指向左子树  如果是1  则表示前驱驱节点\n\nclass HerNode &#123;    private int no;    private String name;    private HerNode left;    private HerNode right;    //说明    /*    1.如果遇到leftType==0 表示指向左子树  如果是1  则表示前驱驱节点    1.如果遇到rightTypeleftType==0 表示指向左子树  如果是1  则表示前驱驱节点     */    private int leftType;    private int rightType;.........&#125;\n\n堆二叉树进行中序线索化的方法/** * 编写堆二叉树进行中序线索化的方法 * * @param node 当前需要线索化的方法 */public void threadNodes(HerNode node) &#123;    //如果node==null  不能线索化    if (node == null) &#123;        return;    &#125;    //1  线索化左子树    threadNodes(node.getLeft());    //2 线索化当前接结点    //以8来说 .left=null   8结点的.leftType=1;    if (node.getLeft() == null) &#123;        //当前结点指向做指针的想向前的前驱结点        node.setLeft(pre);        //修改当前结点的左指针的类型 指向前驱节点        node.setLeftType(1);    &#125;    //  处理后续结点    if (pre != null &amp;&amp; pre.getRight() == null) &#123;        //让前驱结点的右指针指向当前结点        pre.setRight(node);        //修改当前驱节点的右指针类型        pre.setRightType(1);    &#125;    //!!!每处理一个结点后 让当前结点是下一个结点的前驱结点    pre = node;    //3 在线索化右子树    threadNodes(node.getRight());&#125;\n\n遍历线索化二叉树的方法//遍历线索化二叉树的方法public void threadList() &#123;    //定义一个遍历 储存当前遍历的结点 由root开始    HerNode node = root;    while (node != null) &#123;        /*        循环的找到leftType==1 结点   第一个找到的就是8结点        后面随着遍历的变化 因为当leftType==1时,说明该节点是按照线索化        处理后的有效结点         */        while (node.getLeftType() == 0) &#123;            node = node.getLeft();        &#125;        //打印这个结点        System.out.println(node);        //如果当前结点的右指针指向的是后续结点 就一直输出        while (node.getRightType() == 1) &#123;            //获取到当前节点的后续结点            node = node.getRight();            System.out.println(node);        &#125;        node = node.getRight();    &#125;&#125;\n\n完整代码package com.nie.Bzhan.tree.ThreadedBinaryTreDemo;public class ThreadBinaryDemo &#123;    public static void main(String[] args) &#123;        //测试一把中序线索二叉树的功能        HerNode root = new HerNode(1, &quot;ttt&quot;);        HerNode node2 = new HerNode(3, &quot;ttt&quot;);        HerNode node3 = new HerNode(6, &quot;ttt&quot;);        HerNode node4 = new HerNode(8, &quot;ttt&quot;);        HerNode node5 = new HerNode(10, &quot;ttt&quot;);        HerNode node6 = new HerNode(14, &quot;ttt&quot;);        //二叉树   手动创建        root.setLeft(node2);        root.setRight(node3);        node2.setLeft(node4);        node2.setRight(node5);        node3.setLeft(node6);        //测试中序线索化        ThreadBinary threadBinary = new ThreadBinary();        threadBinary.setRoot(root);        threadBinary.threadNodes();        //测试: 以10号节点测试        HerNode leftNode = node5.getLeft();        HerNode rightNode = node5.getRight();        System.out.println(&quot;10号结点的前驱结点是 =&quot; + leftNode); //3        System.out.println(&quot;10号结点的后继结点是=&quot; + rightNode); //1        System.out.println(&quot;使用线索化的方式遍历 线索化二叉树&quot;);        threadBinary.threadList();    &#125;&#125;class ThreadBinary &#123;    private HerNode root;    //为了实现线索化，需要创建要给指向当前结点的前驱结点的指针    //在递归进行线索化时，pre 总是保留前一个结点    private HerNode pre = null;    //重载一把threadedNodes方法    public void threadNodes() &#123;        this.threadNodes(root);    &#125;    public HerNode getRoot() &#123;        return root;    &#125;    public void setRoot(HerNode root) &#123;        this.root = root;    &#125;    public HerNode getPre() &#123;        return pre;    &#125;    public void setPre(HerNode pre) &#123;        this.pre = pre;    &#125;    //遍历线索化二叉树的方法    public void threadList() &#123;        //定义一个遍历 储存当前遍历的结点 由root开始        HerNode node = root;        while (node != null) &#123;            /*            循环的找到leftType==1 结点   第一个找到的就是8结点            后面随着遍历的变化 因为当leftType==1时,说明该节点是按照线索化            处理后的有效结点             */            while (node.getLeftType() == 0) &#123;                node = node.getLeft();            &#125;            //打印这个结点            System.out.println(node);            //如果当前结点的右指针指向的是后续结点 就一直输出            while (node.getRightType() == 1) &#123;                //获取到当前节点的后续结点                node = node.getRight();                System.out.println(node);            &#125;            node = node.getRight();        &#125;    &#125;    /**     * 编写堆二叉树进行中序线索化的方法     *     * @param node 当前需要线索化的方法     */    public void threadNodes(HerNode node) &#123;        //如果node==null  不能线索化        if (node == null) &#123;            return;        &#125;        //1  线索化左子树        threadNodes(node.getLeft());        //2 线索化当前接结点        //以8来说 .left=null   8结点的.leftType=1;        if (node.getLeft() == null) &#123;            //当前结点指向做指针的想向前的前驱结点            node.setLeft(pre);            //修改当前结点的左指针的类型 指向前驱节点            node.setLeftType(1);        &#125;        //  处理后续结点        if (pre != null &amp;&amp; pre.getRight() == null) &#123;            //让前驱结点的右指针指向当前结点            pre.setRight(node);            //修改当前驱节点的右指针类型            pre.setRightType(1);        &#125;        //!!!每处理一个结点后 让当前结点是下一个结点的前驱结点        pre = node;        //3 在线索化右子树        threadNodes(node.getRight());    &#125;&#125;class HerNode &#123;    private int no;    private String name;    private HerNode left;    private HerNode right;    //说明    /*    1.如果遇到leftType==0 表示指向左子树  如果是1  则表示前驱驱节点    1.如果遇到rightTypeleftType==0 表示指向左子树  如果是1  则表示前驱驱节点     */    private int leftType;    private int rightType;    public HerNode(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public HerNode getLeft() &#123;        return left;    &#125;    public void setLeft(HerNode left) &#123;        this.left = left;    &#125;    public HerNode getRight() &#123;        return right;    &#125;    public void setRight(HerNode right) &#123;        this.right = right;    &#125;    public int getLeftType() &#123;        return leftType;    &#125;    public void setLeftType(int leftType) &#123;        this.leftType = leftType;    &#125;    public int getRightType() &#123;        return rightType;    &#125;    public void setRightType(int rightType) &#123;        this.rightType = rightType;    &#125;    @Override    public String toString() &#123;        return &quot;HerNode&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n线索化二叉树将数列{1,3,6,8,10,14} 构成一个二叉树 : n+1=7\n问题分析:\n\n当我们对上面的二叉树进行中序遍历时,数列为{8,3,10,1,14,6}\n但是6,8,10,14 这几个节点的左右指针,并没有完全利用上\n如果我们希望充分的利用各个节点的左右指针,让各个节点可以指向自己的前后节点,\n解决方案—线索化二叉树\n\n线索化二叉树基本的介绍\nn个结点的二叉树中含有n+1 ____  [2n-(n-1)=n+1]个空指针域,利用二叉链表中的而空指针域,存放指向该结点在某种遍历次序下的前驱和后续结点的指针(这里的指针称为”线索”)\n这种加上了线索的二叉链表称为线索链表，   相应的二叉树称为线索二叉树,\n根据线索性质的不同,线索二叉树称为前序二叉树,中序二叉树,后续二叉树  三种\n一个结点的前一个结点,称为前驱结点\n一个结点的后一个结点,称为后续结点\n\n线索化二叉树应用案例\n案例说明: 将下的二叉树,进行中序线索二叉树,中序遍历的数列为{8,3,10,1,14,6}\n思路分析:中序遍历的结果为:{8, 3, 10, 1, 14, 6}  \n\n说明:当前线索化二叉树后,node节点的属性 left和right  由一下情况\n\nleft指向的是左子树,也可能是值向的前驱节点,,,,,,比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.  \nright 指向的是右子树， 也可能是指向后继节点,,,,,,,比如 ① 节点 right 指向的是右子树， 而⑩ 节点的 right 指向的是后继节点  \n\n代码实现:准备工作1.如果遇到leftType&#x3D;&#x3D;0 表示指向左子树  如果是1  则表示前驱驱节点1.如果遇到rightTypeleftType&#x3D;&#x3D;0 表示指向左子树  如果是1  则表示前驱驱节点\n\nclass HerNode &#123;    private int no;    private String name;    private HerNode left;    private HerNode right;    //说明    /*    1.如果遇到leftType==0 表示指向左子树  如果是1  则表示前驱驱节点    1.如果遇到rightTypeleftType==0 表示指向左子树  如果是1  则表示前驱驱节点     */    private int leftType;    private int rightType;.........&#125;\n\n堆二叉树进行中序线索化的方法/** * 编写堆二叉树进行中序线索化的方法 * * @param node 当前需要线索化的方法 */public void threadNodes(HerNode node) &#123;    //如果node==null  不能线索化    if (node == null) &#123;        return;    &#125;    //1  线索化左子树    threadNodes(node.getLeft());    //2 线索化当前接结点    //以8来说 .left=null   8结点的.leftType=1;    if (node.getLeft() == null) &#123;        //当前结点指向做指针的想向前的前驱结点        node.setLeft(pre);        //修改当前结点的左指针的类型 指向前驱节点        node.setLeftType(1);    &#125;    //  处理后续结点    if (pre != null &amp;&amp; pre.getRight() == null) &#123;        //让前驱结点的右指针指向当前结点        pre.setRight(node);        //修改当前驱节点的右指针类型        pre.setRightType(1);    &#125;    //!!!每处理一个结点后 让当前结点是下一个结点的前驱结点    pre = node;    //3 在线索化右子树    threadNodes(node.getRight());&#125;\n\n遍历线索化二叉树的方法//遍历线索化二叉树的方法public void threadList() &#123;    //定义一个遍历 储存当前遍历的结点 由root开始    HerNode node = root;    while (node != null) &#123;        /*        循环的找到leftType==1 结点   第一个找到的就是8结点        后面随着遍历的变化 因为当leftType==1时,说明该节点是按照线索化        处理后的有效结点         */        while (node.getLeftType() == 0) &#123;            node = node.getLeft();        &#125;        //打印这个结点        System.out.println(node);        //如果当前结点的右指针指向的是后续结点 就一直输出        while (node.getRightType() == 1) &#123;            //获取到当前节点的后续结点            node = node.getRight();            System.out.println(node);        &#125;        node = node.getRight();    &#125;&#125;\n\n完整代码package com.nie.Bzhan.tree.ThreadedBinaryTreDemo;public class ThreadBinaryDemo &#123;    public static void main(String[] args) &#123;        //测试一把中序线索二叉树的功能        HerNode root = new HerNode(1, &quot;ttt&quot;);        HerNode node2 = new HerNode(3, &quot;ttt&quot;);        HerNode node3 = new HerNode(6, &quot;ttt&quot;);        HerNode node4 = new HerNode(8, &quot;ttt&quot;);        HerNode node5 = new HerNode(10, &quot;ttt&quot;);        HerNode node6 = new HerNode(14, &quot;ttt&quot;);        //二叉树   手动创建        root.setLeft(node2);        root.setRight(node3);        node2.setLeft(node4);        node2.setRight(node5);        node3.setLeft(node6);        //测试中序线索化        ThreadBinary threadBinary = new ThreadBinary();        threadBinary.setRoot(root);        threadBinary.threadNodes();        //测试: 以10号节点测试        HerNode leftNode = node5.getLeft();        HerNode rightNode = node5.getRight();        System.out.println(&quot;10号结点的前驱结点是 =&quot; + leftNode); //3        System.out.println(&quot;10号结点的后继结点是=&quot; + rightNode); //1        System.out.println(&quot;使用线索化的方式遍历 线索化二叉树&quot;);        threadBinary.threadList();    &#125;&#125;class ThreadBinary &#123;    private HerNode root;    //为了实现线索化，需要创建要给指向当前结点的前驱结点的指针    //在递归进行线索化时，pre 总是保留前一个结点    private HerNode pre = null;    //重载一把threadedNodes方法    public void threadNodes() &#123;        this.threadNodes(root);    &#125;    public HerNode getRoot() &#123;        return root;    &#125;    public void setRoot(HerNode root) &#123;        this.root = root;    &#125;    public HerNode getPre() &#123;        return pre;    &#125;    public void setPre(HerNode pre) &#123;        this.pre = pre;    &#125;    //遍历线索化二叉树的方法    public void threadList() &#123;        //定义一个遍历 储存当前遍历的结点 由root开始        HerNode node = root;        while (node != null) &#123;            /*            循环的找到leftType==1 结点   第一个找到的就是8结点            后面随着遍历的变化 因为当leftType==1时,说明该节点是按照线索化            处理后的有效结点             */            while (node.getLeftType() == 0) &#123;                node = node.getLeft();            &#125;            //打印这个结点            System.out.println(node);            //如果当前结点的右指针指向的是后续结点 就一直输出            while (node.getRightType() == 1) &#123;                //获取到当前节点的后续结点                node = node.getRight();                System.out.println(node);            &#125;            node = node.getRight();        &#125;    &#125;    /**     * 编写堆二叉树进行中序线索化的方法     *     * @param node 当前需要线索化的方法     */    public void threadNodes(HerNode node) &#123;        //如果node==null  不能线索化        if (node == null) &#123;            return;        &#125;        //1  线索化左子树        threadNodes(node.getLeft());        //2 线索化当前接结点        //以8来说 .left=null   8结点的.leftType=1;        if (node.getLeft() == null) &#123;            //当前结点指向做指针的想向前的前驱结点            node.setLeft(pre);            //修改当前结点的左指针的类型 指向前驱节点            node.setLeftType(1);        &#125;        //  处理后续结点        if (pre != null &amp;&amp; pre.getRight() == null) &#123;            //让前驱结点的右指针指向当前结点            pre.setRight(node);            //修改当前驱节点的右指针类型            pre.setRightType(1);        &#125;        //!!!每处理一个结点后 让当前结点是下一个结点的前驱结点        pre = node;        //3 在线索化右子树        threadNodes(node.getRight());    &#125;&#125;class HerNode &#123;    private int no;    private String name;    private HerNode left;    private HerNode right;    //说明    /*    1.如果遇到leftType==0 表示指向左子树  如果是1  则表示前驱驱节点    1.如果遇到rightTypeleftType==0 表示指向左子树  如果是1  则表示前驱驱节点     */    private int leftType;    private int rightType;    public HerNode(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public HerNode getLeft() &#123;        return left;    &#125;    public void setLeft(HerNode left) &#123;        this.left = left;    &#125;    public HerNode getRight() &#123;        return right;    &#125;    public void setRight(HerNode right) &#123;        this.right = right;    &#125;    public int getLeftType() &#123;        return leftType;    &#125;    public void setLeftType(int leftType) &#123;        this.leftType = leftType;    &#125;    public int getRightType() &#123;        return rightType;    &#125;    public void setRightType(int rightType) &#123;        this.rightType = rightType;    &#125;    @Override    public String toString() &#123;        return &quot;HerNode&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","二叉树","线索化二叉树"]},{"title":"B站顺序存储二叉树","url":"http://example.com/2020/12/22/B站顺序存储二叉树/","content":"顺序存储二叉树概念由数据的存储来看,数组存储方式和树的存储方式可以转换,即数组可以转换成树,树也可以转换称为数组\n顺序储存二叉树的特点:\n顺序二叉树通常就只考虑二叉树\n第n个元素的左子节点为2*n+1;\n第n个元素的右子节点为2*n+2;\n第n个元素的父节点为(n-1)/2;\nn 表示二叉树中的第n个元素\n\n\n\n\n需求: 给你一个数组 {1,2,3,4,5,6,7}， 要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为1,2,4,5,3,6,7  \n代码package com.nie.Bzhan.tree;/** * 顺序存储二叉树 */public class ArrBinaryTreeDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;;        //创建一个 数组二叉树  ArrBinaryTree        ArrBinaryTree tree = new ArrBinaryTree(arr);        tree.preOrder(0);    &#125;&#125;class ArrBinaryTree &#123;    private int[] arr;//存储数据结点的数组    public ArrBinaryTree(int[] arr) &#123;        this.arr = arr;    &#125;    public ArrBinaryTree() &#123;    &#125;    //完成顺序储存二叉树的前序遍历/    /**     * 输入二叉树的遍历     * @param index 数组的下标     */    public void preOrder(int index) &#123;        //如果数组为空 或者arr.length=0        if (arr == null || arr.length == 0) &#123;            System.out.println(&quot;如果数组为空,不能按照二叉树的前序遍历&quot;);        &#125;        //由于前序        //输出当前这个元素        System.out.println(arr[index]);        //向左递归        if ((index * 2 + 1) &lt; arr.length) &#123;            preOrder(2 * index + 1);        &#125;        if ((index * 2 + 2) &lt; arr.length) &#123;            preOrder(2 * index + 2);        &#125;    &#125;&#125;\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","二叉树"]},{"title":"javaSE24-反射","url":"http://example.com/2020/12/21/javaSE反射/","content":"反射反射就是根据字节码文件,反射类的信息,字段,方法,构造方法等类的内容,\n根据字节码文件创建对象,调用方法的技术\n反射的基础,是class的对象\n每一个类都有class属性\n每个对象都有getClass() 方法\nClass.forName(完整类名)\n\nClass.forName 返回Class对象时,回把参数指定的类加载到内存中\nClass&lt;?&gt; class7 = Person.class;   //没有执行Person类静态代码块, 说明Person类没有加载内存Class&lt;?&gt; class8 = Class.forName(&quot;com.bjpowernode.chapter08.demo01.Person&quot;);  //执行了静态代码块, 说明类加载了内存\n\n\n\n\n\n\n\n反射类的信息java.lang.reflect包中有反射相关的类\n\nclass1.getModifiers()        返回类的修饰符\nclass1.getName()            返回完整类名\nclass1.getSimpleName()        简易类名\nclass1.getSuperClass()        父类\nclass1.getInterfaces()        接口\n\n创建Class对象Class&lt;?&gt; class1 = String.class;    \n反射类的信息修饰类  Modifiers:修饰器class1.getModifiers();\nModifier.toString(mod);//整数转换为字符串\n类名Simple简单\nclass1.getName() 返回完整类名\nclass1.getSimpleName() //返回简易类名\n父名class1.getSuperClass();\nClass&lt;?&gt; superclass &#x3D; class1.getSuperclass();\t&#x2F;&#x2F;判断父类是否为Object\tif ( Object.class !&#x3D; superclass ) &#123;\t\tsb.append(&quot; extends &quot;);\t\tsb.append( superclass.getSimpleName() );\t\t\t\t&#125;\n\n\n\n接口getInterfaces()返回接口数组, 如果类没有实现接口,返回的数组长度为0\nclass1.getInterfaces();\nClass&lt;?&gt;[] interfaces &#x3D; class1.getInterfaces();if( interfaces.length &gt; 0 )&#123; \t\t&#x2F;&#x2F;实现了接口\tsb.append(&quot; implements &quot;);\t&#x2F;&#x2F;遍历接口数组\tfor( int i &#x3D; 0 ;  i&lt;interfaces.length ; i++)&#123;\t\tsb.append( interfaces[i].getSimpleName() );\t\t&#x2F;&#x2F;接口之间使用逗号分隔\t\tif ( i &lt; interfaces.length - 1) &#123;\t\t\tsb.append(&quot;,&quot;);\t\t&#125;\t&#125;&#125; \n\n\n\n\n\n\n\n通过反射技术访问字段\nclass1.getField(字段名)            返回指定字段名的公共字段\nclass1.getDeclaredField(字段名)    返回指定名称的字段(即使它是私有的)\nclass1.newInstance()             创建一个实例(创建一个对象)\nfield.set(对象名, 字段的值);             设置字段的值\nfield.get(对象名);                     返回字段的值\nfield.setAccessible(true);             设置字段的可访问性\n\n创建Class对象,​        Class&lt;?&gt; class1 = Person.class;\n反射name字段​    Field nameF = class1.getField(“name”);\n通过反射技术创建对象(实例),默认调用类的无参构造​    Object p1 = class1.newInstance();             //相当于new Person()\n设置字段的值nameF.set(p1, “lisi”);                 //p1.setName(“lisi”)\n返回字段的值​    System.out.println( p1 );​    System.out.println( nameF.get(p1) );        //p1.getName()\n访问私有字段 ageObject p1 = class1.newInstance(); \t\t\t//相当于new Person()Field ageF = class1.getField(&quot;age&quot;); \t\t//只能返回公共字段Field ageF = class1.getDeclaredField(&quot;age&quot;); \t\t//返回字段ageF.setAccessible(true); \t\t\t\t//设置字段的可访问性ageF.set(p1, 18);System.out.println( ageF.get(p1));System.out.println( p1 );\n\n通过反射技术调用方法\nclass1.getMethod(方法名,参数类型列表)  反射指定方法签名的公共方法\nmethod.invoke(实例名, 方法的实参列表)         调用方法\n\npublic static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;\t\t//1) 创建Class对象\t\tClass&lt;?&gt; class1 = Person.class;\t\t\t\t//2) 反射show()方法\t\tMethod showM = class1.getMethod(&quot;show&quot;, null);\t\t\t\t//3)通过反射技术创建实例\t\tObject obj = class1.newInstance();\t\t\t//new Person()\t\t\t\t//4)调用方法\t\tshowM.invoke(obj, null); \t\t//obj.show()\t\t\t\t//5)反射set(String, int)方法\t\tMethod setM = class1.getMethod(&quot;set&quot;, String.class , int.class );\t\tsetM.invoke(obj, &quot;lisi&quot;, 66);\t\t\t\tshowM.invoke(obj);\t\tSystem.out.println( obj );\t&#125;\n\n\n\n代码Person类public class Person &#123;\tstatic&#123;\t\tSystem.out.println(&quot;静态代码块, 在类加载内存后执行&quot;);\t&#125;\t\tpublic String name; \t\t\tprivate int age;\t\t@Override\tpublic String toString() &#123;\t\treturn &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;\t&#125;\t\tpublic void show() &#123;\t\tSystem.out.println(&quot;name:&quot; + name + &quot;,age:&quot; + age);\t&#125;\t\tpublic void set(String name, int age) &#123;\t\tthis.age = age;\t\tthis.name = name;\t&#125;\t&#125;\n\n创建Class对象的方式public class Test01 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//1) 每个类都有一个Class属性\t\tClass class1 = Test01.class;\t\t\t\t//2)每个 对象有getClass()\t\tClass class2 =  new Test01().getClass();\t\t\t\t//3) Class.forName()\t\tClass class3 = Class.forName(&quot;com.bjpowernode.chapter08.demo01.Test01&quot;);\t\t\t\tSystem.out.println( class1 );\t\t//\t\tSystem.out.println( class1 == class2 );\t\tSystem.out.println( class2 == class3 );\t\t \t\t//4)\t\tClass&lt;?&gt;  class4 = int.class;\t\tClass&lt;?&gt; class5 = Integer.class;\t\tSystem.out.println( class4 == class5 ); \t //false\t\tClass&lt;?&gt; class6 = Integer.TYPE;\t\tSystem.out.println( class4 == class6 ); \t//true\t\t\t\t//5) Class.forName()r返回Class对象时, 会把参数指定的类加载到内存中//\t\tClass&lt;?&gt; class7 = Person.class;   //没有执行Person类静态代码块, 说明Person类没有加载内存\t\tClass&lt;?&gt; class8 = Class.forName(&quot;com.bjpowernode.chapter08.demo01.Person&quot;);  //执行了静态代码块, 说明类加载了内存\t\t\t\t\t&#125;&#125;\n\n反射类的信息public class Test02 &#123;\tpublic static void main(String[] args) &#123;\t\t//1)创建Class对象\t\tClass&lt;?&gt; class1 = String.class;\t\t\t\t//\t\tClass&lt;?&gt; class1 = Integer.class;\t\t\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\t\t//2)反射类的信息\t\t//2.1 修饰符\t\tint mod = class1.getModifiers(); \t\t//方法返回类的修饰符,是一个整数\t\tString modifier = Modifier.toString(mod);//整数转换为字符串\t\tsb.append( modifier );\t\t//2.2 类名\t\tsb.append(&quot; class  &quot;);//\t\tsb.append( class1.getName() ) ; \t\t//getName()r返回完整类名 \t\tsb.append( class1.getSimpleName() ) ; \t//返回简易类名 \t\t\t\t//2.3 父类\t\tClass&lt;?&gt; superclass = class1.getSuperclass();\t\t//判断父类是否为Object\t\tif ( Object.class != superclass ) &#123;\t\t\tsb.append(&quot; extends &quot;);\t\t\tsb.append( superclass.getSimpleName() );\t\t\t\t\t&#125;\t\t\t\t//2.4 接口,getInterfaces()返回接口数组, 如果类没有实现接口,返回的数组长度为0\t\tClass&lt;?&gt;[] interfaces = class1.getInterfaces();\t\tif( interfaces.length &gt; 0 )&#123; \t\t//实现了接口\t\t\tsb.append(&quot; implements &quot;);\t\t\t//遍历接口数组\t\t\tfor( int i = 0 ;  i&lt;interfaces.length ; i++)&#123;\t\t\t\tsb.append( interfaces[i].getSimpleName() );\t\t\t\t//接口之间使用逗号分隔\t\t\t\tif ( i &lt; interfaces.length - 1) &#123;\t\t\t\t\tsb.append(&quot;,&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; \t\t\t\tSystem.out.println( sb );\t&#125;&#125;\n\n通过反射技术访问字段public class Test03 &#123;\tpublic static void main(String[] args) throws NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException &#123;\t\t//1) 创建Class对象, \t\tClass&lt;?&gt; class1 = Person.class;\t\t\t\t//2) 反射name字段\t\tField nameF = class1.getField(&quot;name&quot;);\t\t\t\t//3) 通过反射技术创建对象(实例), 默认调用类的无参构造\t\tObject p1 = class1.newInstance(); \t\t\t//相当于new Person()\t\t\t\t//4)设置字段的值\t\tnameF.set(p1, &quot;lisi&quot;); \t\t\t\t//p1.setName(&quot;lisi&quot;)\t\t\t\t//5)返回字段的值\t\tSystem.out.println( p1 );\t\tSystem.out.println( nameF.get(p1) );\t\t//p1.getName()\t\t\t\t//6)访问私有字段: age//\t\tField ageF = class1.getField(&quot;age&quot;); \t\t//只能返回公共字段\t\tField ageF = class1.getDeclaredField(&quot;age&quot;); \t\t//返回字段\t\tageF.setAccessible(true); \t\t\t\t//设置字段的可访问性\t\tageF.set(p1, 18);\t\tSystem.out.println( ageF.get(p1));\t\tSystem.out.println( p1 );\t&#125;&#125;\n\n通过反射技术调用方法public class Test04 &#123;\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;\t\t//1) 创建Class对象\t\tClass&lt;?&gt; class1 = Person.class;\t\t\t\t//2) 反射show()方法\t\tMethod showM = class1.getMethod(&quot;show&quot;, null);\t\t\t\t//3)通过反射技术创建实例\t\tObject obj = class1.newInstance();\t\t\t//new Person()\t\t\t\t//4)调用方法\t\tshowM.invoke(obj, null); \t\t//obj.show()\t\t\t\t//5)反射set(String, int)方法\t\tMethod setM = class1.getMethod(&quot;set&quot;, String.class , int.class );\t\tsetM.invoke(obj, &quot;lisi&quot;, 66);\t\t\t\tshowM.invoke(obj);\t\tSystem.out.println( obj );\t&#125;&#125;\n\n","categories":["-javase"],"tags":["基础","反射"]},{"title":"十大排序8堆排序","url":"http://example.com/2020/12/20/十大排序8堆排序/","content":"堆排序基本介绍\n堆排序是利用堆这种数据结构二设计的一种排序算法,堆排序是一种选择排序,他的最好最坏,平均复杂度都为O(nlogn)， 它也是不稳定排序  \n堆是具有一下性质的完全二叉树:每个节点的值都大于或者等于其左右孩子节点的值,称为大顶堆,,没有要求结点的左孩子的值和右孩子的值的关系\n每个结点的值都小于或等于其左右孩子结点的值， 称为小顶堆  \n\n大顶堆举例说明\n\n\n\n堆排序的基本思想:\n将待排序序列构造成一个大顶堆\n此时,整个序列的最大值就是堆顶的根节点\n将其与末尾元素进行交换， 此时末尾就为最大值  \n然后将剩余的n-1个元素重新构造一个堆,这样会得到n个元素的次小值,如此反复执行,便可以得到一个有序序列\n\n可以看到在构建大顶堆的过程中， 元素的个数逐渐减少， 最后就得到一个有序序列了.  \n简单的思路\n将无序序列构建成一个堆,根据升序降序需求选择大顶堆或小顶堆\n将堆顶与末尾元素进行交换,将最大元素”沉”到数组末端\n重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序  \n\n代码实现将一个数组(二叉树), 调整成一个大顶堆//将一个数组(二叉树), 调整成一个大顶堆/** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125; * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */public  static void adjustHeap(int arr[], int i, int lenght) &#123;\t\tint temp = arr[i];//先取出当前元素的值，保存在临时变量\t//开始调整\t//说明\t//1. k = i * 2 + 1 k 是 i结点的左子结点\tfor(int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) &#123;\t\tif(k+1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k+1]) &#123; //说明左子结点的值小于右子结点的值\t\t\tk++; // k 指向右子结点\t\t&#125;\t\tif(arr[k] &gt; temp) &#123; //如果子结点大于父结点\t\t\tarr[i] = arr[k]; //把较大的值赋给当前结点\t\t\ti = k; //!!! i 指向 k,继续循环比较\t\t&#125; else &#123;\t\t\tbreak;//!\t\t&#125;\t&#125;\t//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)\tarr[i] = temp;//将temp值放到调整后的位置&#125;\n\n//编写一个堆排序的方法public static void heapSort(int arr[]) &#123;\tint temp = 0;\tSystem.out.println(&quot;堆排序!!&quot;);\t\tfor(int i = arr.length / 2 -1; i &gt;=0; i--) &#123;\t\tadjustHeap(arr, i, arr.length);\t&#125;\t\t/*\t * 2).将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;　　\t\t\t3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。\t */\tfor(int j = arr.length-1;j &gt;0; j--) &#123;\t\t//交换\t\ttemp = arr[j];\t\tarr[j] = arr[0];\t\tarr[0] = temp;\t\tadjustHeap(arr, 0, j); \t&#125;\t\t//System.out.println(&quot;数组=&quot; + Arrays.toString(arr)); \t&#125;\n\n完整代码package com.nie.Bzhan.tree;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class BinaryTreeDemo &#123;    public static void main(String[] args) &#123;        int arr[] = &#123;4, 6, 8, 5, 9&#125;;        Date date = new Date();        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:sss&quot;);        System.out.println(format.format(date));        heapSort(arr);        System.out.println(Arrays.toString(arr));    &#125;    public static void heapSort(int arr[]) &#123;        int temp = 0;        System.out.println(&quot;堆排序&quot;);        //将无序序列构建成一个堆,  大堆 或者小堆        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;            adjustHeap(arr, i, arr.length);        &#125;        for (int j = arr.length  - 1; j &gt; 0; j--) &#123;            //交换            temp = arr[j];            arr[j] = arr[0];            arr[0] = temp;            adjustHeap(arr, 0, j);        &#125;    &#125;    //降一个数组(二叉树) 调整为一个大顶堆    /**     * @param arr    待调整的数组     * @param i      非叶子节点在数组中索引     * @param length 表示对多少和元素的继续调整  length在逐渐减少     */    public static void adjustHeap(int arr[], int i, int length) &#123;        int temp = arr[i];//先取出当前的元素的值,保存在临时变量中        //开始调整        //说明        for (int k = 2 * 1 + 1; k &lt; length; k = k * 2 + 1) &#123;            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;                //说明左子节点的值小于右子节点                k++;            &#125;            if (arr[k] &gt; temp) &#123;//如果子节点大于夫节点                arr[i] = arr[k];//把较大的值赋给当前节点                i = k;//!! i指向k 继续循环比较            &#125; else &#123;                break;//!            &#125;        &#125;        //当for循环结束后 我们已经将以i位父节点的树的最大值,放在了顶部        arr[i] = temp;//将temp值放在调整后的位置    &#125;&#125;\n\n总结:平均时间复杂度O(nlogn)\n最好情况 O(nlogn)\n最坏情况 O(nlogn)\n空间复杂度 O(1)\n排序方式 in-place\n稳定性 不稳定\n图解:\n\n","categories":["-算法"],"tags":["二叉树","排序","十大排序"]},{"title":"二叉树基本实现-遍历.查找.删除{JAVA}","url":"http://example.com/2020/12/17/Java二叉树基本实现/","content":"树结构的基础部分二叉树为什么要使用二叉树\n数组方式的分析:\n\n优点:通过下标方式访问元素,速度快,对于有序数组,还可以通过二分查找提高检索速度\n缺点: 如果要检索具体某个值,或者插入值(按一定的顺序)回整体移动,效率低.\n2 链式储存方式的分析:\n优点: 在一定程度上对数组储存方式的优化(比如:插入一个数值节点,只需要将插入节点,链接到链表中即可,删除效率也很好)\n缺点: 在进行检索,效率仍然低,比如(检索某个值,需要从头节点开始遍历)\n3 树存储方式的分析\n能够提高数据储存,读取的效率.比如利用 二叉排序树(Binary Sort Tree)， 既可以保证数据的检索速度， 同时也可以保证数据的插入， 删除， 修改的速度。   \n  \n\n\n\n树示意图\n树的重用术语\n\n节点\n根节点\n父节点\n子节点\n叶子节点 (没有子节点的节点)\n节点的权(节点值)\n路径(从 root 节点找到该节点的路线)\n层\n子树\n树的高度(最大层数)\n森林 :多颗子树构成森林  \n\n二叉树的概念\n树有很多种,每个节点最多只能由两个子节点的一种形式称为二叉树\n二叉树的子节点分为左节点和右节点\n示意图\n\n满二叉树  如果该二叉树的所有叶子节点都在最后一层， 并且结点总数= 2^n -1 , n 为层数，   \n\n完全二叉树  如果该二叉树的所有叶子节点都在最后一层或者倒数第二层， 而且最后一层的叶子节点在左边连续， 倒数第二层的叶子节点在右边连续，   \n\n二叉树遍历的说明\n使用前中 后序对下列二叉树进行遍历\n\n前序遍历: 先输出父节点,在遍历左子树和右子树\n中序遍历: 先遍历左子树,在输出父子节点,在遍历右子树\n后序遍历:先遍历左子树， 再遍历右子树， 最后输出父节点  \n小结: 看输出父节点的顺序， 就确定是前序， 中序还是后序  \n\n案例分析\n\n\n前序遍历的方法//编写前序遍历的方法public void preOrder() &#123;\tSystem.out.println(this); //先输出父结点\t//递归向左子树前序遍历\tif(this.left != null) &#123;\t\tthis.left.preOrder();\t&#125;\t//递归向右子树前序遍历\tif(this.right != null) &#123;\t\tthis.right.preOrder();\t&#125;&#125;\n\n\n\n中序遍历public void infixOrder() &#123;\t\t\t\t//递归向左子树中序遍历\t\tif(this.left != null) &#123;\t\t\tthis.left.infixOrder();\t\t&#125;\t\t//输出父结点\t\tSystem.out.println(this);\t\t//递归向右子树中序遍历\t\tif(this.right != null) &#123;\t\t\tthis.right.infixOrder();\t\t&#125;\t&#125;\n\n\n\n后序遍历public void postOrder() &#123;\tif(this.left != null) &#123;\t\tthis.left.postOrder();\t&#125;\tif(this.right != null) &#123;\t\tthis.right.postOrder();\t&#125;\tSystem.out.println(this);&#125;\n\n\n\n\n二叉树-查找指定节点  前序遍历查找\n比较当前结点是不是\n则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找如果左递归前序查找，找到结点，则返回\n左递归前序查找，找到结点，则返回，否继续判断，当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找\n\npublic HeroNode preOrderSearch(int no) &#123;\tSystem.out.println(&quot;进入前序遍历&quot;);\t//比较当前结点是不是\tif(this.no == no) &#123;\t\treturn this;\t&#125;\t//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找\t//2.如果左递归前序查找，找到结点，则返回\tHeroNode resNode = null;\tif(this.left != null) &#123;\t\tresNode = this.left.preOrderSearch(no);\t&#125;\tif(resNode != null) &#123;//说明我们左子树找到\t\treturn resNode;\t&#125;\t//1.左递归前序查找，找到结点，则返回，否继续判断，\t//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找\tif(this.right != null) &#123;\t\tresNode = this.right.preOrderSearch(no);\t&#125;\treturn resNode;&#125;\n\n中序遍历查找//中序遍历查找public HeroNode infixOrderSearch(int no) &#123;\t//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找\tHeroNode resNode = null;\tif(this.left != null) &#123;\t\tresNode = this.left.infixOrderSearch(no);\t&#125;\tif(resNode != null) &#123;\t\treturn resNode;\t&#125;\tSystem.out.println(&quot;进入中序查找&quot;);\t//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点\tif(this.no == no) &#123;\t\treturn this;\t&#125;\t//否则继续进行右递归的中序查找\tif(this.right != null) &#123;\t\tresNode = this.right.infixOrderSearch(no);\t&#125;\treturn resNode;\t&#125;\n\n后序遍历查找public HeroNode postOrderSearch(int no) &#123;\t\t//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找\tHeroNode resNode = null;\tif(this.left != null) &#123;\t\tresNode = this.left.postOrderSearch(no);\t&#125;\tif(resNode != null) &#123;//说明在左子树找到\t\treturn resNode;\t&#125;\t\t//如果左子树没有找到，则向右子树递归进行后序遍历查找\tif(this.right != null) &#123;\t\tresNode = this.right.postOrderSearch(no);\t&#125;\tif(resNode != null) &#123;\t\treturn resNode;\t&#125;\tSystem.out.println(&quot;进入后序查找&quot;);\t//如果左右子树都没有找到，就比较当前结点是不是\tif(this.no == no) &#123;\t\treturn this;\t&#125;\treturn resNode;&#125;\n\n\n\n\n二叉树-删除节点要求:\n如果删除的节点是叶子节点， 则删除该节点  \n如果删除的节点是非叶子节点， 则删除该子树.  \n测试， 删除掉 5 号叶子节点 和 3 号子树.  \n完成删除思路分析  \n\n代码实现递归删除结点​    //1.如果删除的节点是叶子节点，则删除该节点​    //2.如果删除的节点是非叶子节点，则删除该子树\n\n因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.\n如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)\n如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)\n如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除\n如果第4步也没有删除结点，则应当向右子树进行递归删除.\n\n\n\n\nHeroNode 类增加方法  \npublic void delNode(int no) &#123;\t */\t//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)\tif(this.left != null &amp;&amp; this.left.no == no) &#123;\t\tthis.left = null;\t\treturn;\t&#125;\t//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)\tif(this.right != null &amp;&amp; this.right.no == no) &#123;\t\tthis.right = null;\t\treturn;\t&#125;\t//4.我们就需要向左子树进行递归删除\tif(this.left != null) &#123;\t\tthis.left.delNode(no);\t&#125;\t//5.则应当向右子树进行递归删除\tif(this.right != null) &#123;\t\tthis.right.delNode(no);\t&#125;&#125;\n\n\n\n\n在 BinaryTree 类增加方法  \npublic void delNode(int no) &#123;\tif(root != null) &#123;\t\t//如果只有一个root结点, 这里立即判断root是不是就是要删除结点\t\tif(root.getNo() == no) &#123;\t\t\troot = null;\t\t&#125; else &#123;\t\t\t//递归删除\t\t\troot.delNode(no);\t\t&#125;\t&#125;else&#123;\t\tSystem.out.println(&quot;空树，不能删除~&quot;);\t&#125;&#125;\n\n\n\n\n完整代码package com.nie.Bzhan.tree;import sun.reflect.generics.tree.Tree;public class BinaryTreeDem01 &#123;    public static void main(String[] args) &#123;        //先需要创建一颗二叉树        BinaryTree tree = new BinaryTree();        //创建需要的结点        HeroNode root = new HeroNode(1, &quot;宋江&quot;);        HeroNode node2 = new HeroNode(2, &quot;吴用&quot;);        HeroNode node3 = new HeroNode(3, &quot;卢俊义&quot;);        HeroNode node4 = new HeroNode(4, &quot;林冲&quot;);        HeroNode node5 = new HeroNode(5, &quot;关胜&quot;);        //我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树        root.setLeft(node2);        root.setRight(node3);        node3.setRight(node4);        node3.setLeft(node5);        tree.setRoot(root);        //测试        System.out.println(&quot;前序遍历&quot;);        tree.preOrder1();// 1,2,3,5,4        //测试        System.out.println(&quot;中序遍历&quot;);        tree.infixOrder1();// 2,1,5,3,4        //后续遍历        System.out.println(&quot;后序遍历&quot;);        tree.postOrder1(); // 2,5,4,3,1        System.out.println(&quot;++++++++++++++++++++++++++&quot;);        //前序遍历查找        System.out.println(&quot;前序遍历查找-----&quot;);        HeroNode resnode = tree.preOrderSerch1(5);        if (resnode != null) &#123;            System.out.println(&quot;找到了&quot; + resnode.getNo() + &quot;\\t&quot; + resnode.getName());        &#125; else &#123;            System.out.println(&quot;没有找到&quot; + 5 + &quot;信息&quot;);        &#125;        //中序遍历查找        System.out.println(&quot;中序遍历查找-----&quot;);        HeroNode resnode1 = tree.infixOrderSearch1(5);        if (resnode != null) &#123;            System.out.println(&quot;找到了&quot; + resnode1.getNo() + &quot;\\t&quot; + resnode1.getName());        &#125; else &#123;            System.out.println(&quot;没有找到&quot; + 5 + &quot;信息&quot;);        &#125;        //后续遍历查找        System.out.println(&quot;后序遍历查找-----&quot;);        HeroNode resnode2 = tree.postOrderSearch1(5);        if (resnode != null) &#123;            System.out.println(&quot;找到了&quot; + resnode2.getNo() + &quot;\\t&quot; + resnode2.getName());        &#125; else &#123;            System.out.println(&quot;没有找到&quot; + 5 + &quot;信息&quot;);        &#125;        //测试一次删除结点        System.out.println(&quot;删除前,前序遍历&quot;);        tree.preOrder1();        tree.delNode(5);        System.out.println(&quot;删除后，前序遍历&quot;);        tree.preOrder1(); // 1,2,3,4    &#125;&#125;class BinaryTree &#123;    private HeroNode root;    public HeroNode getRoot() &#123;        return root;    &#125;    public void setRoot(HeroNode root) &#123;        this.root = root;    &#125;    //删除节点    public void delNode(int no) &#123;        if (root != null) &#123;            ////如果只有一个root结点, 这里立即判断root是不是就是要删除结点            if (root.getNo() == no) &#123;                root = null;            &#125; else &#123;                root.delNode(no);            &#125;        &#125; else &#123;            System.out.println(&quot;空树 不能删除&quot;);        &#125;    &#125;    //中序遍历    public void preOrder1() &#123;        if (this.root != null) &#123;            this.root.preOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空&quot;);        &#125;    &#125;    //中序遍历    public void infixOrder1() &#123;        if (this.root != null) &#123;            this.root.infiXOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空&quot;);        &#125;    &#125;    //后序遍历    public void postOrder1() &#123;        if (this.root != null) &#123;            this.root.postOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空&quot;);        &#125;    &#125;    //前需遍历查找    public HeroNode preOrderSerch1(int no) &#123;        if (root != null) &#123;            return root.preOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;    //中序遍历查找    public HeroNode infixOrderSearch1(int no) &#123;        if (root != null) &#123;            return root.infixOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;    //后续遍历查找    public HeroNode postOrderSearch1(int no) &#123;        if (root != null) &#123;            return root.postOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;&#125;/** * 创建HeroNode节点 */class HeroNode &#123;    private int no;    private String name;    private HeroNode left;//默认为空    private HeroNode right;//默认为空    public HeroNode(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public HeroNode getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode left) &#123;        this.left = left;    &#125;    public HeroNode getRight() &#123;        return right;    &#125;    public void setRight(HeroNode right) &#123;        this.right = right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    /*    前序遍历方法     */    public void preOrder() &#123;        System.out.println(this);//输出父节点        //向左递归        if (this.left != null) &#123;            this.left.preOrder();        &#125;        //向右递归        if (this.right != null) &#123;            this.right.preOrder();        &#125;    &#125;    /*   中序遍历方法    */    public void infiXOrder() &#123;        //向左递归        if (this.left != null) &#123;            this.left.infiXOrder();        &#125;        System.out.println(this);//输出父节点        //向右递归        if (this.right != null) &#123;            this.right.infiXOrder();        &#125;    &#125;    /* 后序遍历方法  */    public void postOrder() &#123;        //向左递归        if (this.left != null) &#123;            this.left.postOrder();        &#125;        //向右递归        if (this.right != null) &#123;            this.right.postOrder();        &#125;        System.out.println(this);//输出父节点    &#125;    /**     * 前序遍历查找     *     * @param no 查找no     * @return 如果找到就返回该Node ,如果没有找到返回 null     */    public HeroNode preOrderSearch(int no) &#123;        //比较当前结点是不是        if (this.no == no) &#123;            return this;        &#125;        //则判断当前结点的左结点是否为空,如果不为空,则递归前需查找        // 如果左递归前序查找,找到结点,则返回        HeroNode resNode = null;        if (this.left != null) &#123;            resNode = this.left.preOrderSearch(no);        &#125;        if (resNode != null) &#123;//说明我们左子树找到  退出            return resNode;        &#125;        //左递归前序查找，找到结点，则返回，否继续判断，        //当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找        if (this.right != null) &#123;            resNode = this.right.preOrderSearch(no);        &#125;        return resNode;    &#125;    /**     * 中序遍历查找     *     * @param no 查找no     * @return 如果找到就返回该Node ,如果没有找到返回 null     */    public HeroNode infixOrderSearch(int no) &#123;        //则判断当前结点的左结点是否为空,如果不为空,则递归前需查找        // 如果左递归前序查找,找到结点,则返回        HeroNode resNode = null;        if (this.left != null) &#123;            resNode = this.left.infixOrderSearch(no);        &#125;        if (resNode != null) &#123;//说明我们左子树找到  退出            return resNode;        &#125;        System.out.println(&quot;进入中序查找&quot;);        //比较当前结点是不是        if (this.no == no) &#123;            return this;        &#125;        //左递归前序查找，找到结点，则返回，否继续判断，        //当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找        if (this.right != null) &#123;            resNode = this.right.infixOrderSearch(no);        &#125;        return resNode;    &#125;    /**     * 后序遍历查找     *     * @param no 查找no     * @return 如果找到就返回该Node ,如果没有找到返回 null     */    public HeroNode postOrderSearch(int no) &#123;        //则判断当前结点的左结点是否为空,如果不为空,则递归前需查找        // 如果左递归前序查找,找到结点,则返回        HeroNode resNode = null;        if (this.left != null) &#123;            resNode = this.left.postOrderSearch(no);        &#125;        if (resNode != null) &#123;//说明我们左子树找到  退出            return resNode;        &#125;        //左递归前序查找，找到结点，则返回，否继续判断，        //当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找        if (this.right != null) &#123;            resNode = this.right.postOrderSearch(no);        &#125;        if (resNode != null) &#123;//说明我们左子树找到  退出            return resNode;        &#125;        System.out.println(&quot;进入中序查找&quot;);        //比较当前结点是不是        if (this.no == no) &#123;            return this;        &#125;        return resNode;    &#125;    /**     * 递归删除结点     *     * @param no 要删除的结点     */    public void delNode(int no) &#123;        //思路    /*    1. 因为我们的二叉树单向的,所以我们判断当前节点结点子节点是否是需要删除的结点,而不能去判断当前这个结点是不是需要删除结点.    2. 如果当前结点的左结点 不为空, 而且左子节点 就是要删除的结点,就将就将this.left = null; 并且就返回(结束递归删除    3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)    4.如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除    5,如果第4步也没有删除结点，则应当向右子树进行递归删除.     */        //如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)        if (this.left != null &amp;&amp; this.left.no == no) &#123;            this.left = null;            return;        &#125;        //如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)        if (this.right != null &amp;&amp; this.right.no == no) &#123;            this.right = null;            return;        &#125;        //我们需要向左子树进行递归删除        if (this.left != null) &#123;            this.left.delNode(no);        &#125;        //5.则应当向右子树进行递归删除        if (this.right != null) &#123;            this.right.delNode(no);        &#125;    &#125;&#125;\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","二叉树"]},{"title":"LC121-买卖股票的最佳时机","url":"http://example.com/2020/12/16/LC121/","content":"121. 买卖股票的最佳时机难度简单1344\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n注意：你不能在买入股票前卖出股票。\n示例 1:\n输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票\n\n \n\n解法一:暴力破解法\n利用两次for循环进行遍历\npublic int maxProfit(int[] prices) &#123;    if (prices.length &lt; 2) &#123;        return 0;    &#125;    int max = 0;    for (int i = 0; i &lt; prices.length - 1; i++) &#123;        for (int j = i + 1; j &lt; prices.length; j++) &#123;            max = Math.max(max, prices[j] - prices[i]);        &#125;    &#125;    return max;&#125;\n\n解法二:最低点买入\n算法只是动态记录最小值和最大利益，遍历完一次后就得到了最大利益。\n相关详解\npublic int maxProfit2(int[] prices) &#123;     int minPrice = Integer.MAX_VALUE;     int maxPrice = 0;     for (int i = 0; i &lt; prices.length; i++) &#123;         if (prices[i] &lt; minPrice) &#123;             minPrice = prices[i];         &#125; else &#123;             maxPrice = Math.max(maxPrice, (prices[i] - minPrice));         &#125;     &#125;     return maxPrice; &#125;\n\n解法三: 动态规划\n动态规划三种解法的相关详解\n动态规划就是,空间换取时间\n这是一个买入和卖出的过程，而且能交易一次即只能买卖一次，所以买入之后，状态可以转换到卖出，但是卖出之后就不能再买入了，因为只能买卖一次\n第三天卖出的利润就变了卖出收益是：第二天买入的值-1，加上第三天的股票价格，也就是前一天买入的最大收益 -1加上第三天的股票价格5，于是第三天买入的收益就变成了4买入的收益是：第二天买入的值-1vs第三天买入的股价-5，选择不动\n\n第i天卖出的最大收益计算公式为：\ni-1天卖出的最大收益 vs i-1天买入的最大收益+第i天的股价sell[i] = max(sell[i-1],buy[i-1]+prices[i])第i天买入的最大收益计算公式为：(注意第i天前面有个负号)\ni-1天买入的最大收益 vs -第i天的股价buy[i] = max(buy[i-1],-prices[i])\npublic int maxProfit4(int[] prices) &#123;    if (prices == null || prices.length == 0) &#123;        return 0;    &#125;    int n = prices.length;    int[] sell = new int[n];    int[] buy = new int[n];    //初始化第一天的收益    sell[0] = 0;    buy[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;        //第i天卖出的收益 = max(第i-1天卖出的收益,第i-1天买入收益+当天股价)        sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);        //第i天买入的收益=max(第i-1天买入收益，-当天股价)        buy[i] = Math.max(buy[i - 1], -prices[i]);    &#125;    return Math.max(sell[n - 1], buy[n - 1]);&#125;\n\n","categories":["-算法"],"tags":["LeetCode","动态规划","数组"]},{"title":"javaSE23-线程同步","url":"http://example.com/2020/12/16/java线程02/","content":"线程同步并发与并行\n\n并行：多个CPU同时执行多个任务,  比如: 多个人同时做不同的事\n并发: 一个CPU(采用时间片)同时执行多个任务,比如: 秒杀,多个人做同一件事\n\n线程同步:\n\n多个线程同时读写同一份共享资源,可能会引起从图,所以引入线程”同步”机制,即各线程要有先来后到\n\n同步就是排队+锁:\n\n几个线程之间要排队,一个个对共享资源操作,而不是同时进行操作\n为了保证数据在方法中被访问的正确性,在访问时加入锁机制\n\n  \n\n模拟卖票\n两个窗口分别售票,票数为10张分别使用继承Thread和实现Runnable两种方式实现\n\n\n继承Thread:       线程代码存放Thread子类run方法中。实现Runnable：线程代码存在接口的子类的run方法\n实现Runnable的好处1）避免了单继承的局限性\n2）多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源\n\n\n\n\n确保一个时间点只有一个线程访问共享资源,可以给共享资源加一把锁,这把锁只有一把钥匙,哪个线程获取了这把钥匙,才有权利范文该共享资源\n在java 代码中实现同步\n使用synchronized(同步监视器)关键字同步方法或代码块。\nsynchronized (同步监视器）&#123;       // 需要被同步的代码； &#125;\n\n\n\nsynchronized还可以放在方法声明中，表示整个方法,为同步方法。例如：\n public synchronized void show (String name)&#123;                &#x2F;&#x2F; 需要被同步的代码；&#125;\n\n\n\n同步监视器 \n\n同步监视器可以是任何对象,必须唯一,保证多个线程获得是同一个对象(锁).同步监视器的执行过程\n\n1.第一个线程访问，锁定同步监视器，执行其中代码.2.第二个线程访问，发现同步监视器被锁定，无法访问.3.第一个线程访问完毕，解锁同步监视器.4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问.\n\n\n\n注:一个线程持有锁会导致其他所有需要此锁的线程挂起；在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题.\n继承Thread:    中的线程同步方法一: synchronized (object){}结果:线程同步成功\nTicketThread\n//最核心的 操作代码块   //object 唯一的一把钥匙   // 哪一个线程得到了钥匙  就可以进入同步代码块   // 一次只能进一个   synchronized (object) &#123;//synchronized表示锁 object表示钥匙   &#125;\n\n\n\npublic class TicketThread extends Thread &#123;    static int num = 10;    static Object object = new Object();    @Override    public void run() &#123;        // /一直出票,num=0出票结束        while (true) &#123;            //最核心的 操作代码块            //object 唯一的一把钥匙            // 哪一个线程得到了钥匙  就可以进入同步代码块            // 一次只能进一个            synchronized (object) &#123;//synchronized表示锁 object表示钥匙                if (num &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;出票:&quot; + num);//t1=10 失去执行权1                    num--;                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;\n\n测试\npublic class Test &#123;    public static void main(String[] args) &#123;        //出票的任务,只有一个对象        TicketThread t1 = new TicketThread();        t1.setName(&quot;a&quot;);        t1.start();        TicketThread t2 = new TicketThread();        t2.setName(&quot;b&quot;);        t2.start();    &#125;&#125;\n\n结果:线程同步成功\n\n\n方法二:synchronized 给方法结果:线程同步失败\n\nsynchronized 给方法枷锁  钥匙是this  有多个线程对象 就有多把钥匙\n\npublic synchronized void printTick() {}\n\n测试部分创建多个对象,进行多线程\n\nTicketThread t1 = new TicketThread();\n     t1.setName(&quot;a&quot;);\n     t1.start();\n\n     TicketThread t2 = new TicketThread();\n     t2.setName(&quot;b&quot;);\n     t2.start();\n**TicketThread**&#96;&#96;&#96;javapublic class TicketThread extends Thread &#123;    static int num &#x3D; 10;    @Override    public void run() &#123;        &#x2F;&#x2F;        while (true) &#123;            if (num &#x3D;&#x3D; 0) &#123;                break;            &#125;            printTick();        &#125;    &#125;    &#x2F;*    不可以  加锁失效     *&#x2F;    &#x2F;&#x2F;synchronized 给方法枷锁  钥匙是this  有多个线程对象 就有多把钥匙    public synchronized void printTick() &#123;        &#x2F;&#x2F; 一直出票,num&#x3D;0出票结束        if (num &gt; 0) &#123;            try &#123;                Thread.sleep(500);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;出票:&quot; + num);&#x2F;&#x2F;t1&#x3D;10 失去执行权1            num--;        &#125;    &#125;&#125;\n\n\n\n测试\npublic class Test &#123;    public static void main(String[] args) &#123;                TicketThread t1 = new TicketThread();        t1.setName(&quot;a&quot;);        t1.start();        TicketThread t2 = new TicketThread();        t2.setName(&quot;b&quot;);        t2.start();    &#125;&#125;\n\n结果:线程同步失败\n\n\n\n\n\n\n\n实现Runnable：线程同步方法方法一: synchronized (object){}TicketThread\n结果:线程同步成功\n\n//因为只创建了一个  因此this只有一个\n\npublic class TicketThread implements Runnable &#123;    int num = 10;    @Override    public void run() &#123;        // /一直出票,num=0出票结束        while (true) &#123;            //因为只创建了一个  因此this只有一个            synchronized (this) &#123;                if (num &gt; 0) &#123;                    try &#123;                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;出票:&quot; + num);//t1=10 失去执行权1                    num--;                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;\n\n测试\npublic class Test &#123;    public static void main(String[] args) &#123;        //出票的任务,只有一个对象        TicketThread ticketThread = new TicketThread();        Thread t1  = new Thread(ticketThread,&quot;窗口1&quot;);        t1.start();        Thread t2  = new Thread(ticketThread,&quot;窗口2&quot;);        t2.start();    &#125;&#125;\n\n结果:线程同步成功\n方法二:synchronized 给方法结果:线程同步成功\n\n//synchronized 给方法枷锁  钥匙是this  this只创建了一个TicketThread对象\n//所以就this只有一个\n\nTicketThread\npublic class TicketThread implements Runnable &#123;     int num = 10;    @Override    public void run() &#123;        //        while (true) &#123;            if (num == 0) &#123;                break;            &#125;            printTick();        &#125;    &#125;    //synchronized 给方法枷锁  钥匙是this  this只创建了一个TicketThread对象    //所以就this只有一个    public synchronized void printTick() &#123;        // 一直出票,num=0出票结束        if (num &gt; 0) &#123;            try &#123;                Thread.sleep(500);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;出票:&quot; + num);//t1=10 失去执行权1            num--;        &#125;    &#125; &#125;\n\n测试:\npublic class Test &#123;    public static void main(String[] args) &#123;        //出票的任务,只有一个对象        TicketThread ticketThread = new TicketThread();        Thread t1  = new Thread(ticketThread,&quot;窗口1&quot;);        t1.start();        Thread t2  = new Thread(ticketThread,&quot;窗口2&quot;);        t2.start();    &#125;&#125;\n\n结果:线程同步成功\n","categories":["-javase"],"tags":["基础","线程","进程"]},{"title":"javaSE22-线程","url":"http://example.com/2020/12/16/java线程01/","content":"java-线程程序,进程,线程程序:是为完成特定任务,用某种语言编写的一组指令的集合,,即指一段静态的代码\n进程:就是正在执行的程序,从windows角度讲,进程是含有内存的资源并安置线程的地方\n线性:可进一步细化为线程,是一个进程内部的最小执行单元(执行任务)\n\n\n线程和进程的关系一个进程可以包含多个线程,一个线程只能属于一个进程,线程不能脱离进程而独立运行\n每一个进程至少包含一个线程(称为主线程): 在主线程中开始执行程序,java程序的入口main() 方法就是在主线程中被执行\n在主线程中可以创建并启动其他的线程\n一个进程内的所有线程共享该进程的内存资源\n  \n\n\n\n多线程的概念多线程是指程序中包含多个执行单元,即在一个程序中可以同时运行多个不同的线程来执行不同的任务,也就是说允许单个程序创建多个并执行的线程来完成各自的任务\n\n\n多线程的使用:\n程序需要同时执行两个或多个任务\n程序需要实现一些需要等待的任务时,如用户输入,文件读写操作,网络操作,搜索等\n需要一些后台运行的程序时\n\n\n\n多线程的好处\n提高CPU的利用率\n提高程序的相应\n改善程序结构,将复杂任务分为多个线程,独立运行\n\n\n\n多线程的缺点\n线程也是程序,所以线程需要占用内存,线程越多占用内存也越多\n多线程需要协调的管理,所以需要CPU时间跟踪线程\n线程之间对共享资源的访问会相互影响,必须解决竞用共享资源的问题\n\n\n\n创建线程:\n继承Thread类的方式\n实现Runnable接口的方式\n\n继承Thread类的方式\n继承Thread类的方式,在java中要实现线程,,扩展Thread,必须重写run类\nThread类中的run方法本身并不执行任何操作，\n如果我们重写了run方法，当线程启动时，它将执行run方法\n\nthead类/*继承thead方式 */public class ThreadDemo extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 1000; i++) &#123;            System.out.println(&quot;threadDEmo+++++&quot; + i);        &#125;    &#125;&#125;\n\ntest类\nThreadDemo t=new ThreadDemo();\n错误调用方法 t.run(); 调用方法不是启动新线程,而就是一个普通方法调用\nt.start();\n\npublic class Test &#123;    public static void main(String[] args) &#123;        ThreadDemo t=new ThreadDemo();//        t.run(); 调用方法不是启动新线程,而就是一个普通方法调用        t.start();        for (int i = 0; i &lt;10000 ; i++) &#123;            System.out.println(&quot;mian++++++++++++++++++++&quot;+i);        &#125;    &#125;&#125;\n\n实现Runnable接口的方式\njava.lang.Runnable接口中仅仅只有一个抽象方法：\npublic void run()\n通过实现其中的run方法即可\nrunable接口的存在主要时为了解决java中不允许多继承的问题\n\nThreadDemo002 implements  Runnable\npublic class ThreadDemo002 implements  Runnable&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10000; i++) &#123;            System.out.println(&quot;runable------------&quot;+i);        &#125;    &#125;&#125;\n\nTest\npublic class Test &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10000; i++) &#123;            System.out.println(&quot;main!!!!!!!!&quot; + i);        &#125;        ThreadDemo001 demo001 = new ThreadDemo001();        //Runnable必须创建执行任务对象        Thread thread = new Thread(demo001);        thread.start();//调用线程对象对应的方法    &#125;&#125;\n\n\n\n继承Thread和实现Runnable的联系与区别区别:\n继承Thread: 线程代码存放在Thread子类中run方法中\n实现Runnable:线程代码存放在接口的子类的run方法\n实现Runningable的好处:\n避免了单继承的局限性\n多个线程可以共享同一个实现类的对象,非常适合多个相同线程来处理同一份资源\n\n\n\nThread类中方法Thread类构造方法\nThread()  创建一个新的线程\nThread(String name) 创建一个指定名称的线程\nThread(Runnable target) 利用Runnable对象创建一个线程，启动时将执行该对象的run方法\nThread(Runnable target, String name)    利用Runnable对象创建一个线程，并指定该线程的名称\n\n方法:\ncurrentThread() 返回对当前正在执行的线程对象的引用\ngetName() 返回此线程的名称\nsetName(String name) 将此线程的名称更改为等于参数 name\n\nThreadDemo\npublic class ThreadDemo implements Runnable &#123;    @Override    public void run() &#123;         for (int i = 0; i &lt; 10000; i++) &#123;         // currentThread() 返回对当前正在执行的线程对象的引用\t\t //getName() 返回此线程的名称             System.out.println(Thread.currentThread().getName()+&quot;\\t&quot;+i);        &#125;    &#125;&#125;\n\n\n\ntest\npublic class tests &#123;    /*    thread中的方法:    Thread(Runnable target)   分配一个新的 Thread对象。    Thread(Runnable target, String name)  分配一个新的 Thread对象。    方法:    currentThread()  返回对当前正在执行的线程对象的引用。    getName()    返回此线程的名称。    setName(String name)    将此线程的名称更改为等于参数 name 。     */    public static void main(String[] args) &#123;        //创建一个任务        ThreadDemo threadDemo = new ThreadDemo();        //创建两个线性        Thread thread = new Thread(threadDemo,&quot;线程一&quot;);        thread.start();        Thread thread1 = new Thread(threadDemo);        thread1.setName(&quot;线程名你猜&quot;);        thread1.start();    &#125;&#125;\n\n\n\n\n\n\n\n\n\nThread常用方法:start()  启动线程\nSetname 设置线程名\ngetname 返回线程名\nsetPriority(int newPriority)  设置线程的优先级\ngetPriority()  返回线程的优先级\njoin   等待线程终止//thread.join();//线程合并, 等待thread线程执行完了,才会执行thread1线程\nsleep(Long millis)让当前正在执行的线程休眠（暂停执行），休眠时间由millis（毫秒）指定\nsetPriority(int newPriority)  设置线程的优先级getPriority()  返回线程的优先级\n\n计算机只有一个CPU,各个线程轮流使用CPU的使用权,才能执行任务\n优先级较高的线程有更多获得CPU的机会，反之亦然；优先级用整数表示，取值范围是1~10，一般情况下，线程的默认优先级都是5，但是也可以通过setPriority和getPriority方法来设置或返回优先级；\n调度策略:时间片: 排队  队列\n优先级高的使用\njava的调度方法:\n同优先级线程组成先进先出队列（先到先服务），使用时间片策略\n对高优先级，使用优先调度的抢占式策略\n\nThread类有如下3个静态常量来表示优先级\nMAX_PRIORITY：取值为10，表示最高优先级。\nMIN_PRIORITY：取值为1，表示最底优先级。\nNORM_PRIORITY：取值为5，表示默认的优先级。\n\n\n\n线程的生命周期\n线程的状态:\n\n新建: 当一个Thread类或其子类的对象被声明并创建时,新生的线程对象处于新建状态\n\n就绪:处于新建状态的线程被start() 后, 将进入线程队列等待CPU的时间片,此时它已具备了运行的条件,只是没有分配到cpu的资源\n\n运行:当就绪的线程被调度并获得CPU的资源时,便进入运行状态, run() 方法定义了线程的操作和功能\n\n阻塞: 在某种特殊情况下,被认为的挂起或执行输入输出操作时,让CPU并临时中止自己的执行,进入阻塞状态\n\n\n\n\nJava中的线程分为两类:\n用户线程\n守护线程\n\n用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：\n只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。\n注意:设置线程为守护线程必须在启动线程之前，否则会跑出一个IllegalThreadStateException异常。\n Thread.yield();//线程让步,运行状态回到就绪\nThread.sleep(1000);\nThread.currentThread().stop();\n\n\n\n\n案例ThreadDemo\npublic class ThreadDemo implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;//            if (i % 3 == 0) &#123;//                Thread.yield();//线程让步,运行状态回到就绪////            &#125;          /*  try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;*///线程停止//            if (i==5)&#123;//                Thread.currentThread().stop();//            &#125;            System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + i);        &#125;    &#125;&#125;\n\n\n\ntests\npublic class tests &#123;    /*    thread中的方法:    Thread(Runnable target)   分配一个新的 Thread对象。    Thread(Runnable target, String name)  分配一个新的 Thread对象。    方法:    currentThread()  返回对当前正在执行的线程对象的引用。    getName()    返回此线程的名称。    setName(String name)    将此线程的名称更改为等于参数 name 。     */    public static void main(String[] args) &#123;        //创建一个任务        ThreadDemo threadDemo = new ThreadDemo();        //创建两个线性        Thread thread = new Thread(threadDemo, &quot;线程一&quot;);        System.out.println(thread.getState());//返回线程状态        thread.start();        System.out.println(thread.getState());//返回线程状态        try &#123;            thread.join();//线程合并, 等待thread线程执行完了,才会执行thread1线程        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;                        Thread thread1 = new Thread(threadDemo);        thread1.setName(&quot;线程二&quot;);        thread1.start();        thread1.setPriority(Thread.MAX_PRIORITY);        thread.setPriority(1);        System.out.println(thread.getState());//返回线程状态        System.out.println(&quot;线程1的优先级&quot; + thread.getPriority());        System.out.println(&quot;线程2的优先级&quot; + thread1.getPriority());//      System.out.println(thread.getState());//返回线程状态    &#125;&#125;\n\n\n\n输出结构:\n\n\n\n\n\n案例二:t1.setDaemon(true);//设置线程为守护线程,在线程启动前设置,当所有的用户线程结束后,守护线程与虚拟机都停止\n\n\nThreadDemo\npublic class ThreadDemo extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt;100 ; i++) &#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;用户线程&quot;+i);        &#125;    &#125;&#125;\n\nThreadDemo1\npublic class ThreadDemo1 extends  Thread&#123;    @Override    public  void  run()&#123;        while (true) &#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;我是守护线程,,__________&quot;);        &#125;    &#125;&#125;\n\ntest\npublic class test &#123;    public static void main(String[] args) &#123;//        ThreadDemo t = new ThreadDemo();//        t.start();        ThreadDemo1 t1 = new ThreadDemo1();        t1.setDaemon(true);//设置线程为守护线程,在线程启动前设置,当所有的用户线程结束后,守护线程与虚拟机都停止        t1.start();    &#125;&#125;\n\n","categories":["-javase"],"tags":["基础","线程","进程"]},{"title":"LC682-棒球比赛","url":"http://example.com/2020/12/15/LC682/","content":"682. 棒球比赛难度简单158\n你现在是一场采特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\n输入：ops = [“5”,”2”,”C”,”D”,”+”]输出：30解释：“5” - 记录加 5 ，记录现在是 [5]“2” - 记录加 2 ，记录现在是 [5, 2]“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5].“D” - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].“+” - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].所有得分的总和 5 + 10 + 15 = 30\n \n\nclass Solution &#123;    public int calPoints(String[] ops) &#123;     ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();        for (String op : ops) &#123;            if (op.equals(&quot;+&quot;)) &#123;                Integer a = stack.poll();                Integer b = stack.peek();                Integer c = a + b;                stack.push(a);                stack.push(c);            &#125; else if (op.equals(&quot;C&quot;)) &#123;                stack.poll();            &#125; else if  (op.equals(&quot;D&quot;)) &#123;                              stack.push(2 * stack.peek());            &#125; else &#123;                //类型转换                stack.push(Integer.valueOf(op));            &#125;        &#125;          int ans = 0;        for(int score : stack) ans += score;        return ans;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","栈"]},{"title":"LC049-字母异位词分组","url":"http://example.com/2020/12/13/LC049/","content":"49. 字母异位词分组给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n示例:\n输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]\n\n\n\n\n\n\n\n1.先排序再判断\n字母异位词就是两个字符串中的字母都是一样的，只不过顺序被打乱了\n找出来他们进行排序\n利用map进行,判断,储存HashMap&lt;String, List&gt; map = new HashMap&lt;&gt;();\n输出 map的value的值\n\n \n\n\n\n转换\n强化记忆\n强化记忆\n强化记忆\n强化记忆\n强化记忆\n&#x2F;&#x2F;取出字符串，然后把它转化为字符数组char[] c &#x3D; strs[i].toCharArray();&#x2F;&#x2F;对字符数组进行排序Arrays.sort(c);&#x2F;&#x2F;排序之后再把它转化为一个字符串String keyStr &#x3D; String.valueOf(c);\n\n强化记忆\n强化记忆\n强化记忆\n强化记忆\npublic List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;     //边界条件判断    if (strs == null || strs.length == 0) &#123;        return new ArrayList&lt;&gt;();    &#125;    //map中key存储的是字符串中字母排序后新的字符串    HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; strs.length; i++) &#123;         //取出字符串，然后把它转化为字符数组        char[] c = strs[i].toCharArray();        //对字符数组进行排序        Arrays.sort(c);        //排序之后再把它转化为一个字符串        String keyStr = String.valueOf(c);          //判断map中有没有这个字符串，如果没有这个字符串，    //说明还没有出现和这个字符串一样的字母异位词，    //要新建一个list，把它存放到map中        if (!map.containsKey(keyStr))            map.put(keyStr, new ArrayList&lt;&gt;());        //把字符串存放到对应的list中        map.get(keyStr).add(strs[i]);    &#125;     //最后返回    return new ArrayList&lt;&gt;(map.values());&#125;\n\n其他相关解法\n","categories":["-算法"],"tags":["LeetCode","字符串"]},{"title":"hashTable(哈希表){JAVA实现}","url":"http://example.com/2020/12/13/HashTableJAVA实现/","content":"hashTable(哈希表)哈希表的介绍哈希表(Hashtable 也叫散列表) 是根据关键码值(key value) 而直接进行访问的数据结构,也就是说他是用过关键码值映射到表中一个位置来访问记录,以加快访问进度,这个映射函数叫做散列函数， 存放记录的数组叫做散列表  \n详细hash请看  \n\n\n应用:google 公司的一个上机题  \n有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时,要求查找到该员工的 所有信息.  \n要求 \n\n不使用数据库,,速度越快越好=&gt;哈希表(散列)\n添加时， 保证按照 id 从低到高插入 [课后思考： 如果 id 不是从低到高插入， 但要求各条链表仍是从低到高， 怎么解决?]\n使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]\n思路分析并画出示意图  \n\nhashtable分析\n总结\n\n由哈希表的结构我们知道\n哈希表 由数组队应得 链表    链表对应得键值 构成\n\n键值(雇员)class Emp &#123;\tpublic int id;\tpublic String name;\tpublic Emp next; //next 默认为 null\tpublic Emp(int id, String name) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.name = name;\t&#125;&#125;\n\n\n\n\n\n\n\n链表(存放雇员)创建EmpLinkedList ,表示链表,组成得链表\nclass EmpLinkedList &#123;//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp\tprivate Emp head; //默认null\t\t//添加雇员到链表\t//说明\t//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大\t//   因此我们将该雇员直接加入到本链表的最后即可\tpublic void add(Emp emp) &#123;\t\t//如果是添加第一个雇员\t\tif(head == null) &#123;\t\t\thead = emp;\t\t\treturn;\t\t&#125;\t\t//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后\t\tEmp curEmp = head;\t\twhile(true) &#123;\t\t\tif(curEmp.next == null) &#123;//说明到链表最后\t\t\t\tbreak;\t\t\t&#125;\t\t\tcurEmp = curEmp.next; //后移\t\t&#125;\t\t//退出时直接将emp 加入链表\t\tcurEmp.next = emp;\t&#125;\t...\t...\t...&#125;\n\n\n\n创建HashTab 管理多条链表将链表,映射到数组对应得位置 \nclass HashTab &#123;\tprivate EmpLinkedList[] empLinkedListArray;\tprivate int size; //表示有多少条链表\t\t//构造器\tpublic HashTab(int size) &#123;\t\tthis.size = size;\t\t//初始化empLinkedListArray\t\tempLinkedListArray = new EmpLinkedList[size];\t\t//？留一个坑, 这时不要分别初始化每个链表\t\tfor(int i = 0; i &lt; size; i++) &#123;            //每个数组对应着链表\t\t\tempLinkedListArray[i] = new EmpLinkedList();\t\t&#125;\t&#125;..........&#125;\n\n\n\n\n\n具体操作add:  添加雇员在hashtable中//添加雇员public void add(Emp emp) &#123;\t//根据员工的id ,得到该员工应当添加到哪条链表\tint empLinkedListNO = hashFun(emp.id);\t//将emp 添加到对应的链表中\tempLinkedListArray[empLinkedListNO].add(emp);\t&#125;\n\n//添加雇员到链表//说明//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大//   因此我们将该雇员直接加入到本链表的最后即可public void add(Emp emp) &#123;\t//如果是添加第一个雇员\tif(head == null) &#123;\t\thead = emp;\t\treturn;\t&#125;\t//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后\tEmp curEmp = head;\twhile(true) &#123;\t\tif(curEmp.next == null) &#123;//说明到链表最后\t\t\tbreak;\t\t&#125;\t\tcurEmp = curEmp.next; //后移\t&#125;\t//退出时直接将emp 加入链表\tcurEmp.next = emp;&#125;\n\nlist: 显示雇员遍历所有的链表,遍历hashtab//遍历所有的链表,遍历hashtabpublic void list() &#123;\tfor(int i = 0; i &lt; size; i++) &#123;\t\tempLinkedListArray[i].list(i);\t&#125;&#125;\n\n//遍历链表的雇员信息public void list(int no) &#123;\tif(head == null) &#123; //说明链表为空\t\tSystem.out.println(&quot;第 &quot;+(no+1)+&quot; 链表为空&quot;);\t\treturn;\t&#125;\tSystem.out.print(&quot;第 &quot;+(no+1)+&quot; 链表的信息为&quot;);\tEmp curEmp = head; //辅助指针\twhile(true) &#123;\t\tSystem.out.printf(&quot; =&gt; id=%d name=%s\\t&quot;, curEmp.id, curEmp.name);\t\tif(curEmp.next == null) &#123;//说明curEmp已经是最后结点\t\t\tbreak;\t\t&#125;\t\tcurEmp = curEmp.next; //后移，遍历\t&#125;\tSystem.out.println();&#125;\n\nfind: 查找雇员在Hashtable中public void findEmpById(int id) &#123;\t//使用散列函数确定到哪条链表查找\tint empLinkedListNO = hashFun(id);\tEmp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);\tif(emp != null) &#123;//找到\t\tSystem.out.printf(&quot;在第%d条链表中找到 雇员 id = %d\\n&quot;, (empLinkedListNO + 1), id);\t&#125;else&#123;\t\tSystem.out.println(&quot;在哈希表中，没有找到该雇员~&quot;);\t&#125;&#125;//编写散列函数, 使用一个简单取模法public int hashFun(int id) &#123;\treturn id % size;&#125;\n\n链表中//根据id查找雇员//如果查找到，就返回Emp, 如果没有找到，就返回nullpublic Emp findEmpById(int id) &#123;\t//判断链表是否为空\tif(head == null) &#123;\t\tSystem.out.println(&quot;链表为空&quot;);\t\treturn null;\t&#125;\t//辅助指针\tEmp curEmp = head;\twhile(true) &#123;\t\tif(curEmp.id == id) &#123;//找到\t\t\tbreak;//这时curEmp就指向要查找的雇员\t\t&#125;\t\t//退出\t\tif(curEmp.next == null) &#123;//说明遍历当前链表没有找到该雇员\t\t\tcurEmp = null;\t\t\tbreak;\t\t&#125;\t\tcurEmp = curEmp.next;//以后\t&#125;\t\treturn curEmp;&#125;\n\n\n\n\n\n完整代码package com.nie.Bzhan;import java.util.Scanner;public class HashTableDemo &#123;    public static void main(String[] args) &#123;        HashTab tab = new HashTab(7);        //写一个简单的菜单        String key = &quot;&quot;;        Scanner scanner = new Scanner(System.in);        while (true) &#123;            System.out.println(&quot;a:  添加雇员&quot;);            System.out.println(&quot;l: 显示雇员&quot;);            System.out.println(&quot;f: 查找雇员&quot;);            System.out.println(&quot;e: 退出系统&quot;);            key = scanner.next();            switch (key) &#123;                case &quot;a&quot;:                    System.out.println(&quot;输入id&quot;);                    int id = scanner.nextInt();                    System.out.println(&quot;输入名字&quot;);                    String name = scanner.next();                    //创建雇员                    Emp emp = new Emp(id, name);                    tab.add(emp);                    break;                case &quot;l&quot;:                    tab.List();                    break;                case &quot;f&quot;:                    System.out.println(&quot;请输入要查找的id&quot;);                    id = scanner.nextInt();                    tab.findEmpById(id);                    break;                case &quot;e&quot;:                    scanner.close();                    System.exit(0);                default:                    break;            &#125;        &#125;    &#125;&#125;//表示一个雇员 即 哈希表中链表中的结点class Emp &#123;    public int id;    public String name;    public Emp next;    public Emp(int id, String name) &#123;        this.id = id;        this.name = name;    &#125;&#125;//创建链表class EmpLinkedList &#123;    //头指针,执行第一个emp 因此我们这个链的head直接访问emp    private Emp head;//默认为null    //添加雇员    //说明    //1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大    //   因此我们将该雇员直接加入到本链表的最后即可    public void add(Emp emp) &#123;        if (head == null) &#123;            head = emp;            return;        &#125;        Emp curEmp = head;        while (true) &#123;            if (curEmp.next == null) &#123;                break;            &#125;            curEmp = curEmp.next;        &#125;        curEmp.next = emp;    &#125;    //遍历链表的雇员信息    public void list(int no) &#123;        if (head == null) &#123;            System.out.println(&quot;第&quot; + (no + 1) + &quot;链表为空&quot;);            return;        &#125;        System.out.print(&quot;第 &quot; + (no + 1) + &quot; 链表的信息为&quot;);        Emp curEmp = head;//辅助指针        while (true) &#123;            System.out.printf(&quot; =&gt; id=%d name=%s\\t&quot;, curEmp.id, curEmp.name);            if (curEmp.next == null) &#123;//说明curEmp已经是最后结点                break;            &#125;            curEmp = curEmp.next;//后移        &#125;        System.out.println();    &#125;    //根据id查找雇员    //如果查找到，就返回Emp, 如果没有找到，就返回null    public Emp findEmpById(int id) &#123;        if (head == null) &#123;            System.out.println(&quot;此链表为空&quot;);        &#125;        Emp curEmp = head;        while (true) &#123;            //找到返回            if (curEmp.id == id) &#123;                break;            &#125;            //没有找到返回null            //退出            if (curEmp.next == null) &#123;                curEmp = null;                break;            &#125;            curEmp = curEmp.next;//向后遍历        &#125;        return curEmp;    &#125;&#125;//创建hashtab 管理多条链表class HashTab &#123;    private EmpLinkedList[] empLinkedListArray;    private int size;//表示有多少链表    //构造器    HashTab(int size) &#123;        this.size = size;        empLinkedListArray = new EmpLinkedList[size];        for (int i = 0; i &lt; size; i++) &#123;            empLinkedListArray[i] = new EmpLinkedList();        &#125;    &#125;    //添加雇员    public void add(Emp emp) &#123;        //根据员工id.得到该员工应该在那条链表中        int empLinkedListNO = hashFun(emp.id);        //将emp添加到链表中        empLinkedListArray[empLinkedListNO].add(emp);    &#125;    //根据输入id 查找雇员    public void findEmpById(int id) &#123;        //使用散列表函数 确定到哪条链表查找        int empLinkedListNO = hashFun(id);        Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);        if (emp != null) &#123;            System.out.printf(&quot;在第%d条链表中找到 雇员 id = %d\\n&quot;, (empLinkedListNO + 1), id);        &#125; else &#123;            System.out.println(&quot;在哈希表中，没有找到该雇员~&quot;);        &#125;    &#125;    //遍历所有的链表 遍历hashtab    public void List() &#123;        for (int i = 0; i &lt; size; i++) &#123;            empLinkedListArray[i].list(i);        &#125;    &#125;    private int hashFun(int id) &#123;        return id % size;    &#125;&#125;\n\n\n\n\n\n\n\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","hash","hashTable"]},{"title":"快排总汇Java","url":"http://example.com/2020/12/12/快排总汇Java/","content":"快速排序前言优秀快排写法\n此文章python写法快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。步骤如下\n\n从数列中挑出一个元素,称为基准(pivot)\n\n分区(partition):遍历数列,比基数小的元素放在左边,比他大的放在右边\n于是此次分区结束后，该基准就处于数列的中间位置，其左边的数全比它小（称为小与子序列），右边的数全比他大（称为大于子序列）。这样一次排序就造成了整体上的有序化。\n\n子数列排序:将小于子数列和大于子序列分别继续快速排序\n\n递归到最底部,数列是零或一,至此,递归结束\n\n\n\n\n\n针对具体的基数的选择方式和区别方式的不同,主要有四种方式:\n\n普通快排\n随机快排\n双路快排\n三路快排\n\n思考:1.渐进有序的数组和一般乱序的数组,对快排有什么效率的区别\n对于快排,就类似于通过分治从顶到底的渐进有序,选择的基数使得分正左右两个子序列长度接近(分区平衡),快排的效率越高.反之使得分区不平衡,快排的效率会降低.\n\n当然当序列有序时,意味着大量元素已经处于有序状态,左边数普遍小于右边,对于普通快排,默认选择左边第一个数作为基准数,这就导致小于基准的数相对于少,而大于基准的数多,,造成分区不平衡,严重的话,严重的将退化成O(n^2),,  对其改进就是不在使用默认的第一个数,而是选择谁记得一个数位基准,这样的快排称为随机普通快排\n\n\n\n实现上，随机普通快排随机选一个数与第一个数交换，然后在将第一个数作为基准（这样代码好写），进行普通快排即可。所以随机普通快排只是对普通快排进行了一下预处理而已。\n\n2.分区时等于的数怎么办？对于普通快排,我们将等于的数一并放到左边后者右边,在一般情况下,排序效率都很快,能达到O(nlogn),\n但是当序列含有大量相等数字时，普通快排会使得大量等于的数集中位于某一边，造成分区不平衡的问题，使得普通快排退化成O(n^2)，\n这时对于等于的数的处理就显得很重要了，针对普通快速排序的改进版本——双路排序和三路排序，就应运而生了。\n\n双路快排:从两端向中间扫描,等于的数可以被分再任意一边,这样就缓解了分区不平衡问题\n\n三路快排：也是从两端向中间扫描，不同的是，它将等于的数通通放到中间，即新增了一个等于区。接下去分别对小与区和大于区继续快排，这样不仅避免了分区不平衡，还有个额外的好处：等于区的数从此不必再处理。\n\n\n3. 所以双/三路快排一定比普通快排和随机普通快排快吗？不一定:双路三路快排,只有再序列含有大量相等元素事性能才能比普通的好,负责性能会比普通快排稍差,因为,双/三路快排比普通快排稍复杂,会维护多些指针,就会对对出一些额外的赋值和比较开销\n总结:普通快速排序：从左到右或从右到左的单向扫描。设立两个区：小于区，大于等于区\n\n问题\n对于渐进有序的数组，效率很差,\n改进选择随机基准,得到随机快速排序\n\n\n对于含有大量重复元素的序列，即使是随机化快排效率也很差于是再次改进，\n1.双路快排： 从两端向中间挺近，设立两个区：小于等于区，大于等于区2.三路快排： 从两端向中间挺近，设立三个区：小与区，等于区，大于区\n普通快速排序由左到右扫描,设立两个区,小于区,大于等于区\n\npublic class QuickSortOne &#123;    public static void main(String[] args) &#123;        int[] arr=new int[]&#123;4,1,7,6,9,2,8,0,3,5,44,32,53,76,86,9,12,32,14,13,12&#125;;        int l=0;        int r=arr.length-1;        quickSort(arr,l,r);        System.out.println(Arrays.toString(arr));    &#125;    public static void quickSort(int[] arr, int l, int r) &#123;        if (l &gt;= r) &#123;            return;        &#125;        int p = partition(arr, l, r);//分割，返回分割点p        quickSort(arr,l,p-1);//递归地对左部分快排        quickSort(arr,p+1,r);//递归地对右部分快排    &#125;/*_partition()对arr[l...r]部分进行partition操作返回p,使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt;= arr[p]*/    public static int partition(int[] arr, int l, int r) &#123;        int v = arr[l];        int j = l;        for (int i = l + 1; i &lt; r + 1; i++) &#123;            if (arr[i] &lt; v) &#123;                j += 1;                swap(arr, i, j);            &#125;else &#123;                continue;            &#125;        &#125;        swap(arr, j, l);        return j;    &#125;/*交换 */    public static void swap(int[] arry, int i, int j) &#123;        int temp = arry[i];        arry[i] = arry[j];        arry[j] = temp;    &#125;&#125;\n\n普通快排的问题问题1：对于渐进有序的数组，效率不高\n原因：快排中分治的不平衡性我们知道，归并排序复杂度O(nlogn)中logn的原因是每次归并都是高度平衡的，即左右两支长度相等。平衡度越好，性能越接近logn。快排每次都从左边第一个数作为比较数，而对于渐进有序的数组来说，每次区分其实都是极其不平衡的（如下图），甚至会退化成O(n^2).\n改进方式：随机化基准数，得到随机普通快排随机普通快排平均意义上，对于任何数组（包括渐进有序数组），快排遇到最差情况的概率将大大降低。代码如下\n\n\n\n\npublic class QuickSortTwo &#123;    public static void main(String[] args) &#123;        int[] arr=new int[]&#123;4,1,7,6,9,2,8,0,3,5,44,32,53,76,86,9,12,32,14,13,12&#125;;        int l = 0;        int r = arr.length - 1;        quickSort(arr, l, r);        System.out.println(Arrays.toString(arr));    &#125;    public static void quickSort(int[] arr, int l, int r) &#123;        if (l &gt;= r) &#123;            return;        &#125;        int p = partition(arr, l, r);//分割，返回分割点p        quickSort(arr, l, p-1);//递归地对左部分快排        quickSort(arr, p + 1, r);//递归地对右部分快排    &#125;/*_partition()对arr[l...r]部分进行partition操作返回p,使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt;= arr[p]*//*  单路改进版： 随机选取分割值，避免分出来的两块大小不均匀问题带来的性能下降 */    public static int partition(int[] arr, int l, int r) &#123;         // 改进点：随机选取一个元素开始分割，而不是第一个元素        int piovt = (int) (l + Math.random() * (r - l));        swap(arr,l,piovt);        int v = arr[l];//# 将第一个元素（已随机化了）作为分割值        int j = l;        for (int i = l + 1; i &lt; r + 1; i++) &#123;            if (arr[i] &lt; v) &#123;                j += 1;                swap(arr, i, j);            &#125; else &#123;                continue;            &#125;        &#125;        swap(arr, j, l);        return j;    &#125;    /*    交换     */    public static void swap(int[] arry, int i, int j) &#123;        int temp = arry[i];        arry[i] = arry[j];        arry[j] = temp;    &#125;&#125;\n\n问题2：对于含有大量重复元素的数组，即使是改进版的单路快排效率也很差\n原因对于含有大量重复元素的数组，则对于与基准数相同的数，（根据所写代码不同）要么都分到了左边，要么都分到了右边。同样会造成分治不平衡的问题，造成性能退化。如下图所示：\n改进算法1.双路快排： 从两端向中间挺近，设立两个区：小于等于区，大于等于区2.三路快排： 从两端向中间挺近，设立三个区：小与区，等于区，大于区\n双路快排从两端向中间挺近，设立两个区：小于等于区，大于等于区\n如何克服含大量重复元素的数组导致不平衡问题：等于基准的数在两边均有分布，避免集中在一边，从而克服了不平衡问题\n/*从两端向中间挺近，设立两个区：小于等于区，大于等于区如何克服含大量重复元素的数组导致不平衡问题：等于基准的数在两边均有分布，避免集中在一边，从而克服了不平衡问题。 */public class QuickSortThree002 &#123;    public static void main(String[] args) &#123;        int[] arr=new int[]&#123;4,1,7,6,9,2,8,0,4&#125;;        int l = 0;        int r = arr.length - 1;        quickSort(arr, l, r);        System.out.println(Arrays.toString(arr));    &#125;    public static void quickSort(int[] arr, int l, int r) &#123;        if (l &gt;= r) &#123;            return;        &#125;        int p = partition(arr, l, r);//分割，返回分割点p        quickSort(arr, l, p-1);//递归地对左部分快排        quickSort(arr, p + 1, r);//递归地对右部分快排    &#125;    public static int partition(int[] arr, int l, int r) &#123;        int piovt = (int) (l + Math.random() * (r - l));        swap(arr, piovt, l);        int v = arr[l];        int i = l +1;//i: &lt;=区的右标记点        int j = r;// # j: &gt;=区的左标记点        while (true) &#123;            // # i,j相遇时停止            while (i &lt;= j &amp;&amp; arr[i] &lt;= v) &#123;                i++;// # i一直右移到大于v的值处            &#125;            while (i &lt;= j &amp;&amp; arr[j] &gt;= v) &#123;                j--;// # j一直左移到小于v的值处            &#125;            if (i &gt; j) break;            swap(arr, j, i);            i++;            j--;        &#125;        swap(arr, j, l);        return j;    &#125;    /*    交换     */    public static void swap(int[] arry, int i, int j) &#123;        int temp = arry[i];        arry[i] = arry[j];        arry[j] = temp;    &#125;&#125;\n\n\n\n三路快排从两端向中间挺近，设立三个区：小与区，等于区，大于区\n如何克服含大量重复元素的数组导致不平衡问题：等于基准的数在正好集中在了中间，而不是任意一边，从而克服了不平衡问题。\n三路快排的额外的好处：在继续递归时，中间的arr[lt+1,gt-1]是等号区，不用管了，这样在含有大量相同元素的时候就可以避免大量的运算这也是3路快排在含有大量相同元素的状况下，保持优势的地方.\n/*从两端向中间挺近，设立三个区：小与区，等于区，大于区如何克服含大量重复元素的数组导致不平衡问题：等于基准的数在正好集中在了中间，而不是任意一边，从而克服了不平衡问题。三路快排的额外的好处：在继续递归时，中间的arr[lt+1,gt-1]是等号区，不用管了，这样在含有大量相同元素的时候就可以避免大量的运算这也是3路快排在含有大量相同元素的状况下，保持优势的地方.。 */public class QuickSortThreeLu &#123;    public static void main(String[] args) &#123;        int[] arr = new int[]&#123;4, 1, 7, 6, 7, 7, 9, 2, 8, 0&#125;;        int l = 0;        int r = arr.length - 1;        quickSort(arr, l, r);        System.out.println(Arrays.toString(arr));    &#125;    public static void quickSort(int[] arr, int l, int r) &#123;        if (l &gt;= r) &#123;            return;        &#125;        int piovt = (int) (l + Math.random() * (r - l));        swap(arr, piovt, l);        int v = arr[l];        int lt = l;  //  # arr[l+1...lt] &lt; v        int gt = r + 1;// # arr[gt...r] &gt; v        int i = l + 1;  //# arr[lt+1...i) == v        while (i &lt; gt) &#123;            if (arr[i] &lt; v) &#123;                swap(arr, i, lt + 1);                lt++;//    [l+1,Lt    Lt+1 i      gt,r]                i++;//交换后，i右移，因为i指向了一个已处理的数（从等号区换来的）            &#125; else if (arr[i] &gt; v) &#123;                swap(arr, i, gt - 1);                gt--;//交换后，i不需要动，因为i仍指向一个未处理的数（从乱序区换来的）            &#125; else &#123;                i++;            &#125;        &#125;        swap(arr, lt, l);        lt--;        quickSort(arr, l, lt);//继续对arr[l..lt]部分快排        quickSort(arr, gt, r);//继续对arr[gt,r]部分快排        /*           # 而中间的arr[lt+1,gt-1]是等号区，不用管了。    # 这样在含有大量相同元素的时候就可以避免大量的运算    # 这也是3路快排在含有大量相同元素的状况下，保持优势的地方         */    &#125;    /*    交换     */    public static void swap(int[] arry, int i, int j) &#123;        int temp = arry[i];        arry[i] = arry[j];        arry[j] = temp;    &#125;&#125;","categories":["-算法"],"tags":["排序","十大排序","快速排序"]},{"title":"LC239-滑动窗口最大值","url":"http://example.com/2020/12/12/LC239/","content":"239. 滑动窗口最大值给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回滑动窗口中的最大值。\n进阶：\n你能在线性时间复杂度内解决此题吗？\n示例:\n \n\n输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3输出: [3,3,5,5,6,7] 解释:   滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7\n\n使用是双端队列\n\n遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。\n队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。\n如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。\n刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。\n当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。\n\n设置双端队列存储最大值（便于O(1)时间获取），队列降序排列，一轮遍历，先把窗口塞满，然后这时就可以返回最大值（队头）了，但返回前要做2件事，首先，要加入数组当前下标到队尾，并保证是单调的，其次，如果队头这是已经到了窗口左边，就移除队头。\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7]解释过程中队列中都是具体的值，方便理解，具体见代码。初始状态：L=R=0,队列:&#123;&#125;i=0,nums[0]=1。队列为空,直接加入。队列：&#123;1&#125;i=1,nums[1]=3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：&#123;3&#125;i=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：&#123;3,-1&#125;。此时窗口已经形成，L=0,R=2，result=[3]i=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：&#123;3,-1,-3&#125;。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]i=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：&#123;5&#125;。此时L=2,R=4，有效。result=[3,3,5]i=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：&#123;5,3&#125;。此时L=3,R=5，有效。result=[3,3,5,5]i=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：&#123;6&#125;。此时L=4,R=6，有效。result=[3,3,5,5,6]i=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：&#123;7&#125;。此时L=5,R=7，有效。result=[3,3,5,5,6,7]\n\n\n通过示例发现 R=i，L=k-R。由于队列中的值是从大到小排序的，所以每次窗口变动时，只需要判断队首的值是否还在窗口中就行了。\n解释一下为什么队列中要存放数组下标的值而不是直接存储数值，因为要判断队首的值是否在窗口范围内，由数组下标取值很方便，而由值取数组下标不是很方便\n\n代码class Solution &#123;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        if(nums == null || nums.length &lt; 2) return nums;        // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序        LinkedList&lt;Integer&gt; queue = new LinkedList();        // 结果数组        int[] result = new int[nums.length-k+1];        // 遍历nums数组        for(int i = 0;i &lt; nums.length;i++)&#123;            // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求            while(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i])&#123;                queue.pollLast();            &#125;            // 添加当前值对应的数组下标            queue.addLast(i);            // 判断当前队列中队首的值是否有效            if(queue.peek() &lt;= i-k)&#123;                queue.poll();               &#125;             // 当窗口长度为k时 保存当前窗口中最大值            if(i+1 &gt;= k)&#123;                result[i+1-k] = nums[queue.peek()];            &#125;        &#125;        return result;    &#125;&#125;\n\n\n\n\n\n注释:\n&#x2F;&#x2F; 判断当前队列中队首的值是否有效          if(queue.peek() &lt;&#x3D; i-k)&#123;              queue.poll();             &#125; \n\n\n​        queue里面放的是nums中数对应的下标 ，所谓的queue.peek() &lt;= i-k 是说如果当前最大值的下标已经在窗口外的时候，就要将其弹出删除，举个例子，假设说nums是 [1,3,-1,-3,-4], 在读取完-3的时候，队列从头到尾的数据为 [1, 2, 3]（注意队列里是nums的下标）, 那么在读取到-4的时候，会直接把-4压到队尾，这个时候窗口应该是 [2, 4], 而 此时队头的下标1已经在窗口外了，​        1=&lt;4-3​        所以，需要将其弹出，那么最终窗口最大值的下标应该为2              \n","categories":["-算法"],"tags":["LeetCode","map"]},{"title":"LC242-有效的字母异位词","url":"http://example.com/2020/12/11/LC242/","content":"242. 有效的字母异位词难度简单314\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1:\n输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true\n\n示例 2:\n输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false\n\n\n\n\n\n解法一:\n将其转成数组之后,排序,作比较\n \n\nclass Solution &#123;    public boolean isAnagram(String s, String t) &#123;        if (s.length() != t.length()) &#123;            return false;        &#125;        char[] str1 = s.toCharArray();        char[] str2 = t.toCharArray();        Arrays.sort(str1);        Arrays.sort(str2);        return Arrays.equals(str1, str2);    &#125;&#125;\n\n\n\n解法二\n解题思路\n\n哈希表的映射\n首先判断两个字符串长度是否相同,不同的直接返回false\n若相等,则初始化26个字母哈希表,遍历字符串s和t\ns负责在对应位置加,,t则的位置减少\n如果哈希表的值都为 0，则二者是字母异位词\n\nclass Solution &#123;    public boolean isAnagram(String s, String t) &#123;        if(s.length() != t.length())            return false;        int[] alpha = new int[26];        for(int i = 0; i&lt; s.length(); i++) &#123;            alpha[s.charAt(i) - &#x27;a&#x27;] ++;            alpha[t.charAt(i) - &#x27;a&#x27;] --;        &#125;        for(int i=0;i&lt;26;i++)            if(alpha[i] != 0)                return false;        return true;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","map","字符串"]},{"title":"java查找方法","url":"http://example.com/2020/12/10/java查找方法/","content":"查找方法:在Java常用的四种查找方法\n\n顺序查找\n二分查找\n插值查找\n斐波那契查找  \n\n顺序查找无序,有序均可利用循环依次进行遍历进行查找\n二分查找\n\n对一个有序数组进行二分查找{1,8, 10, 89, 1000, 1234} ， 输入一个数看看该数组是否存在此数， 并且求出下标， 如果没有就提示”没有这个数”。  \n\n\n非递归二分法 主要临界点:while (left&lt;=right)\n/**   *  非递归 二分法   * @param arr  数组   * @param finVal  要查找的值   * @return   */  public  static  int binaryTwo(int[] arr ,int finVal)&#123;      int left=0;      int right=arr.length-1;      int mid;      while (left&lt;=right)&#123;          mid=(left+right)/2;          if (arr[mid]==finVal)&#123;              return  mid;          &#125;else if (arr[mid]&gt;finVal)&#123;              right=mid-1;          &#125;else &#123;              left=mid+1;          &#125;      &#125;      return -1;  &#125;\n\n\n\n递归/** * 递归 * @param arr    数组 * @param left   左边的索引 * @param rigth  右边的索引 * @param finVal 要查找的值 * @return 如果找到就返回下标, 如果没有 返回-1; */public static int binary(int[] arr, int left, int rigth, int finVal) &#123;    //当left&gt;right时, 说明整个递归没有找到    if (left &gt; rigth) &#123;        return -1;    &#125;    int mid = (left + rigth) / 2;    int midVal = arr[mid];    if (finVal &gt; midVal) &#123;        return binary(arr, mid + 1, rigth, finVal);    &#125; else if (finVal &lt; midVal) &#123;        return binary(arr, left, mid + 1, finVal);    &#125; else &#123;        return mid;    &#125;&#125;\n\n插值查找算法插值查找原理介绍\n插值查找法类似于二分查找法,不同的是插值查找每次从自适应mid处开始查找\n将折半查找中的求  mid索引的公式,low表示左边索引left,high表示右边索引right\nkey就是需要查找到元素\n\n*int  mid=left+(right-left)(find-arr[left])/(arr[right]-arr[left]);**\n插值查找算法举例说明\n\npublic class insertValueSearch &#123;    public static void main(String[] args) &#123;        int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;        int index=insertValue(arr,0,arr.length-1,8);        System.out.println(index);    &#125;    public static int insertValue(int[] arr, int left, int right, int findVal) &#123;        if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123;            return -1;        &#125;        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);        int midVAl = arr[mid];        if (findVal &gt; midVAl) &#123;            return insertValue(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVAl) &#123;            return insertValue(arr, left, mid - 1, findVal);        &#125;else &#123;            return mid;        &#125;    &#125;&#125;\n\n斐波那契(黄金分割法)查找算法基本介绍\n黄金分割点是指把一条线段分割为两部分， 使其中一部分与全长之比等于另一部分与这部分之比。 取其前三位数字的近似值是 0.618。   \n斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例， 无限接近 黄金分割值0.618  \n\n原理斐波拉契查找原理与前两种相似,仅仅改变了中间结点(mid) 的位置,mid不再是中间或者插值得到,而是位于黄金分割点附近,即mid=low+F(k-1)-1…..（F 代表斐波那契数列） ， 如下图所示  \n\nmid=low+F(k-1)-1对F(k-1)-1 的理解：  \n\n由斐波拉契数列F[k]=F[k-1]+F[k-2] 的性质， \n可以得到 （F[k]-1） =（F[k-1]-1） +（F[k-2]-1） +1 。\n则可以将该表达式长度分为F[k-1]-1 和 F[k-2]-1 的两段，  \n即中间的值为mid=low+F(k-1)-1  \n\n但顺序表长度n不一定刚好等于F[k]-1,所以需要将原来的顺序长度n增加至F[k]-1,这里的k值只要能使得F[k]-1 恰好大于或等于 n 即可  ,有以下代码可以得到（从 n+1 到 F[k]-1 位置）   \nf[0] = 1;   f[1] = 1;   for (int i = 2; i &lt; maxSize; i++) &#123;       f[i] = f[i - 1] + f[i - 2];   &#125;\n\n\n\nif (key &lt; temp[mid])f[k] = f[k-1] + f[k-2]因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]即 在 f[k-1] 的前面继续查找 k--即下次循环 mid = f[k-1-1]-1k--;\n\n\n\nif (key &lt; temp[mid]) &#123;        high = mid - 1;        //为甚是 k--        //说明        //1. 全部元素 = 前面的元素 + 后边元素        //2. f[k] = f[k-1] + f[k-2]        //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]        //即 在 f[k-1] 的前面继续查找 k--        //即下次循环 mid = f[k-1-1]-1        k--;&#125;\n\nif (key &gt; temp[mid])全部元素 &#x3D; 前面的元素 + 后边元素f[k] &#x3D; f[k-1] + f[k-2]因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] &#x3D; f[k-3] + f[k-4]即在f[k-2] 的前面进行查找 k -&#x3D;2即下次循环 mid &#x3D; f[k - 1 - 2] - 1\n\nif (key &gt; temp[mid]) &#123;    low = mid + 1;    //为什么是k -=2    //说明    //1. 全部元素 = 前面的元素 + 后边元素    //2. f[k] = f[k-1] + f[k-2]    //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]    //4. 即在f[k-2] 的前面进行查找 k -=2    //5. 即下次循环 mid = f[k - 1 - 2] - 1    k -= 2;&#125; \n\n\n\n\n\n代码\npackage com.nie.Bzhan.Search;import java.util.Arrays;public class FibonacciSerch &#123;    public static int maxSize = 20;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 8, 10, 189, 1000, 1234&#125;;        System.out.println(&quot;index=&quot; + fibSearch(arr, 1234));// 0    &#125;    //因为后面我们mid=low+F(k-1)-1  需要使用到斐波那契数列,因此我们需要先获取到一一个斐波那契数列    //非递归的方法 得到一个斐波拉契数列    public static int[] fib() &#123;        int[] f = new int[maxSize];        f[0] = 1;        f[1] = 1;        for (int i = 2; i &lt; maxSize; i++) &#123;            f[i] = f[i - 1] + f[i - 2];        &#125;        return f;    &#125;    //编写斐波那契查找算法    //使用非递归的方式编写算法    public static int fibSearch(int[] a, int key) &#123;        int low = 0;        int high = a.length - 1;        int k = 0;//表示斐波拉契分隔值的下标        int mid = 0;//存放mid值        int f[] = fib();//获取到斐波拉契数列        //获取到斐波拉契分隔值的下标        while (high &gt; f[k] - 1) &#123;            k++;        &#125;        int[] temp = Arrays.copyOf(a, f[k]);        for (int i = high + 1; i &lt; temp.length; i++) &#123;            temp[i] = a[high];        &#125;        while (low &lt;= low) &#123;            mid = low + f[k - 1] - 1;            if (key &lt; temp[mid]) &#123;                high = mid - 1;                //为甚是 k--                //说明                //1. 全部元素 = 前面的元素 + 后边元素                //2. f[k] = f[k-1] + f[k-2]                //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]                //即 在 f[k-1] 的前面继续查找 k--                //即下次循环 mid = f[k-1-1]-1                k--;            &#125; else if (key &gt; temp[mid]) &#123;                low = mid + 1;                //为什么是k -=2                //说明                //1. 全部元素 = 前面的元素 + 后边元素                //2. f[k] = f[k-1] + f[k-2]                //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]                //4. 即在f[k-2] 的前面进行查找 k -=2                //5. 即下次循环 mid = f[k - 1 - 2] - 1                k -= 2;            &#125; else &#123;                if (mid &lt;= high) &#123;                    return mid;                &#125; else &#123;                    return high;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;\n\n\n\n","categories":["-算法"],"tags":["斐波那契","基础","查找"]},{"title":"LC155-最小栈","url":"http://example.com/2020/12/08/LC155/","content":"155. 最小栈难度简单745\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\npush(x) —— 将元素 x 推入栈中。\n\npop() —— 删除栈顶的元素。\n\ntop() —— 获取栈顶元素。\n\ngetMin() —— 检索栈中的最小元素。\n  \n\n\n\n示例:\n输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.\n\n思路\npush()方法: 每当push() 新值进来时,如果小于等于minstack栈顶值,则一起Push() 到minstack.即更新了栈顶最小值\npop方法: 判断pop() 出去的元素值是否是minstack栈顶元素(即最小值),如果是则将minstack栈顶元素一起pop(),这样可以保证min_stack栈顶元素始终是stack中的最小值。\ngetMin()方法： 返回min_stack栈顶即可。\n\nmin_stack作用分析：\n\nmin_stack等价于遍历stack所有元素,把升序的数字都删除掉,留下一个从栈底到栈定降序的栈\n相当于给stack中的降序元素做了标记,每当pop() 这些元素,min_stack会将相应的栈顶元素pop() 出去,保证其栈顶元素始终是stack的最小元素\n\n\n\n\n代码:\npackage com.nie.LEE.jike.CLass04StackQuenu;import java.util.Stack;public class LEE155 &#123;    class MinStack &#123;        private Stack&lt;Integer&gt; stack;        private Stack&lt;Integer&gt; minStack;        /**         * initialize your data structure here.         */        public MinStack() &#123;            //  # 数据栈            stack = new Stack&lt;&gt;();            //        # 辅助栈            minStack = new Stack&lt;&gt;();        &#125;        public void push(int x) &#123;            stack.push(x);            if (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;                minStack.push(x);            &#125; else &#123;                return;            &#125;        &#125;        public void pop() &#123;            if (stack.pop().equals(minStack.peek())) &#123;                minStack.pop();            &#125;        &#125;        public int top() &#123;            return stack.peek();        &#125;        public int getMin() &#123;            return minStack.peek();        &#125;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","栈"]},{"title":"LC20-有效的括号","url":"http://example.com/2020/12/07/LC20/","content":"20. 有效的括号难度简单2031\n给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\n输入: “()”输出: true\n输入: “()[]{}”输出: true\n输入: “(]”输出: false\n输入: “([)]”输出: false\n\n方法一:使用栈,哈希映射（HashMap）使用栈,哈希映射（HashMap）\n   \n\n哈希映射（HashMap）存储每一种括号。哈希映射的键为右括号，值为相同类型的左括号。\n我们对给定的字符串 s 进行遍历，当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。\n遇到一个右括号时，我们需要将一个相同类型的左括号闭合。取出栈顶的左括号并判断它们是否是相同类型的括号。\n如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。\n使用哈希映射（HashMap）存储每一种括号。哈希映射的键为右括号，值为相同类型的左括号。\n在遍历结束后，如果栈中没有左括号，说明我们将字符串 ss 中的所有左括号闭合，返回 True，否则返回 False。\n注意到有效字符串的长度一定为偶数\npublic static boolean isValid(String s) &#123;       int n = s.length();    if (n % 2 == 1) &#123;        return false;    &#125;        char[] chars = s.toCharArray();    Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();    HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;();    map.put(&#x27;)&#x27;, &#x27;(&#x27;);    map.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);    map.put(&#x27;]&#x27;, &#x27;[&#x27;);    for (int i = 0; i &lt; chars.length; i++) &#123;        if (map.containsKey(chars[i])) &#123;            if (stack.isEmpty() || stack.peek() != map.get(chars[i])) &#123;                return false;            &#125;            stack.pop();        &#125; else &#123;            stack.push(chars[i]);        &#125;    &#125;    return stack.isEmpty();&#125;\n\n\n\n\n\n\n\n方法二:使用栈\n方法一的简单版\n\n由于正确的括号都是 ()[]{} 一一对应的关系\n按将第一个    (     对应的     )    放入栈中\n当遍历到    )     时 判断    )    是否在栈定弹出的元素 是继续循环  2,3  否则返回flase\n\npublic static boolean isValid1(String s) &#123;        int n = s.length();        if (n % 2 == 1) &#123;            return false;        &#125;        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();        for (char c : s.toCharArray()) &#123;            if (c == &#x27;[&#x27;) &#123;                stack.push(&#x27;]&#x27;);            &#125; else if (c == &#x27;&#123;&#x27;) &#123;                stack.push(&#x27;&#125;&#x27;);            &#125; else if (c == &#x27;(&#x27;) &#123;                stack.push(&#x27;)&#x27;);            &#125; else if (stack.isEmpty() || c == stack.pop()) &#123;                return true;            &#125;else &#123;                return false;            &#125;        &#125;        return stack.isEmpty();    &#125;\n\n\n\n","categories":["-算法"],"tags":["LeetCode","栈","有效括号"]},{"title":"LC快刷数组.链表.跳表","url":"http://example.com/2020/12/06/LC快刷数组-链表-跳表/","content":"快刷:数组、链表、跳表两数之和题目： https://leetcode-cn.com/problems/two-sum/Array 实战题目https://leetcode-cn.com/problems/container-with-most-water/https://leetcode-cn.com/problems/move-zeroes/https://leetcode.com/problems/climbing-stairs/https://leetcode-cn.com/problems/3sum/ (高频老题）Linked List 实战题目https://leetcode.com/problems/reverse-linked-list/https://leetcode.com/problems/swap-nodes-in-pairshttps://leetcode.com/problems/linked-list-cyclehttps://leetcode.com/problems/linked-list-cycle-iihttps://leetcode.com/problems/reverse-nodes-in-k-group/\n   \n\n课后作业https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/https://leetcode-cn.com/problems/rotate-array/https://leetcode-cn.com/problems/merge-two-sorted-lists/https://leetcode-cn.com/problems/merge-sorted-array/https://leetcode-cn.com/problems/two-sum/https://leetcode-cn.com/problems/move-zeroes/https://leetcode-cn.com/problems/plus-one/\n1. 两数之和https://leetcode-cn.com/problems/two-sum/\n方法一:暴力破解\npublic int[] twoSum(int[] nums, int target) &#123;       for (int i = 0; i &lt; nums.length - 1; i++) &#123;           for (int j = i + 1; j &lt; nums.length; j++) &#123;               if (target == (nums[i] + nums[j])) &#123;                   return new int[]&#123;i, j&#125;;               &#125;           &#125;       &#125;       return null;   &#125;\n\n方法一二,利用集合map\n思想:\n\n开始遍历数组,将便利的数放到map中&lt; 数的值,  对应的下标 &gt;\n利用int num = target - nums[i];   得到我们所需要的数\n在每次便利的时候,看我们所需要的数是否在集合map中\n如果在返回对应的数,,,否则则继续便利\n\npublic int[] twoSum(int[] nums, int target) &#123;       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            int num = target - nums[i];            if (!map.containsKey(num)) &#123;                map.put(nums[i], i);            &#125; else &#123;                return new int[]&#123;map.get(num), i&#125;;            &#125;        &#125;        return null;&#125;\n\n11. 盛最多水的容器https://leetcode-cn.com/problems/container-with-most-water/\n利用双指针法\n\n设置两个指针,一前  一后\n每次将两个指针对应的面积求出,保存,,与前一个面积比较,保存大的\n将两个指针对应的高度,,,小的向另外一边进行遍历,重复第二的\n直到i&lt;j\n\npublic int maxArea(int[] height) &#123;       int i=0;       int j=(height.length-1);       int area=0;       while (i&lt;j)&#123;           if (height[i]&lt;=height[j])&#123;               area=Math.max(area,(height[i])*(j-i));               i++;           &#125;else &#123;               area=Math.max(area,(height[j])*(j-i));               j--;           &#125;       &#125;       return  area;   &#125;\n\n283. 移动零https://leetcode-cn.com/problems/move-zeroes/\n双指针法\n\n设置快慢指针\nj慢指针表示  非零数的前一个下标   慢指针\ni表示是不是非零数字  快指针\n\npublic static void moveZeroes1(int[] nums) &#123;       int j = 0;       for (int i = 0; i &lt; nums.length; i++) &#123;           if (nums[i] != 0) &#123;               if (nums[j] == 0) &#123;                       nums[j]=nums[i];                       nums[i]=0;               &#125;               j++;           &#125;       &#125;   &#125;\n\n\n\n26. 删除排序数组中的重复项示例 1:\n给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。\n双指针 快慢指针\npublic int removeDuplicates(int[] nums) &#123;      //慢指针      int a=0;      //快指针      for (int i = 1; i &lt;nums.length ; i++) &#123;          if (nums[a]!=nums[i])&#123;              a++;              nums[a]=nums[i];          &#125;      &#125;      a=a+1;      return  a;  &#125;\n\n\n\n27. 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\nclass Solution &#123;    public int removeElement(int[] nums, int val) &#123;    int i = 0;    for (int j = 0; j &lt; nums.length; j++) &#123;        if (nums[j] != val) &#123;                        nums[i] = nums[j];            i++;        &#125;    &#125;    return i;    &#125;&#125;\n\n\n\n\n\n70. 爬楼梯https://leetcode-cn.com/problems/climbing-stairs/\n\n//该数组每个元素的指针对应的是台阶数,元素的值存放的是台阶数对应的方法数\n\n不管怎样,数组下标指针肯定是从0开始的,所以要考虑0.有0个台阶,不需要爬,所以没有方法数(但从斐波那契角度,dp[0]=1)\n\ndp[1] = 1; //1阶台阶,只有一种方式(1)\n\n2阶台阶,有两种方式(1+1, 2), 因为题目设定n是正整数,所以n最小是1,此时如果定义dp的长度是int[n + 1],则length=2\n而dp[2]实际对应的是第三个元素,超出length了,所以定义new int[n + 2]更合理\n\n从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和,,,第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推….\n\n\npublic int climbStairs(int n) &#123;        int[] dp = new int[n + 2]; //该数组每个元素的指针对应的是台阶数,元素的值存放的是台阶数对应的方法数        //dp[0] = 0; //不管怎样,数组下标指针肯定是从0开始的,所以要考虑0.有0个台阶,不需要爬,所以没有方法数(但从斐波那契角度,dp[0]=1)        dp[1] = 1; //1阶台阶,只有一种方式(1)        //2阶台阶,有两种方式(1+1, 2), 因为题目设定n是正整数,所以n最小是1,此时如果定义dp的长度是int[n + 1],则length=2        //而dp[2]实际对应的是第三个元素,超出length了,所以定义new int[n + 2]更合理        dp[2] = 2;        //从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和        //第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推....        for (int i = 3; i &lt;= n; i++) &#123; //要遍历到第n个台阶,所以指针其实是从0到n,所以dp数组数量比n多1            dp[i] = dp[i - 1] + dp[i - 2]; //最后到第n个台阶,得到结果后正好遍历完        &#125;        return dp[n];  &#125;\n\n15. 三数之和https://leetcode-cn.com/problems/3sum/\n方法一:\n利用暴力破解\n注意主要的是去重复\n\nif (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue;\n\n超时\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; inList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; nums.length - 2; i++) &#123;            if (nums[i] &gt; 0) break;//第一个数大于零 结束\t\t\t//去重复            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue;            for (int j = i + 1; j &lt; nums.length - 1; j++) &#123;                if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) continue;                for (int k = j + 1; k &lt; nums.length; k++) &#123;                                        if (k &gt; j + 1 &amp;&amp; nums[k - 1] == nums[k]) continue;  //去重原理同j                    if ((nums[i] + nums[j] + nums[k]) == 0) &#123;                        List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();                        curr.add(nums[i]);                        curr.add(nums[j]);                        curr.add(nums[k]);                        inList.add(curr);                    &#125;                &#125;            &#125;        &#125;\n\n\n\n方法二:\n利用集合的特性将 方法一中的一个for循环代替\n\n先排序\n\n利用hashmap的特性判断是否在数组中\n\n先将每个数组遍历放到map中,最后一的数字用map集合进行进行遍历\n\n注意各种去重复的放方法\nif (nums[i] &gt; 0) break;if (nums[i] + nums[j] &gt; 0) break;//去重原理同i，j必须大于i + 1，因为j是从i + 1开始的，必须要大于开始值才能后退一步if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) continue;\n\n\n\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum1(int[] nums) &#123;    Arrays.sort(nums);    ArrayList&lt;List&lt;Integer&gt;&gt; inList = new ArrayList&lt;&gt;();    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        map.put(nums[i], i);    &#125;    for (int i = 0; i &lt; nums.length - 2; i++) &#123;        if (nums[i] &gt; 0) break;        if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue;        for (int j = i + 1; j &lt; nums.length - 1; j++) &#123;            if (nums[i] + nums[j] &gt; 0) break;            //去重原理同i，j必须大于i + 1，因为j是从i + 1开始的，必须要大于开始值才能后退一步            if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) continue;            int z = 0 - nums[i] - nums[j];            if (map.containsKey(z)) &#123;                List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();                curr.add(nums[i]);                curr.add(nums[j]);                curr.add(z);                inList.add(curr);            &#125;        &#125;    &#125;    return inList;&#125;\n\n方法三:\n利用三指针的方法\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum2(int[] nums) &#123;          List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      if (nums.length == 0 &amp;&amp; nums.length &lt; 3) &#123;          return result;      &#125;      Arrays.sort(nums);      for (int i = 0; i &lt; nums.length; i++) &#123;          if (i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue;          int a = i + 1;          int b = nums.length - 1;          while (a &lt; b) &#123;              if ((nums[i] + nums[a] + nums[b]) == 0) &#123;                  List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();                  curr.add(nums[i]);                  curr.add(nums[a]);                  curr.add(nums[b]);                  result.add(curr);                  a++;                  b--;                  while (a &lt; nums.length &amp;&amp; nums[a] == nums[a - 1]) a++;                  while (b &gt; a &amp;&amp; nums[b] == nums[b + 1]) b--;              &#125; else if (nums[a] + nums[b] &lt; (-nums[i])) &#123;                  a++;              &#125; else &#123;                  b--;              &#125;          &#125;      &#125;      return result;  &#125;\n\n\n\n206. 反转链表https://leetcode-cn.com/problems/reverse-linked-list\n利用双指针法\nclass Solution &#123;   public ListNode reverseList(ListNode head) &#123;        ListNode newHead = null;        ListNode temp;        while (head != null) &#123;            temp = head.next;            head.next = newHead;           newHead=head;           head=temp;        &#125;        return  newHead;    &#125;&#125;\n\n递归\n   public ListNode reverseList(ListNode head) &#123;       if (head == null || head.next == null) &#123;            return head;        &#125;        ListNode cur=reverseList(head.next);        head.next.next=head;        head.next=null;        return  cur;&#125;\n\n\n\n三种解法请看:\nhttps://blog.csdn.net/qq_44236958/article/details/109685806\n24. 两两交换链表中的节点递归\npublic ListNode swapPairs(ListNode head) &#123;     if (head == null || head.next == null) &#123;         return head;     &#125;     ListNode temp = head.next;     head.next = swapPairs(temp.next);     temp.next = head;     return temp; &#125;\n\n利用栈的特性\npublic ListNode swapPairs1(ListNode head) &#123;    if (head == null || head.next == null) &#123;        return head;    &#125;    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();    ListNode p=new ListNode(0);    ListNode temp=head;    head=p;    while (temp!=null&amp;&amp;temp.next!=null)&#123;        stack.push(temp);        stack.push(temp.next);        temp=temp.next.next;        p.next=stack.pop();        p=p.next;        p.next=stack.pop();        p=p.next;    &#125;    if (temp!=null)&#123;        p.next=temp;    &#125;else &#123;        p.next=null;    &#125;    return  head.next;&#125;\n\n141. 环形链表关于链表的小总结\n\n\n利用集合存放数据,不在就就存放数据,进行遍历\npublic boolean hasCycle(ListNode head) &#123;        HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();        ListNode temp=head;        while (temp!=null)&#123;            if (set.contains(temp))&#123;                return true;            &#125;            else &#123;                set.add(temp);            &#125;            temp=temp.next;        &#125;        return  false;    &#125;\n\n利用快慢指针\npublic boolean hasCycle1(ListNode head) &#123;       if (head == null || head.next == null) &#123;           return false;       &#125;     ListNode slow=head;       ListNode fast=head.next;       while (slow!=fast)&#123;           if (fast==null||fast.next==null)&#123;               return  false;           &#125;           slow=slow.next;           fast=fast.next.next;       &#125;jaba       return true;   &#125;\n\n142. 环形链表 II\n\n利用集合进行普通的遍历\npublic ListNode detectCycle(ListNode head) &#123;    HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();    while (head != null) &#123;        if (set.contains(head)) &#123;            return head;        &#125; else &#123;            set.add(head);        &#125;        head = head.next;    &#125;    return null;&#125;\n\n快慢指针进行遍历\n具体详解看\n根据：\n\nf=2s （快指针每次2步，路程刚好2倍）\nf = s + nb (相遇时，刚好多走了n圈）\n\n推出：s = nb\n从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。\n如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步\n\n\n\n\n\n\npublic ListNode detectCycle2(ListNode head) &#123;    if (head == null || head.next == null) &#123;        return null;    &#125;    ListNode slow = head;    ListNode fast = head;    while (true) &#123;        if (fast == null || fast.next == null) &#123;            return null;        &#125;        slow = slow.next;        fast = fast.next.next;        if (fast == slow) break;    &#125;    fast = head;    while (slow != fast) &#123;        slow = slow.next;        fast = fast.next;    &#125;    return fast;&#125;\n\n25. K 个一组翻转链表多种解法请看\n栈,递归,迭代\n递归\npublic ListNode reverseKGroup(ListNode head, int k) &#123;if (head==null||head.next==null)&#123;    return head;&#125;    ListNode tail=head;    for (int i = 0; i &lt; k; i++) &#123;        if (tail==null)&#123;            return  head;        &#125;        tail =tail.next;    &#125;    ListNode newHead=reverse(head,tail);    head.next=reverseKGroup(tail,k);    return  newHead;&#125;private ListNode reverse(ListNode head, ListNode tail) &#123;ListNode pre=null;ListNode next=null;while (head!=tail)&#123;    next=head.next;    head.next=pre;    //不能换顺序    pre = head;    head = next;&#125;return  pre;&#125;\n\n\n\n迭代\n\n1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7\n反转K个,由于遍历k个链表,然后将第k个节点的next指向空(防止循环)\n这样就得到了长度为k的单链表了。1-&gt;2-&gt;3 4-&gt;5-&gt;6-&gt;7\n然后反转所截的\n如果遍历完整个链表，发现最后几个节点的长度不足k，那么直接退出就可以了。\n把长度k的链表前后指向切断，这样就不会出现循环指向了。\n\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;//新节点        ListNode cur = head;//辅助结点进行反转的        while (cur != null) &#123;            ListNode temp = cur.next;标记下一次需要反转的节点            cur.next = pre;//已经开始反转            //移动节点  准备下一次反转            pre = cur;            cur = temp;        &#125;        return pre;    &#125;    public ListNode reverseKGroup(ListNode head, int k) &#123;        if (head == null || k &lt; 0) &#123;            return head;        &#125;        ListNode dummy = new ListNode(-1);        //新节点指向头节点        dummy.next = head;        //设置辅助指针进行遍历        ListNode p = dummy;        int n = k;        while (p.next != null) &#123;            //辅助指针进行遍历            ListNode temp = p;            while (temp != null &amp;&amp; temp.next != null &amp;&amp; n &gt; 0) &#123;                //在合法范围之内遍历到  k的位置上                temp = temp.next;                --n;            &#125;            if (n == 0) &#123;                //报先记录下temp.next,方便后面链接链表                ListNode nextNode = temp.next;                //得到开始要遍历的节点                //假设链表为1-&gt;2-&gt;3-&gt;4，下面的nextNode就是4，tail是1                ListNode tail = p.next;                //反转之前需要将下一个节点保存，并设置next为空，防止循环指向                temp.next = null;                //进行反转                //p 也即是dummy指向反转后的节点 dummy-&gt;2-&gt;1                p.next = reverseList(tail);                //翻转后头节点变到最后。通过.next把断开的链表重新链接。                //1&lt;-2 3-&gt;4 转换成为    2-&gt;1-&gt;3-&gt;4                tail.next = nextNode;                //移动p节点进行下一个遍历                p = tail;                n = k;            &#125; else &#123;                break;            &#125;        &#125;        return dummy.next;    &#125;\n\n\n\n\n\n\n\n189. 旋转数组输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]\n方法一:\n三次数值的反转\n第一次: revers(nums, 0, nums.length - 1);   7,6,5,4,3,2,1\n第二次  revers(nums, 0, k - 1);      5,6,7,4,3,2,1\n第三次 revers(nums, k, nums.length - 1);   5,6,7,1,2,3,4\npublic void rotate(int[] nums, int k) &#123;       //元素向右移动 k 个位置       //在此与原数组的模  防止出界       k = k % nums.length;       revers(nums, 0, nums.length - 1);       revers(nums, 0, k - 1);       revers(nums, k, nums.length - 1);   &#125;   private void revers(int[] nums, int start, int end) &#123;       while (start &lt; end) &#123;           int temp = nums[start];           nums[start] = nums[end];           nums[end] = temp;           start++;           end--;       &#125;   &#125;\n\n\n\n暴力\n最简单的方法是旋转k次,每次将数组旋转一个元素\npublic void rotate1(int[] nums, int k) &#123;      int temp = 0;      int pre = 0;      for (int j = 0; j &lt; k; j++) &#123;          pre = nums[nums.length - 1];          for (int i = 0; i &lt; nums.length; i++) &#123;              temp = nums[i];              nums[i] = pre;              pre = temp;          &#125;      &#125;  &#125;\n\n\n\n环状替代\n思路\n把元素看做同学，把下标看做座位，大家换座位。第一个同学离开座位去第k+1个座位，第k+1个座位的同学被挤出去了，他就去坐他后k个座位，如此反复。但是会出现一种情况，就是其中一个同学被挤开之后，坐到了第一个同学的位置（空位置，没人被挤出来），但是此时还有人没有调换位置，这样就顺着让第二个同学换位置。 那么什么时候就可以保证每个同学都换完了呢？n个同学，换n次，所以用一个count来计数即可。\n\n\npublic static void rotate2(int[] nums, int k) &#123;    k = k % nums.length;    int count = 0;//记录交换的次数  判断是否终止结束    for (int start = 0; count &lt; nums.length; start++) &#123;        int current=start;//现在需要交换的值下标        int prev=nums[start];//现在需要交换的值        do&#123;            //保存被交换的下标位next            int next=(current+k)%nums.length;           //保存被交换的值            int temp=nums[next];            nums[next]=prev;//交换            prev=temp;//保存下一次交换的值            current=next;//下一次需要交换的坐标的            count++;//交换次数加一            //判断现在交换的值是否已经交换了.如已经交换,由右临开始        &#125;while (start!=current);    &#125;    System.out.println(Arrays.toString(nums));&#125;\n\n\n\n21. 合并两个有序链表输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n\n\n方法一:\n递归\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;       if (l1 == null) &#123;           return l2;       &#125;       if (l2 == null) &#123;           return l1;       &#125;       if (l1.val &lt; l2.val) &#123;           l1.next = mergeTwoLists(l1.next, l2);           return l1;       &#125; else &#123;           l2.next = mergeTwoLists(l1, l2.next);           return l2;       &#125;   &#125;\n\n方法二:\n迭代\npublic ListNode mergeTwoLists4(ListNode l1, ListNode l2) &#123;    ListNode head = new ListNode(0);    ListNode temp = head;    while (l1 != null &amp;&amp; l2 != null) &#123;        if (l1.val &lt; l2.val) &#123;            temp.next = l1;            l1 = l1.next;        &#125; else &#123;            temp.next = l2;            l2 = l2.next;        &#125;        temp = temp.next;    &#125;    temp.next = l1 == null ? l2 : l1;    return head.next;&#125;\n\n88. 合并两个有序数组最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(Java是2行)，时间复杂度较差，为O((n + m)\\log(n + m))O((n+m)log(n+m))。这是由于这种方法没有利用两个数组本身已经有序这一点\nclass Solution &#123;  public void merge(int[] nums1, int m, int[] nums2, int n) &#123;    System.arraycopy(nums2, 0, nums1, m, n);    Arrays.sort(nums1);  &#125;&#125;\n\n从后向前数组遍历\n因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充当 len1&lt;0 时遍历结束，此时 nums2 中海油数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组时间复杂度：O(m+n)O(m+n)\npublic void merge(int[] nums1, int m, int[] nums2, int n) &#123;    int len1 = m - 1;    int len2 = n - 1;    int len = m + n - 1;    while (len1 &gt;= 0 &amp;&amp; len2 &gt;= 0) &#123;        // 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码        nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];    &#125;    // 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1    System.arraycopy(nums2, 0, nums1, 0, len2 + 1);&#125;\n\n1. 两数之和给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]\n利用集合\n    public int[] twoSum(int[] nums, int target) &#123;       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            int num = target - nums[i];            if (!map.containsKey(num)) &#123;                map.put(nums[i], i);            &#125; else &#123;                return new int[]&#123;map.get(num), i&#125;;            &#125;        &#125;        return null;&#125;\n\n66. 加一示例 1：\n输入：digits = [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。\n\npublic static void main(String[] args) &#123;      int[] ints = new int[]&#123;9, 9, 9, 9&#125;;      System.out.println(plusOne(ints));  &#125;  public static int[] plusOne(int[] digits) &#123;      int len = digits.length;      for (int i = len - 1; i &gt;= 0; i--) &#123;          digits[i]++;          digits[i] %= 10;          if (digits[i] != 0) &#123;              return digits;          &#125;      &#125;      digits = new int[len + 1];      digits[0] = 1;      return digits;  &#125;\n\n","categories":["-算法"],"tags":["链表","LeetCode","双指针","数组"]},{"title":"LC0283-移动零--LC026-删除排序数组中的重复项--LC027-移除元素{双指针解决}","url":"http://example.com/2020/12/06/LC283-LC026-LC027/","content":"283. 移动零https://leetcode-cn.com/problems/move-zeroes/\n双指针法\n\n设置快慢指针\nj慢指针表示  非零数的前一个下标   慢指针\ni表示是不是非零数字  快指针\n\n   \n\npublic static void moveZeroes1(int[] nums) &#123;       int j = 0;       for (int i = 0; i &lt; nums.length; i++) &#123;           if (nums[i] != 0) &#123;               if (nums[j] == 0) &#123;                       nums[j]=nums[i];                       nums[i]=0;               &#125;               j++;           &#125;       &#125;   &#125;\n\n\n\n26. 删除排序数组中的重复项示例 1:\n给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。\n双指针 快慢指针\npublic int removeDuplicates(int[] nums) &#123;      //慢指针      int a=0;      //快指针      for (int i = 1; i &lt;nums.length ; i++) &#123;          if (nums[a]!=nums[i])&#123;              a++;              nums[a]=nums[i];          &#125;      &#125;      a=a+1;      return  a;  &#125;\n\n\n\n27. 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\nclass Solution &#123;    public int removeElement(int[] nums, int val) &#123;    int i = 0;    for (int j = 0; j &lt; nums.length; j++) &#123;        if (nums[j] != val) &#123;                        nums[i] = nums[j];            i++;        &#125;    &#125;    return i;    &#125;&#125;\n\n\n\n","categories":["-算法"],"tags":["LeetCode","双指针"]},{"title":"LC189-旋转数组","url":"http://example.com/2020/12/06/LC189/","content":"189. 旋转数组输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]\n方法一:\n三次数值的反转\n第一次: revers(nums, 0, nums.length - 1);   7,6,5,4,3,2,1\n第二次  revers(nums, 0, k - 1);      5,6,7,4,3,2,1\n第三次 revers(nums, k, nums.length - 1);   5,6,7,1,2,3,4\n   \n\n\n\npublic void rotate(int[] nums, int k) &#123;       //元素向右移动 k 个位置       //在此与原数组的模  防止出界       k = k % nums.length;       revers(nums, 0, nums.length - 1);       revers(nums, 0, k - 1);       revers(nums, k, nums.length - 1);   &#125;   private void revers(int[] nums, int start, int end) &#123;       while (start &lt; end) &#123;           int temp = nums[start];           nums[start] = nums[end];           nums[end] = temp;           start++;           end--;       &#125;   &#125;\n\n\n\n暴力\n最简单的方法是旋转k次,每次将数组旋转一个元素\npublic void rotate1(int[] nums, int k) &#123;      int temp = 0;      int pre = 0;      for (int j = 0; j &lt; k; j++) &#123;          pre = nums[nums.length - 1];          for (int i = 0; i &lt; nums.length; i++) &#123;              temp = nums[i];              nums[i] = pre;              pre = temp;          &#125;      &#125;  &#125;\n\n\n\n环状替代\n思路\n把元素看做同学，把下标看做座位，大家换座位。第一个同学离开座位去第k+1个座位，第k+1个座位的同学被挤出去了，他就去坐他后k个座位，如此反复。但是会出现一种情况，就是其中一个同学被挤开之后，坐到了第一个同学的位置（空位置，没人被挤出来），但是此时还有人没有调换位置，这样就顺着让第二个同学换位置。 那么什么时候就可以保证每个同学都换完了呢？n个同学，换n次，所以用一个count来计数即可。\n\n\npublic static void rotate2(int[] nums, int k) &#123;    k = k % nums.length;    int count = 0;//记录交换的次数  判断是否终止结束    for (int start = 0; count &lt; nums.length; start++) &#123;        int current=start;//现在需要交换的值下标        int prev=nums[start];//现在需要交换的值        do&#123;            //保存被交换的下标位next            int next=(current+k)%nums.length;           //保存被交换的值            int temp=nums[next];            nums[next]=prev;//交换            prev=temp;//保存下一次交换的值            current=next;//下一次需要交换的坐标的            count++;//交换次数加一            //判断现在交换的值是否已经交换了.如已经交换,由右临开始        &#125;while (start!=current);    &#125;    System.out.println(Arrays.toString(nums));&#125;\n\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"LC141_LC142环形链表 1 2","url":"http://example.com/2020/12/06/LC141-LC142/","content":"141. 环形链表关于链表的小总结\n\n利用集合存放数据,不在就就存放数据,进行遍历   \n\npublic boolean hasCycle(ListNode head) &#123;        HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();        ListNode temp=head;        while (temp!=null)&#123;            if (set.contains(temp))&#123;                return true;            &#125;            else &#123;                set.add(temp);            &#125;            temp=temp.next;        &#125;        return  false;    &#125;\n\n利用快慢指针public boolean hasCycle1(ListNode head) &#123;       if (head == null || head.next == null) &#123;           return false;       &#125;     ListNode slow=head;       ListNode fast=head.next;       while (slow!=fast)&#123;           if (fast==null||fast.next==null)&#123;               return  false;           &#125;           slow=slow.next;           fast=fast.next.next;       &#125;jaba       return true;   &#125;\n\n142. 环形链表 II\n利用集合进行普通的遍历public ListNode detectCycle(ListNode head) &#123;    HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();    while (head != null) &#123;        if (set.contains(head)) &#123;            return head;        &#125; else &#123;            set.add(head);        &#125;        head = head.next;    &#125;    return null;&#125;\n\n\n\n\n\n\n\n\n\n\n\n快慢指针进行遍历具体详解看\n根据：\n\nf=2s （快指针每次2步，路程刚好2倍）\nf = s + nb (相遇时，刚好多走了n圈）\n\n推出：s = nb\n从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。\n如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步\n\npublic ListNode detectCycle2(ListNode head) &#123;    if (head == null || head.next == null) &#123;        return null;    &#125;    ListNode slow = head;    ListNode fast = head;    while (true) &#123;        if (fast == null || fast.next == null) &#123;            return null;        &#125;        slow = slow.next;        fast = fast.next.next;        if (fast == slow) break;    &#125;    fast = head;    while (slow != fast) &#123;        slow = slow.next;        fast = fast.next;    &#125;    return fast;&#125;\n\n","categories":["-算法"],"tags":["链表","LeetCode","环形链表"]},{"title":"LC070-爬楼梯","url":"http://example.com/2020/12/06/LC070/","content":"70. 爬楼梯https://leetcode-cn.com/problems/climbing-stairs/\n\n//该数组每个元素的指针对应的是台阶数,元素的值存放的是台阶数对应的方法数\n\n不管怎样,数组下标指针肯定是从0开始的,所以要考虑0.有0个台阶,不需要爬,所以没有方法数(但从斐波那契角度,dp[0]=1)\n\ndp[1] = 1; //1阶台阶,只有一种方式(1)\n\n2阶台阶,有两种方式(1+1, 2), 因为题目设定n是正整数,所以n最小是1,此时如果定义dp的长度是int[n + 1],则length=2\n而dp[2]实际对应的是第三个元素,超出length了,所以定义new int[n + 2]更合理\n\n从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和,,,第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推….\n\n\n   \n\npublic int climbStairs(int n) &#123;        int[] dp = new int[n + 2]; //该数组每个元素的指针对应的是台阶数,元素的值存放的是台阶数对应的方法数        //dp[0] = 0; //不管怎样,数组下标指针肯定是从0开始的,所以要考虑0.有0个台阶,不需要爬,所以没有方法数(但从斐波那契角度,dp[0]=1)        dp[1] = 1; //1阶台阶,只有一种方式(1)        //2阶台阶,有两种方式(1+1, 2), 因为题目设定n是正整数,所以n最小是1,此时如果定义dp的长度是int[n + 1],则length=2        //而dp[2]实际对应的是第三个元素,超出length了,所以定义new int[n + 2]更合理        dp[2] = 2;        //从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和        //第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推....        for (int i = 3; i &lt;= n; i++) &#123; //要遍历到第n个台阶,所以指针其实是从0到n,所以dp数组数量比n多1            dp[i] = dp[i - 1] + dp[i - 2]; //最后到第n个台阶,得到结果后正好遍历完        &#125;        return dp[n];  &#125;\n\n","categories":["-算法"],"tags":["LeetCode","斐波那契"]},{"title":"LC066-加一","url":"http://example.com/2020/12/06/LC066/","content":"66. 加一示例 1：\n输入：digits = [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。\n\n\n\n\n\n   \n\n\n\npublic static void main(String[] args) &#123;      int[] ints = new int[]&#123;9, 9, 9, 9&#125;;      System.out.println(plusOne(ints));  &#125;  public static int[] plusOne(int[] digits) &#123;      int len = digits.length;      for (int i = len - 1; i &gt;= 0; i--) &#123;          digits[i]++;          digits[i] %= 10;          if (digits[i] != 0) &#123;              return digits;          &#125;      &#125;      digits = new int[len + 1];      digits[0] = 1;      return digits;  &#125;\n\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"LC021_LC088 合并两个有序链表/合并两个有序数组","url":"http://example.com/2020/12/06/LC021-LC088/","content":"21. 合并两个有序链表输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n\n\n方法一:\n递归\n   \n\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;       if (l1 == null) &#123;           return l2;       &#125;       if (l2 == null) &#123;           return l1;       &#125;       if (l1.val &lt; l2.val) &#123;           l1.next = mergeTwoLists(l1.next, l2);           return l1;       &#125; else &#123;           l2.next = mergeTwoLists(l1, l2.next);           return l2;       &#125;   &#125;\n\n方法二:\n迭代\npublic ListNode mergeTwoLists4(ListNode l1, ListNode l2) &#123;    ListNode head = new ListNode(0);    ListNode temp = head;    while (l1 != null &amp;&amp; l2 != null) &#123;        if (l1.val &lt; l2.val) &#123;            temp.next = l1;            l1 = l1.next;        &#125; else &#123;            temp.next = l2;            l2 = l2.next;        &#125;        temp = temp.next;    &#125;    temp.next = l1 == null ? l2 : l1;    return head.next;&#125;\n\n88. 合并两个有序数组最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(Java是2行)，时间复杂度较差，为O((n + m)\\log(n + m))O((n+m)log(n+m))。这是由于这种方法没有利用两个数组本身已经有序这一点\nclass Solution &#123;  public void merge(int[] nums1, int m, int[] nums2, int n) &#123;    System.arraycopy(nums2, 0, nums1, m, n);    Arrays.sort(nums1);  &#125;&#125;\n\n从后向前数组遍历\n因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充当 len1&lt;0 时遍历结束，此时 nums2 中海油数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组时间复杂度：O(m+n)O(m+n)\npublic void merge(int[] nums1, int m, int[] nums2, int n) &#123;    int len1 = m - 1;    int len2 = n - 1;    int len = m + n - 1;    while (len1 &gt;= 0 &amp;&amp; len2 &gt;= 0) &#123;        // 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码        nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];    &#125;    // 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1    System.arraycopy(nums2, 0, nums1, 0, len2 + 1);&#125;\n\n","categories":["-算法"],"tags":["链表","LeetCode"]},{"title":"LC015-三数之和","url":"http://example.com/2020/12/06/LC015/","content":"15. 三数之和https://leetcode-cn.com/problems/3sum/\n利用暴力破解\n利用集合的特性将 方法一中的一个for循环代替\n利用三指针的方法\n方法一:利用暴力破解\n注意主要的是去重复\n\nif (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue;\n\n超时\n  \n\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; inList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; nums.length - 2; i++) &#123;            if (nums[i] &gt; 0) break;//第一个数大于零 结束\t\t\t//去重复            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue;            for (int j = i + 1; j &lt; nums.length - 1; j++) &#123;                if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) continue;                for (int k = j + 1; k &lt; nums.length; k++) &#123;                                        if (k &gt; j + 1 &amp;&amp; nums[k - 1] == nums[k]) continue;  //去重原理同j                    if ((nums[i] + nums[j] + nums[k]) == 0) &#123;                        List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();                        curr.add(nums[i]);                        curr.add(nums[j]);                        curr.add(nums[k]);                        inList.add(curr);                    &#125;                &#125;            &#125;        &#125;\n\n\n\n方法二:利用集合的特性将 方法一中的一个for循环代替\n\n先排序\n\n利用hashmap的特性判断是否在数组中\n\n先将每个数组遍历放到map中,最后一的数字用map集合进行进行遍历\n\n注意各种去重复的放方法\nif (nums[i] &gt; 0) break;if (nums[i] + nums[j] &gt; 0) break;//去重原理同i，j必须大于i + 1，因为j是从i + 1开始的，必须要大于开始值才能后退一步if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) continue;\n\n\n\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum1(int[] nums) &#123;    Arrays.sort(nums);    ArrayList&lt;List&lt;Integer&gt;&gt; inList = new ArrayList&lt;&gt;();    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        map.put(nums[i], i);    &#125;    for (int i = 0; i &lt; nums.length - 2; i++) &#123;        if (nums[i] &gt; 0) break;        if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue;        for (int j = i + 1; j &lt; nums.length - 1; j++) &#123;            if (nums[i] + nums[j] &gt; 0) break;            //去重原理同i，j必须大于i + 1，因为j是从i + 1开始的，必须要大于开始值才能后退一步            if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) continue;            int z = 0 - nums[i] - nums[j];            if (map.containsKey(z)) &#123;                List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();                curr.add(nums[i]);                curr.add(nums[j]);                curr.add(z);                inList.add(curr);            &#125;        &#125;    &#125;    return inList;&#125;\n\n方法三:利用三指针的方法\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum2(int[] nums) &#123;          List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      if (nums.length == 0 &amp;&amp; nums.length &lt; 3) &#123;          return result;      &#125;      Arrays.sort(nums);      for (int i = 0; i &lt; nums.length; i++) &#123;          if (i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue;          int a = i + 1;          int b = nums.length - 1;          while (a &lt; b) &#123;              if ((nums[i] + nums[a] + nums[b]) == 0) &#123;                  List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();                  curr.add(nums[i]);                  curr.add(nums[a]);                  curr.add(nums[b]);                  result.add(curr);                  a++;                  b--;                  while (a &lt; nums.length &amp;&amp; nums[a] == nums[a - 1]) a++;                  while (b &gt; a &amp;&amp; nums[b] == nums[b + 1]) b--;              &#125; else if (nums[a] + nums[b] &lt; (-nums[i])) &#123;                  a++;              &#125; else &#123;                  b--;              &#125;          &#125;      &#125;      return result;  &#125;\n\n\n\n","categories":["-算法"],"tags":["LeetCode","双指针","map","三指针"]},{"title":"LC011-盛最多水的容器","url":"http://example.com/2020/12/06/LC011/","content":"11. 盛最多水的容器https://leetcode-cn.com/problems/container-with-most-water/\n利用双指针法\n\n设置两个指针,一前  一后\n每次将两个指针对应的面积求出,保存,,与前一个面积比较,保存大的\n将两个指针对应的高度,,,小的向另外一边进行遍历,重复第二的\n直到i&lt;j\n\n   \n\npublic int maxArea(int[] height) &#123;       int i=0;       int j=(height.length-1);       int area=0;       while (i&lt;j)&#123;           if (height[i]&lt;=height[j])&#123;               area=Math.max(area,(height[i])*(j-i));               i++;           &#125;else &#123;               area=Math.max(area,(height[j])*(j-i));               j--;           &#125;       &#125;       return  area;   &#125;\n\n","categories":["-算法"],"tags":["LeetCode","双指针"]},{"title":"LC01-两数之和","url":"http://example.com/2020/12/06/LC01/","content":"1. 两数之和https://leetcode-cn.com/problems/two-sum/\n方法一:暴力破解public int[] twoSum(int[] nums, int target) &#123;       for (int i = 0; i &lt; nums.length - 1; i++) &#123;           for (int j = i + 1; j &lt; nums.length; j++) &#123;               if (target == (nums[i] + nums[j])) &#123;                   return new int[]&#123;i, j&#125;;               &#125;           &#125;       &#125;       return null;   &#125;\n\n方法二,利用集合map   \n\n思想:\n\n开始遍历数组,将便利的数放到map中&lt; 数的值,  对应的下标 &gt;\n利用int num = target - nums[i];   得到我们所需要的数\n在每次便利的时候,看我们所需要的数是否在集合map中\n如果在返回对应的数,,,否则则继续便利\n\npublic int[] twoSum(int[] nums, int target) &#123;       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            int num = target - nums[i];            if (!map.containsKey(num)) &#123;                map.put(nums[i], i);            &#125; else &#123;                return new int[]&#123;map.get(num), i&#125;;            &#125;        &#125;        return null;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","map"]},{"title":"javaSE21-IO","url":"http://example.com/2020/12/05/javaSE21/","content":"IO流File类\n是java.io包中很重要的一个类；\n\nFile类的对象可以表示文件，还可以表示目录，在程序中一个File类对象可以代表一个文件或目录；\n\nFile对象可以对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等；\nFile对象无法操作文件的具体数据,既不能直接对文件进行读写/操作\n//在当前目录下创建一个与aaa.txt文件名相关联的文件对象File f1 = new File(&quot;aaa.txt&quot;);//指明详细的路径以及文件名，请注意双斜线或用反斜杠File f2 = new File(&quot;D:\\\\Java\\\\Hello.java&quot;);//指明详细的路径以及目录名，请注意双斜线File f3 = new File(&quot;D:\\\\Java&quot;);\n\n\n\n构造方法 一  \n\nFile f = new File(&quot;E/naho.txt&quot;);//绝对路径       File f1 = new File(&quot;niiiho.txt&quot;);//相对路径\n\n构造方法 二String parent = &quot;E:\\\\&quot;;File f2 = new File(parent,&quot;demo.txt&quot;);File f3 = new File(parent,&quot;test.txt&quot;);\n\n构造方法 三File file1 = new File(&quot;EE:\\\\&quot;);File file2 = new File(file1, &quot;nihao.text&quot;);File fff = new File(&quot;E:\\\\niaho.txt&quot;); \n\nfile常用的方法\n[canExecute]     测试应用程序是否可以执行此抽象路径名表示的文件。\n[canRead]        测试应用程序是否可以读取此抽象路径名表示的文件。\n[canWrite]        测试应用程序是否可以修改此抽象路径名表示的文件。\nisAbsolute()  测试这个抽象路径名是否是绝对的。\nisHidden()`  测试此抽象路径名命名的文件是否为隐藏文件。\nisDirectory()`  测试此抽象路径名表示的文件是否为目录\nisFile()`  测试此抽象路径名表示的文件是否为普通文件。 \nexists()`  测试此抽象路径名表示的文件或目录是否存在。\nlength()  返回由此抽象路径名表示的文件的长度。\ngetAbsoluteFile()`  返回此抽象路径名的绝对形式。\ngetName()  返回由此抽象路径名表示的文件或目录的名称\ngetParent() 返回此抽象路径名的父null`的路径名字符串，如果此路径名未命名为父目录，则返回null。 \nlistFiles()    返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。\n\npublic static void main(String[] args) &#123;        File f = new File(&quot;E:\\\\demo.txt&quot;);            System.out.println(f.canExecute());            System.out.println(f.canRead());            System.out.println(f.canWrite());            System.out.println(f.isAbsolute());            System.out.println(f.isHidden());            System.out.println(f.isDirectory());            System.out.println(f.isFile());            System.out.println(f.exists());            System.out.println(f.length());//字节单位            long t =  f.lastModified();            System.out.println(DateUtil.dateToString(t));            System.out.println(f.getAbsolutePath());            System.out.println(f.getName());            System.out.println(f.getParent());    &#125;\n\nf3.createNewFile();创建文件夹\nFile f = new File(&quot;E:\\\\demo.txt&quot;)try &#123;            f.createNewFile();//创建        &#125; catch (IOException e) &#123;            e.printStackTrace();            System.out.println(&quot;路径不正确&quot;);        &#125;\n\nfile4.mkdirs();//创建多级File file4 = new File(&quot;E:\\\\lajiii\\\\demo\\\\dsda&quot;);file4.mkdirs();//创建多级\n\nfile4.delete();//f1.delete();//删除文件夹时,文件夹中必须为空只能一级一级进行删除\n\n\n\nFileFilter文件过滤File ff = new File(&quot;F:\\\\Users\\\\LENOVO\\\\Desktop&quot;);File[] fs = ff.listFiles(new MyFileFilter());//获得指定目录下面的文件for (File f0:fs) &#123;System.out.println(f0);&#125;\n\nimport java.io.File;import java.io.FileFilter;public class MyFileFilter implements FileFilter &#123;    @Override    public boolean accept(File pathname) &#123;        return pathname.toString().endsWith(&quot;.md&quot;);//    &#125;&#125;\n\n创建File对象File f1 = new File(&quot;d:/java&quot;);\t\tf1.mkdir(); \t\t\t//创建文件夹\t\t\t\tFile f2 = new File(&quot;d:/java/sub1&quot;);\t\tf2.mkdir();\t\t\t\tFile f3 = new File(&quot;d:/java&quot;, &quot;sub2&quot;);\t\tf3.createNewFile(); \t\t//创建文件\t\t\t\tFile f4 = new File(f2, &quot;sub3&quot;);\t\tf4.createNewFile();\t\t\n\n查看文件的属性File f1 = new File(&quot;hehe.avi&quot;);\t\t//相对路径,要项目目录下的文件\t\tf1.createNewFile();\t\t\t\tSystem.out.println( f1.getAbsolutePath() );\t//返回绝对路径(从根目录开始的路径 )\t\tSystem.out.println( f1.getPath() );\t\t\t//返回路径 \t\tSystem.out.println( f1.getParent() );\t\t//返回上一级文件夹\t\tSystem.out.println( f1.getName() );\t\t\t//对象名\t\tSystem.out.println( f1.length());\t\t\t//文件大小\t\tSystem.out.println( f1.exists() );\t\t\t//是否存在\t\tSystem.out.println( f1.isFile() );\t\t\t//是否为文件\t\tSystem.out.println( f1.isAbsolute() );\t\t//是否绝对路径\t\tSystem.out.println( f1.lastModified() );\t//最后一次修改的时间\n\n列出文件夹的内容public class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\tlistSub3(&quot;D:\\\\course\\\\03-JavaSE\\\\code&quot;);\t&#125;\t//显示指定文件 夹的内容\tpublic static void listSub1(String  dirname) &#123;\t\tFile dir = new File(dirname);\t\t\t\tString[] subs = dir.list();\t\tfor (String string : subs) &#123;\t\t\tSystem.out.println( string );\t\t&#125;\t&#125;\t\t//显示绝对路径 \tprivate static void listSub2(String dirname) &#123;\t\tFile dir = new File(dirname);\t\t\t\tFile[] listFiles = dir.listFiles();\t\tfor (File file : listFiles) &#123;\t\t\tSystem.out.println(file.getAbsolutePath());\t\t&#125;\t&#125;\t\t//显示绝对路径 , 包括子文件夹的内容\tprivate static void listSub3(String dirname) &#123;\t\tFile dir = new File(dirname);\t\t\t\tFile[] listFiles = dir.listFiles();\t\tfor (File file : listFiles) &#123;\t\t\tSystem.out.println(file.getAbsolutePath());\t\t\t//如果file对象是文件夹, 显示该子文件夹的内容\t\t\tif (file.isDirectory()) &#123;\t\t\t\tlistSub3( file.getAbsolutePath() ) ;\t\t\t//递归调用\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n\n\n\n练习File使用File类遍历 例如E:盘下的所有目录和文件\nimport java.io.File;public class One &#123;    public static void main(String[] args) &#123;        File file = new File(&quot;E:\\\\IdeaProjects&quot;);        showDirectory(file);        &#125;    private static void showDirectory(File file) &#123;        //listFiles()    返回一个抽象路径名**数组**，表示由该抽象路径名表示的目录中的文件。        File[] files = file.listFiles();        for(File a:files)&#123;            //getAbsolutePath() 返回此抽象路径名的绝对路径名字符串。             System.out.println(a.getAbsolutePath());            //isDirectory()`  测试此抽象路径名表示的文件是否为目录            if(a.isDirectory())&#123;                showDirectory(a);            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n统计某个目录下(单级)所有以.java结尾的文件数量(不使用过滤器实现)\npublic class Two &#123;    public static void main(String[] args) &#123;        File ff = new File(&quot;E:\\\\IdeaProjects\\\\DateStruct\\\\src\\\\com\\\\nie\\\\LEE&quot;);        File[] fs = ff.listFiles();        int count=javaNum(fs);        System.out.println(count);//        System.out.println();    &#125;    private static int javaNum(File[] fs) &#123;        int a=0;        for (int i = 0; i &lt;fs.length ; i++) &#123;            String str= String.valueOf(fs[i]);            int index=str.lastIndexOf(&quot;.&quot;);            String strJava=str.substring(index+1,str.length());            if (strJava.equals(&quot;java&quot;)) a++;        &#125;        return a;    &#125;&#125;\n\n\n\n\n\n输入及输出的概念输入输出（I/O）\n\n把电脑硬盘上的数据读到程序中,称为输入,既input,进行数据read操作\n从程序往外部设备写数据,成为输出,即output,进行数据的write操作\n\n流是有起点和终点的有序字节序列\n流的分类:输入流/输出流,按照数据的传输方向分为:\n\n输入流:往程序中读叫输入流\n输出流:从程序中往外写叫输出流\n\n所有输入流都是InputStream类或者Reader类的子类。\n\n类名以inputstream结尾的类都是InputStream的子类\n类名以reader结尾的类都是reader类的子类\n\n所有输出流都是OutputStream类或者Writer类的子类。\n\n类名以OutputStream结尾的类都是OutputStream的子类。\n类名以Writer结尾的类都是Writer类的子类。\n\n字节流/字符流字节流:字节位单位处理流的中的数据就是字节流,\n字符流 为单位处理流中的数据就是字符流\nInputStream和OutPutStream的子类都是字节流\n可以读写二进制文件,主要处理音频,图片,歌曲,字节流,处理单元位一个字节\n\nReader和Writer的子类都是字符流\n主要处理字符或者字符串,字符流处理单元为2个字节\n字节流将读取到的字节数据,去指定的编码表中获取对应文字\n\n节点流与处理流根据封装类型不同流又分为      节点流      处理流节点流：             如果流封装的是某种特定的数据源，如文件、字符串、字符串数组等，则称为节点流。处理流。            如果流封装的是其它流对象，称为处理流。      处理流提供了缓冲功能，提高读写效率,同时增加了一些新的方法。\n节点流中常用类\n\n字节输入流 FileInputStream\n字节输出流 FileOutputStream\n字符输入流 FileReader\n字符输出流 FileWriter\n\n处理流中常用类\n\n缓冲字节输出流 BufferedOutputStream\n缓冲字节输入流 BufferedInputStream\n缓冲字符输入流 BufferedReader\n缓冲字符输出流 BufferedWriter\n\n字节流中常用类FileInputStream/FileOutputStream\n字节输入流 FileInputStream\n字节输出流 FileOutputStream\n\n读写文件的步骤public static void main(String[] args) throws IOException &#123;\t//1)在当前程序与指定的文件之间建立流通道\tFileInputStream fis = new FileInputStream(&quot;d:/abc.txt&quot;);\t\t//2) 读写文件内容\tfis.read();\t\t//3)关闭流通道\tfis.close();&#125;\n\n以字节为单位读取文件的内容read()方法从文件中读取一个字节, 并把讲到的字节返回, 讲到文件末尾返回-1//读取d:/abc.txt文件的内容, 通过构造方法指定要访问的文件,如果文件不存在会抛出异常FileInputStream fis = new FileInputStream(&quot;d:/abc.txt&quot;);\n\n以字节为单位读取文件的内容, 循环读取public static void main(String[] args) throws IOException &#123;\t\t//1)在当前程序与指定的文件之间建立流通道,\t\t//读取d:/abc.txt文件的内容, 通过构造方法指定要访问的文件,如果文件不存在会抛出异常\t\tFileInputStream fis = new FileInputStream(&quot;d:/abc.txt&quot;);\t\t//文件内容: ABCabc\t\t\t\t//2) 读取文件内容, \t\t//read()方法从文件中读取一个字节, 并把讲到的字节返回, 讲到文件末尾返回-1\t\tint cc = fis.read();\t\t//65, A的码值\t\twhile( cc != -1 )&#123;\t\t\t//把读到的字节cc进行处理,  把cc转换为字符再打印, 因为当前文件中只有英文字符,一个字节就对应一个字符\t\t\tSystem.out.print(  (char)cc  );\t\t\t//继续读下个字节\t\t\tcc = fis.read( );\t\t&#125;\t\t\t\t\t\t//3)关闭流通道\t\tfis.close();\t&#125;\n\n一次读取一个字节数组,循环读取\n加快读取的的速度\npublic static void main(String[] args) throws IOException &#123;\t\t//1)在程序与读取的文件之间建立流通道\t\tFileInputStream fis = new FileInputStream(&quot;d:/abc.txt&quot;);\t\t//文件ABCabcABC\t\t\t\tbyte[] bytes = new byte[1024];\t\t\t\t//从流中读取很多字节, 保存到字节数组中, 返回读到的字节数,如果读到文件末尾,返回-1\t\tint len = fis.read(bytes);\t\t\t\twhile(  len != -1 )&#123;\t\t\t//从文件中读取了len个字节保存到了bytes数组中, 对len个字节进行处理\t\t\t//把读到的len个字节转换为字符串  new String(byte[]bytes , 0 , len)\t\t\tSystem.out.print( new String(bytes , 0 , len ));\t\t\t//继续读\t\t\tlen = fis.read(bytes);\t\t&#125;\t\t\t\tfis.close();\t&#125;\n\n异常处理一次读取一个字节, 手动关闭流, 异常处理private static void m1() &#123;\t\t\tFileInputStream fis = null;\ttry &#123;\t\tfis = new FileInputStream(&quot;d:/abc.txt&quot;);\t\t\t\tint cc = fis.read();\t\twhile( cc != -1 )&#123;\t\t\tSystem.out.print( (char)cc );\t\t\tcc = fis.read();\t\t&#125;\t&#125; catch (FileNotFoundException e) &#123;\t\te.printStackTrace();\t&#125; catch (IOException e) &#123;\t\te.printStackTrace();\t&#125; finally &#123;\t\tif (fis != null) &#123;\t\t\ttry &#123;\t\t\t\tfis.close();\t//关闭流,释放系统资源\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;  \t\t\t\t\t&#125;\t&#125;\t&#125;\n\n从文件中读取字节保存到字节数组中, 异常处理, 自动 关闭流//从JDK7开始, 流可以自动关闭\tprivate static void m2() &#123;\t\ttry(\t\t//try资源块,自动释放\t\t\t\tFileInputStream fis = new FileInputStream(&quot;d:/abc.txt&quot;);\t\t\t\t) &#123;\t\t\tbyte[] bytes = new byte[4];\t\t\tint len = fis.read(bytes);\t\t\twhile( len != -1)&#123;\t\t\t\tSystem.out.print( new String(bytes , 0 ,len));\t\t\t\tlen = fis.read(bytes);\t\t\t&#125;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\t\t&#125;\n\nFileOutputStream以字节为单位把数据保存到文件中\nbyte[] bytes = “bjpowernode”.getBytes();\nfos.write(bytes);        //把bytes数组中所有的字节保存到文件中\n\npublic static void main(String[] args) throws IOException &#123;    FileReader fr=  new FileReader(&quot;E:\\\\nihao.txt&quot;);    FileWriter fr1=  new FileWriter(&quot;E:\\\\nihao1.txt&quot;,true);    char[] chars=new  char[1024];    int len=fr.read(chars);    while (true)&#123;        if (len==-1) break;        fr1.write(chars,0,len);        len=fr.read(chars);    &#125;    fr.close();    fr1.close();&#125;\n\n文件的复制public static void main(String[] args) throws IOException &#123;        FileInputStream in = new FileInputStream(&quot;F:\\\\Users\\\\LENOVO\\\\Desktop\\\\微机实验一.doc&quot;);        File file = new File(&quot;F:\\\\Users\\\\LENOVO\\\\Desktop\\\\微机实验一.doc&quot;);        FileOutputStream out1 = new FileOutputStream(&quot;E:\\\\草稿1.doc&quot;);        FileOutputStream out2 = new FileOutputStream(&quot;E:\\\\草稿2.doc&quot;);        /*        in.read() 每次一个字节 读取完毕返回-1        in.read(byte[] b) 返回的是数组中实际装的字节数量         */        System.out.println(&quot;文件大小\\t&quot;+file.length());        Date date = new Date();        System.out.println(&quot;第一次测试&quot;);        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss:sss&quot;);        System.out.println(sdf.format(date));        int a = in.read();        while (a != -1) &#123;            out1.write(a);            a = in.read();        &#125;        Date date2 = new Date();        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss:sss&quot;);        System.out.println(sdf2.format(date2));        System.out.println(&quot;========================&quot;);        Date date3 = new Date();        System.out.println(&quot;第二次测试&quot;);        SimpleDateFormat sdf3 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss:sss&quot;);        System.out.println(sdf3.format(date3));        byte[] b = new byte[1024];        int len = in.read(b);        while (len != -1) &#123;            out2.write(b);            len = in.read(b);        &#125;                Date date4 = new Date();        SimpleDateFormat sdf4 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss:sss&quot;);        System.out.println(sdf4.format(date4));       /* while (true) &#123;            if (len == -1) break;            len = in.read(b);            out.write(b, 0, 3);        &#125;*/    &#125;\n\n字符FileReader/FileWriter 以字符为单位读写文件内容, 只能读写纯文本文件, 要求文本文件的编码格式要与当前环境的编码格式兼容\nFileReader建立流通道new FileReaderFileReader fr  = new FileReader(&quot;d:/abc.txt&quot;);//abc.txt虽然是GBK编码, 当前环境是UTF8编码, abc.txt文件中都是英文字符, 英文字符不管是GBK还是UTF8编码都是一个字节//如果文件是GBK格式, 文件中有中文, 读取时会出现乱码\t\t//一般使用FileReader读取与当前环境编码一致的文件\n\nprivate static void m1() throws IOException &#123;    FileReader fr  = new FileReader(&quot;d:/Test08.java&quot;);        //read()一次读取一个字符, 返回字符的码值,读到文件末尾返回-1        int cc = fr.read();        while( cc != -1 )&#123;        //把读到的字符打印到屏幕上        System.out.print(  (char)cc );        cc = fr.read();    &#125;    fr.close();&#125;\n\n\n\n\n\n读取文本文件内容,一次读取一个字符数组, 异常处理, 自动关闭private static void m2() &#123;\t\ttry (\t\t\t\tFileReader fr = new FileReader(&quot;d:/test08.java&quot;);\t\t\t\t)&#123;\t\t\tchar [] contents = new char[1024];\t\t\tint len = fr.read(contents);\t\t\twhile( len != -1 )&#123;\t\t\t\t//把读到的len个字符进行处理,  转换为字符串打印\t\t\t\tSystem.out.print( new  String(contents , 0 , len) );\t\t\t\tlen = fr.read(contents);\t\t\t&#125;\t\t\t\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\n\nFileWriter//文件不存在就创建, 文件已存在,以追加的方式打开fw = new FileWriter(“d:/xyz.txt”, true);\npublic static void main(String[] args) &#123;        //字符流 每次直接读取一个字符,底层有一个转换流        //字符流只能读纯文本文件        FileReader reader = null;        FileWriter writer = null;        try &#123;            reader = new FileReader(&quot;E:\\\\nihao.txt&quot;);            writer = new FileWriter(&quot;E:\\\\b.txt&quot;, true);//        System.out.println((char) reader.read());//        System.out.println(reader.read());//        System.out.println(reader.read());//        System.out.println(reader.read());            int c = reader.read();            System.out.println((char) c);            while (true) &#123;                if (c == -1) break;                System.out.print((char) c);                writer.write(c);                c = reader.read();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        try &#123;            reader.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        try &#123;            writer.close();//必须关闭对应的流才能显示        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;////        //字符流 每次直接读取一个字符,底层有一个转换流//        //字符流只能读纯文本文件//        FileReader reader = new FileReader(&quot;E:\\\\nihao.txt&quot;);//        FileWriter writer = new FileWriter(&quot;E:\\\\b.txt&quot;);////        System.out.println((char) reader.read());////        System.out.println(reader.read());////        System.out.println(reader.read());////        System.out.println(reader.read());//       int  c=reader.read();//        System.out.println((char)c);//        while (true)&#123;//            if (c==-1) break;//            System.out.print((char)c);//            writer.write(c);//            c=reader.read();////        &#125;//        reader.close();//        writer.close();//必须关闭对应的流才能显示////    &#125;&#125;\n\n文本文件的复制\n 一次复制一个字符, 异常处理, 自动关闭流\n一次复制一个字符数组, 异常处理, 手动关闭流\nInputStreamReader/OutputStreamWriter转换流读写FileReader/FileWriter只能读写与当前环境编码兼容的文本文件\n如果文本文件与当前环境编码不兼容, 使用InputStreamReader/OutputStreamWriter转换流读写\n转换流采用了适配器设计模式\n当操作的文件编码与当前环境编码不兼容, 使用OutputStreamWriter把字符以指定的编码转换为字节\nOutputStream out = new FileOutputStream(&quot;d:/def.txt&quot;, true );\t\tOutputStreamWriter osw = new OutputStreamWriter(out, &quot;GBK&quot;);//在当前程序与指定的文件之间建立字节流通道\tInputStream in = new FileInputStream(&quot;d:/def.txt&quot;);\t//使用GBK编码,把in字节流中的数据转换为字符流\tInputStreamReader isr = new InputStreamReader(in, &quot;GBK&quot;);\n\n\n\n\n\n\n\n//当操作的文件编码与当前环境编码不兼容, 使用OutputStreamWriter把字符以指定的编码转换为字节private static void m2() throws IOException &#123;\t//把字符保存到d:/def.txt文件, 该文件是GBK编码, 当前环境是UTF8编码, 把字符转换为GBK格式再保存\tOutputStream out = new FileOutputStream(&quot;d:/def.txt&quot;, true );\tOutputStreamWriter osw = new OutputStreamWriter(out, &quot;GBK&quot;);\t\tosw.write(&quot;\\r\\n&quot;);\tosw.write(&quot;当前的内容是使用转换流保存到文件中的, 工作区编码是UTF8, 该文件使用GBK编码 &quot;);\t\tosw.close();&#125;\n\n当文本文件的编码与当前环境编码不兼容时, 使用InputStreamReader类读取\nprivate static void m1() throws IOException &#123;\t//读取d:/def.txt文件, 该文件使用GBK编码,当前环境使用UTF8编码\t//在当前程序与指定的文件之间建立字节流通道\tInputStream in = new FileInputStream(&quot;d:/def.txt&quot;);\t//使用GBK编码,把in字节流中的数据转换为字符流\tInputStreamReader isr = new InputStreamReader(in, &quot;GBK&quot;);\t\tint cc = isr.read();\twhile( cc != -1)&#123;\t\tSystem.out.print((char)cc);\t\tcc = isr.read();\t&#125;\t\tisr.close();&#125;\n\n\n\n字符缓冲流\nBufferedReader/BufferedWriter\n也是一种处理流,包装流\n\n\n​    bw.flush();             //清空缓冲区,把数据保存到文件中​    bw.close();\nbr.readLine();从缓冲字符流中读取一行,读到文件末尾返回null\n\n\n从键盘上输入文本,把这些文本保存到文件中\tprivate static void m3() throws IOException &#123;\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(&quot;d:/xyz.txt&quot;));\t\t//使用BufferedReader对键盘输入流缓冲//\t\tSystem.in是标准的输入设备,即键盘\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tString line = br.readLine();\t\twhile( line.length() &gt; 0 )&#123;\t\t\tbw.write(line);\t\t\tbw.newLine();\t\t\tline = br.readLine();\t\t&#125;\t\t\tbr.close();\t\tbw.close();\t&#125;\n\n使用BufferedWriter保存文本到文件\tprivate static void m2() throws IOException &#123;\t\tWriter out = new FileWriter(&quot;d:/abc.txt&quot;, true \t);\t\tBufferedWriter bw = new BufferedWriter(out);\t\t\t\tbw.write(&quot;我送你99朵玫瑰花儿&quot;);\t\t//\t\tbw.flush(); \t\t\t//清空缓冲区,把数据保存到文件中\t\tbw.close();\t&#125;\n\n\n\n\n\n使用BufferedReader读取文本文件内容private static void m1() throws IOException &#123;\tReader in = new FileReader(&quot;d:/test08.java&quot;);\tBufferedReader br = new BufferedReader(in);\t\t//从缓冲字符流中读取一行,读到文件末尾返回null\tString line = br.readLine();\twhile( line != null )&#123;\t\tSystem.out.println( line  );\t\tline = br.readLine();\t&#125;\t\tbr.close(); \t\t//把包装流关闭后, 被包装的流也会关闭&#125;\n\n\n\n\n\n\n\nPrint流\nprint打印流:只做输出没有输入\n\n打印分为字节打印流和字符打印流\n\n\nPrintWriter: 字符打印流\nprint流\n方法可以打印各种类型数据\n单向输出(从服务器,向客户端,浏览器打印输出网页内容)\n在开发时, 一般调用e.printStackTrace()把异常信息打印到屏幕上方便程序员调试在部署后, 会把异常信息打印到日志文件中\n\npublic static void main(String[] args) throws FileNotFoundException &#123;       /*       print  打印流 :  只做输出没有输入       分为字节和字符打印流       printWriter: 字符打印流       print 方法可以打印各种类型数据       print流 单向输出(从服务器 向客户端 浏览器打印输出网页内容)        */       PrintWriter out = new PrintWriter(&quot;E:\\\\22.html&quot;);       out.print(&quot;&lt;b&gt;sfdsdfdfsdfs&lt;/b&gt;&quot;);       out.print(&quot;&lt;b&gt;sfdsdfdfsdfs&lt;/b&gt;&quot;);       out.println(&quot;&lt;b&gt;sfdsdfdfsdfs&lt;/b&gt;&quot;);       out.println(&quot;&lt;b&gt;sfdsdfdfsdfs&lt;/b&gt;&quot;);       out.close();   &#125;\n\n\n\n对象输入输出流作用:\n主要作用时用于写入对象信息和读取对象信息,对象信息一旦写入文件上那么对象的信息就可以做持久化\n\n对象的输出流:    ObjectOutputStream\n\nwriteObject()方法可以直接将对象保存到输出流中\n\n对象的输入流:     ObjectInputStream\n\nreadObject()方法可以直接读取一个对象，\n\n用法:要将序列化之后的对象保存下来,\n通过对象的输出流**(ObjectOutputStream)**将对象状态保存,writeObject()方法可以直接将对象保存到输出流中。\n在通过对象输入流**(ObjectInputStream)**将对象状态恢复,readObject()方法可以直接读取一个对象，\n在恢复的时候注意类型的转换\n案例一:对象的输出流\n对象的输出流输出对象信息到指定文件,长久保存,这个过程称为对象的序列化\n\n\n\n/*对象的输入输出流,主要是用于写入对象信息与读取对象信息 */public class ObjectoutputDemo &#123;    //使用对象    public static void main(String[] args) throws IOException &#123;        //对象的输出流, writeObject()方法可以直接将对象保存到输出流中        //输出对象信息到指定文件,长久保存,这个过程称为对象的序列化        FileOutputStream out = new FileOutputStream(&quot;E:\\\\temp.obj&quot;);        ObjectOutputStream object = new ObjectOutputStream(out);        Date date = new Date();        String str = &quot;abc&quot;;        object.writeObject(date);        object.writeObject(str);    &#125;&#125;\n\n得到对应的序列号\n\n对象输入流\n对象输入流使用对象输入流,将文件中序列化的对象信息,读取成对象的过程称为 对象反序列化\n\npublic class ObjectInputDemo &#123;    //使用对象输入流,将文件中序列化的对象信息,读取成对象的过程称为 对象反序列化    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        FileInputStream input = new FileInputStream(&quot;E:\\\\temp.obj&quot;);        ObjectInputStream oblin = new ObjectInputStream(input);        Date date = (Date) oblin.readObject();        String str = (String) oblin.readObject();        System.out.println(date);        oblin.close();    &#125;&#125;\n\n\n\n\n对象序列化\n对象的寿命通常随着生成发该对象的程序的终止而终止\n需要将对象的状态保存下来,在需要时再将对象恢复\n\n对象的输出流将指定的对象写入到文件的过程,就是将对象序列化的过程\n既然对象的输出流将对象写入到文件中称之为对象的序列化，所以必须要实现Serializable接口。\n\n对象的输入流将指定序列化好的文件读出程序,就是对象反序列化的过程\n\n\nSerializable接口中没有任何办法.当一个类声明实现Serializable接口后,表明该类可被序列化\n在类中可以生成一个编号   随机生成 唯一的      private static final long serialVersionUID = -5974713180104013488L; \n serialVersionUID 用来表明实现序列化类的不同版本间的兼容性。某个类在与之对应的对象已经序列化出去后做了修改，该对象依然可以被正确反序列化\n案例二一个类声明package com.nie.javaIo.day3;import java.io.Serializable;public class User implements Serializable &#123;    /*    实现序列化类,必须实现Serializable接口    如果接口 不显示生产的序列版本id号  会自动生成,但是类的信息一旦改变,序列化的id也会随之改变    也可以显示的声明创建id号 [需配置]     */    private static final long serialVersionUID = 3961552986076715728L;    private  String name;    private  String pass;    public User(String name, String pass) &#123;        this.name = name;        this.pass = pass;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, pass=&#x27;&quot; + pass + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n\n\n对象的输出流public class ObjectoutputDemo &#123;    //使用对象    public static void main(String[] args) throws IOException &#123;        //对象的输出流, writeObject()方法可以直接将对象保存到输出流中        //输出对象信息到指定文件,长久保存,这个过程称为对象的序列化        FileOutputStream out = new FileOutputStream(&quot;E:\\\\temp.obj&quot;);        ObjectOutputStream object = new ObjectOutputStream(out);        Date date = new Date();        String str = &quot;abc&quot;;        User user=new User(&quot;你好&quot;,&quot;123123&quot;);        object.writeObject(user);        object.writeObject(date);        object.writeObject(str);        object.close();    &#125;&#125;\n\n对象的输入流public class ObjectInputDemo &#123;    //使用对象输入流,将文件中序列化的对象信息,读取成对象的过程称为 对象反序列化    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        FileInputStream input = new FileInputStream(&quot;E:\\\\temp.obj&quot;);        ObjectInputStream oblin = new ObjectInputStream(input);//        Date date = (Date) oblin.readObject();//        String str = (String) oblin.readObject();//        System.out.println(date);        User Students1=( User)oblin.readObject();        System.out.println(Students1);        oblin.close();    &#125;&#125;\n\n\n\ntemp.obj:\n \u0005sr \u0018com.nie.javaIo.day3.User6鶦s濤毿\u0002 \u0002L \u0004namet \u0012Ljava&#x2F;lang&#x2F;String;L \u0004passq ~ \u0001xpt \u0006浣犲ソt \u0006123123sr \u000ejava.util.Datehj?KYt\u0019\u0003  xpw\b  \u0001v2墆\u0005xt \u0003abc\n\n\n\n输出:\nUser&#123;name=&#x27;你好&#x27;, pass=&#x27;123123&#x27;&#125;\n\n","categories":["-javase"],"tags":["基础","IO"]},{"title":"十大排序07基数排序","url":"http://example.com/2020/12/02/十大排序07基数排序/","content":"基数排序基数排序基本思想基数排序是使用空间换时间的经典算法\n\n\n基数排序属于”分配式排序”,又称“桶子法” （bucket sort）   ,他是通过各个位的值,将排序的元素分配至某些”桶”中,达到排序的作用\n基数排序法是属于稳定性的排序,基数排序法的是效率高的稳定性排序法\n基数排序法是桶排序的发展\n基数排序是1887赫尔曼· 何乐礼发明的。 ,他是实现的将整数位数切割成不同的数字,然后按每个位数分别比较\n\n\n\n基数排序基本思想将所有待比较数值统一为长度,数位短的数前补零,然后,从最低位开始,依次进行排序,这样由最低为一直排到最高位完成后,数列就变成了一个有序序列\n基数排序图文说明\n\npackage com.nie.sort;import java.util.Arrays;public class radixSort &#123;    public static void main(String[] args) &#123;        int arr[] = &#123;53, 3, 542, 748, 14, 214&#125;;        radixSort(arr);        System.out.println(Arrays.toString(arr));    &#125;    public static void radixSort(int[] arr) &#123;        //得到数组最大的位数        int max = arr[0];        for (int i = 0; i &lt; arr.length; i++) &#123;            if (arr[i] &gt; max) &#123;                max = arr[i];            &#125;        &#125;        int maxLength = (max + &quot;&quot;).length();        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组        /*        说明        1.二维数组包含10个一维数组        2.为了防止在放入数的时候,数据溢出,则每个一维数组(桶) 大小定位arr.length        3.名明确，基数排序是使用空间换时间的经典算法         */        int[][] bucket = new int[10][arr.length];        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数        int[] bucketElementCounts = new int[10];        //(针对每个元素进行对应的排序处理)        for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123;            for (int j = 0; j &lt; arr.length; j++) &#123;                //取出每个元素的对应位的值                int digitOfElement = arr[j] / n % 10;                //放入对应的桶中                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];                bucketElementCounts[digitOfElement]++;            &#125;            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)            int index = 0;            for (int j = 0; j &lt; bucketElementCounts.length; j++) &#123;                //如果桶中，有数据，我们才放入到原数组                if (bucketElementCounts[j] != 0) &#123;                    //循环该桶即第k个桶(即第k个一维数组), 放入                    for (int k = 0; k &lt; bucketElementCounts[j]; k++) &#123;                        //取出元素放入到arr                        arr[index++] = bucket[j][k];                    &#125;                &#125;                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！                bucketElementCounts[j] = 0;            &#125;        &#125;    &#125;&#125;\n\ndsa\n\n总结:平均时间复杂度O(n*k)\n最好情况 O(n*k)\n最坏情况 O(n*k)\n空间复杂度 O(n+k)\n排序方式 out-place\n稳定性 不稳定\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"十大排序06归并","url":"http://example.com/2020/11/30/十大排序06归并/","content":"归并排序归并排序,利用归并的思想实现排序,该方法才采用经典的分治策略,成一些小的问题然后递归求解，   而治的阶段则将分的阶段得到各答案”修补”在一起即分而治之  \n归并排序思想示意图 1-基本思想:\n\n归并排序思想示意图 2-合并相邻有序子序列:\n\n取中间的值作为基准,两边的进行合并.类似于链表合并\n\npackage com.nie.sort;import java.util.Arrays;/*归并排序 */public class MergetSort &#123;    public static void main(String[] args) &#123;        int arr[] = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;;        int temp[] = new int[arr.length];        mergeSort(arr, 0, arr.length - 1, temp);        System.out.println(Arrays.toString(arr));    &#125;    //分+合    public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;        if (left &lt; right) &#123;            //中间索引            int mid = (left + right) / 2;            //向左递归进行分解            mergeSort(arr, left, mid, temp);            //向右递归进行分解            mergeSort(arr, mid + 1, right, temp);            //合并            merge(arr, left, mid, right, temp);        &#125;    &#125;    /**     * @param arr   排序的原始数组     * @param left  左边有序序列的初始索引     * @param mid   中间索引     * @param right 右边索引     * @param temp  作为中转的数组     */    public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;        int i = left;        int j = mid + 1;        int t = 0;        //(一)        //先把左右两边(有序)的数据按照规则填充到temp数组        //直到左右两边的有序序列，有一边处理完毕为止        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素            //即将左边的当前元素，填充到 temp数组            //然后 t++, i++            if (arr[i] &lt;= arr[j]) &#123;                temp[t] = arr[i];                t++;                i++;            &#125; else &#123;//反之,将右边有序序列的当前元素，填充到temp数组                temp[t] = arr[j];                t++;                j++;            &#125;        &#125;        //(二)        //把有剩余数据的一边的数据依次全部填充到temp        while (i &lt;= mid) &#123;//左边的有序序列还有剩余的元素，就全部填充到temp            temp[t] = arr[i];            t += 1;            i += 1;        &#125;        while (j &lt;= right) &#123;//右边的有序序列还有剩余的元素，就全部填充到temp            temp[t] = arr[j];            t += 1;            j += 1;        &#125;        //(三)        //将temp数组的元素拷贝到arr        //注意，并不是每次都拷贝所有        t = 0;        int tempLeft = left;        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3        //最后一次 tempLeft = 0  right = 7        while (tempLeft &lt;= right) &#123;            arr[tempLeft] = temp[t];            t += 1;            tempLeft++;        &#125;    &#125;&#125;\n\nhh\n\n总结:平均时间复杂度O(nlogn)\n最好情况 O(nlog n)\n最坏情况 O(nlog n)\n空间复杂度 O(n)\n排序方式 out-place\n稳定性 稳定\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"javaSE-20-Collection集合概述","url":"http://example.com/2020/11/28/javaSE20/","content":"Collection集合概述最强Java集合合集\n集合是用来储存引用类型数据的容器\n集合分为两类:\n\nCollection集合: 存取数据时是单个存取,\nMap集合: 是按&lt;键,值&gt;对的形式存取数据, &lt;”lisi”,18&gt;  &lt;”feifei”, 28&gt;\n\n最强Java集合合集\n  \n\n\nCollection的常用操作\n\n\nadd(E e) 向集合中添加元素e\n\n\n\naddAll(Collection&lt;? extends E&gt; c) 把集合c中的元素都添加到当前集合中\n\n\nclear() 清空集合,删除集合中所有的元素.\n\n\ncontains(Object o) 判断集合是否包含指定元素o\n\n\ncontainsAll(Collection&lt;?&gt; c) 判断当前集合是否包含指定c集合中的所有元素\n\n\nequals(Object o)\n\n\nhashCode()\n\n\nisEmpty() 判断集合是否为空.\n\n\niterator() 返回集合的迭代器对象.\n\n\nremove(Object o) 在集合中删除第一个与o匹配的元素\n\n\nremoveAll(Collection&lt;?&gt; c) 把当前集合中出现在c集合里的元素都删除\n\n\nretainAll(Collection&lt;?&gt; c) 删除当前集合中的元素,如果该元素在c集合中存在就保留\n\n\nsize() 返回元素的个数.\n\n\ntoArray() 把集合转换为数组.\n\n\ntoArray(T[] a)\n\n\nList集合list特点:有序,可重复\nList集合为每个元素指定了一个索引值,主要增加了针对索引值的操作\nArrayList与Vector\n底层都是数组, Vector是线程安全的, Arraylist不是线程安全的\n初始化容量: 10 \nArrayList扩容: 1.5 倍速,  Vector扩容: 2倍\n\nLinkedList增加了针对头与尾的操作\n\n\n\nvoid\naddFirst(E e)把元素e添加到列表的头部\n\n\n\nvoid\naddLast(E e) 把元素e添加到最后\n\n\nE\ngetFirst() 返回第一个元素\n\n\nE\ngetLast() 返回最后一个元素\n\n\nE\nremoveFirst() 删除第一个元素\n\n\nE\nremoveLast() 删除最后一个元素\n\n\nE\npeek() 返回第一个元素\n\n\n有时, 使用LinkedList模拟栈, 栈的特点:后进先出\n\n\n\nvoid\npush(E e) 模拟压栈, 把元素e添加列表的头部\n\n\n\nE\npop() 模拟出栈, 把列表的第一个元素删除\n\n\n使用offer(e), poll()模拟队列, 队列特点: 先进先出,    \n\n\n\nboolean\noffer(E e) 模拟入队, 把元素e添加到列表的尾部\n\n\n\nE\npoll() 模拟出队, 把列表的第一个元素删除\n\n\nfor循环进行遍历\n\n增删后   集合长度发生变化   i–   一种向后增长,,,索引和长度不匹配\n\nfor (int i = 0; i &lt; list1.size(); i++) &#123;          list1.remove(i);      &#125;      System.out.println(list1);\n\n\n\n增强for循环\n\n增强for循环,不允许遍历时堆元素进行操作\n如果进行操作(删除),会 报错ConcurrentModificationException\n如果执意删除的话  操作依次后    就必须的终止break;否则会抛出异常\n\nfor (Object obj:list1)&#123;    System.out.println(obj);    if (obj.equals(&quot;a&quot;))&#123;    list1.remove(obj);&#125;\n\niterator\n\nhasnext()检测迭代器中是否有元素\nnext() 返回元素,并向后遍历\n在进行迭代器中必须使用迭代器的方法       进行移除,增加等操作,\n\nIterator it = list1.iterator();//hasnext()检测迭代器中是否有元素while (it.hasNext()) &#123;    Object obj = it.next();    if (&quot;a&quot;.equals(obj)) &#123;        it.remove();    &#125;&#125;System.out.println(list1);\n\n\n\n泛型\n\n泛指一种类型,类型不确定,可以以参数的形式进行传递\n必须是 引用数据类型,可以有多个\n如果没有给有给具体的类型,默认为object\n\n如果使用object作为类型,可以使用任何数据类型具体操作的时候需要向下转型..类型不匹配\n\npublic class TypeDemo &#123;    /*    如果使用object作为类型,可以使用任何数据类型     */    public static void main(String[] args) &#123;        ArrayList arrayList = new ArrayList();        arrayList.add(&quot;adasd&quot;);        arrayList.add(0);        arrayList.add(true);        for (Object obj : arrayList) &#123;            //具体操作的时候需要向下转型..类型不匹配            if (obj instanceof Iterator) &#123;                String str = (String) obj;            &#125;        &#125;        Iterator iterator1 = arrayList.iterator();    &#125;&#125;\n\npublic class TypeDemo01&lt;A&gt; &#123;    A ob;    void test(A ob) &#123;        return;    &#125;    /*    如果使用object作为类型,可以使用任何数据类型     */    public static void main(String[] args) &#123;        TypeDemo01&lt;String&gt; typeDemo01 = new TypeDemo01&lt;&gt;();        typeDemo01.test(&quot;a&quot;);        typeDemo01.test(&quot;a&quot;);//        typeDemo01.test(12);        //前面写 必须写 string    后面的没必要写        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();    &#125;&#125;\n\nsetset接口特点,  无序,不重复\nhashset 无序(不是按照添加顺序排列,按照hash进行排列)\ntreeset 有序  按照元素进行排序\nHashSet位置为什么时无序的添加时根据内容的hash值,在经过hash函数经过计算得到函数计算 得到在hash表中的储存位置\nHashSet&lt;String&gt; set = new HashSet&lt;&gt;();    set.add(&quot;ads&quot;);//字符串 已经重写hashcode    set.add(&quot;通话&quot;);    set.add(&quot;ads&quot;);    set.add(&quot;重地&quot;);    set.add(&quot;ads&quot;);    set.add(&quot;123&quot;);    System.out.println(set);\n\n\n\n//如果类中没有从写hashcode()   那么会调用object 类中的hashcode()不会重复  算出对象的值\n为什么使用 hashcodehashCode 存在的第一重要的原因就是在 HashMap(HashSet 其实就是HashMap) 中使用（其实Object 类的 hashCode 方法注释已经说明了 ），我知道，HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）。\n向hashset添加元素时 如何确定重复元素底层双保险,既要提高效率,又要安全可靠首先会获得添加类容的hash值,判断hash值在集合中是否存在但是内容不相同时,hash值可能会相同,,也就不可靠在hash值相同时,会调用equal方法,比较内容是否相等\n\n\n重写object类中的hashcode()  来自己根据对象中包含的内容计算hash值\n效率高,会出现重复\n\n当hash值出现重复 叫用equal  进行内容判断        \n效率低,  安全\n\n\n@Override public boolean equals(Object o) &#123;     if (this == o) return true;     if (o == null || getClass() != o.getClass()) return false;     Student student = (Student) o;     return num == student.num &amp;&amp;             Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123;     return Objects.hash(num, name); &#125;\n\nTreeSet不可以存储重复元素  自平衡 有序的\n有序(按照类容的自然排序)      数据类型 必须实现Comparable接口 重写compareTo()\n底层使用的是红黑树\n判断重复 向TreeSet中添加元素时调用compareTo()比较大小,  小于0   等于0(重复) 大于0\n自然排序要进行一下操作：Compara1.Student类中实现 Comparable接口2.重写Comparable接口中的Compareto方法          \npublic class Student implements Comparable&lt;Student&gt;&#123;\t    private int num;    private String name;\tpublic Student(int num, String name) &#123;\t\tsuper();\t\tthis.num = num;\t\tthis.name = name;\t&#125;/*\t *  TreeSet添加元素时调用 排序用  比较大小\t */\t@Override\tpublic int compareTo(Student o) &#123;\t\t \t\treturn this.num-o.num;//用哪个属性比较,哪个属性不能重复\t&#125;\t..................\n\n比较器排序1.单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口2.重写Comparator接口中的Compare方法\ncompare(T o1,T o2)      比较用来排序的两个参数。\n\n3.在主类中使用下面的 构造方法\nTreeSet(Comparator&lt;? superE&gt; comparator)          构造一个新的空 TreeSet，它根据指定比较器进行排序。\n\n测试类:\npackage nie.java.collection.day3L;import java.util.TreeSet;public class HashsetDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        //TreeSet(Comparator&lt;? super E&gt; comparator)         // 构造一个新的空 TreeSet，它根据指定比较器进行排序。        TreeSet&lt;Student&gt; ste = new TreeSet&lt;&gt;(new MyComparator());        Student s1 = new Student(1, &quot;jjj&quot;);        Student s2 = new Student(1, &quot;jjj&quot;);        Student s3 = new Student(2, &quot;jj11&quot;);        Student s4 = new Student(3, &quot;j23j&quot;);        Student s5 = new Student(4, &quot;jj123&quot;);        ste.add(s1);        ste.add(s2);        ste.add(s3);        ste.add(s4);        ste.add(s5);        System.out.println(ste);    &#125;&#125;\n\nStudent.java:\npackage nie.java.collection.day3L;import java.util.Objects;public class Student &#123;    private  int num;    private  String nume;    public Student(int num, String nume) &#123;        this.num = num;        this.nume = nume;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;num=&quot; + num +                &quot;, nume=&#x27;&quot; + nume + &#x27;\\&#x27;&#x27; +                &quot;\\n&quot;+&#x27;&#125;&#x27;;    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(num, nume);    &#125;    public int getNum() &#123;        return num;    &#125;    public void setNum(int num) &#123;        this.num = num;    &#125;    public String getNume() &#123;        return nume;    &#125;    public void setNume(String nume) &#123;        this.nume = nume;    &#125;&#125;\n\nMyComparator类：\n注意为:Comparator\npackage nie.java.collection.day3L;import java.util.Comparator;public class MyComparator implements  Comparator&lt;Student&gt; &#123;    @Override    public int compare(Student o1, Student o2) &#123;        return o1.getNume().compareTo(o2.getNume());    &#125;&#125;\n\n允许结果\n[Student&#123;num=3, nume=&#x27;j23j&#x27;&#125;, Student&#123;num=2, nume=&#x27;jj11&#x27;&#125;, Student&#123;num=4, nume=&#x27;jj123&#x27;&#125;, Student&#123;num=1, nume=&#x27;jjj&#x27;&#125;]\n\nLinkedHashSet按插入的顺序进行输LinkedHashSet&lt;Dog&gt; dset = new LinkedHashSet&lt;Dog&gt;();dset.add(new Dog(2));dset.add(new Dog(1));dset.add(new Dog(3));dset.add(new Dog(5));dset.add(new Dog(4));Iterator&lt;Dog&gt; iterator = dset.iterator();while (iterator.hasNext()) &#123;    System.out.print(iterator.next() + &quot; &quot;);&#125;\n\n按插入的顺序进行输出：\n2 1 3 5 4 \n\n\n\nMap双列存储  键-值键不重复,值可以重复\nhashMaptreeMaphashTable\n\nhashMap特点键去重复 hashcode()方法和equals();如果键重复,值覆盖以前的允许一个键可以为空,\n基本操作\n\n\nclear() 清除所有的&lt;键,值&gt;对.\n\n\n\ncontainsKey(Object key) 判断是否包含指定的键.\n\n\ncontainsValue(Object value) 判断是否包含指定的值\n\n\nentrySet() 返回Entry的集合, 一个&lt;键,值&gt;对就是一个Entry\n\n\nequals(Object o).\n\n\nget(Object key) 返回key对应的值\n\n\nisEmpty() 判断 是否为空.\n\n\nkeySet() 返回键的集合\n\n\nput(K key, V value) 向Map中添加&lt;key,value&gt;对, 如果键key已存在, 使用value值替换原来的值, Map中的键是不重复的\n\n\nputAll(Map&lt;? extends K,? extends V&gt; m)\n\n\nremove(Object key) 只要key匹配就删除对应的&lt;键,值&gt;对\n\n\nremove(Object key, Object value)要求&lt;key,value&gt;都匹配才会删除\n\n\nreplace(K key, V value) 替换\n\n\nreplace(K key, V oldValue, V newValue)\n\n\nsize() 返回&lt;键,值&gt;对的数量.\n\n\nvalues() 返回值的集合\n\n\nhashmap工作原理\nhashmap的底层时哈希表(散列表),哈希表即使一个数组,数组的每一个元素是一个单向链表;在put(k,v)添加键值对,先根据键的hashCode计算数组的索引值(下标),访问数组元素,如果该元素为null,创建一个新的节点保存到数组元素中,如果数组元素部位null,遍历单向链表的各个节点,如果有某个节点的key与当前的键equles相等,就使用新的值V替换结点原来的value值,如果整个链表中所有结点都不匹配,就创建一个新的结点插入到链表的头部.\n遍历一:Set&lt;String&gt; key = map.keySet();    for (String key1 : key) &#123;        System.out.println(key1 + &quot;====&quot; + map.get(key1));    &#125;\n\n\n\n遍历三:取键值对\nSet&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();     for (Map.Entry&lt;String, String&gt; entrie : entries) &#123;         System.out.println(entrie);     &#125;\n\nHashTable:hashtable:\n\n底层都是hash表(散列表),但是hashtable是线程安全的,hashmap不是线程安全\nhashmap的父类是Abstractmap,HashTable的父类是Dictionary\nhashmap默认的初始化容量:16, hashtable默认初始化容量为:11;\n加载因子: 0.75   当&lt;键,值&gt;对的数量  大于  数组的容量(哈希桶的容量) * 加载因子时 , 数组要扩容\nhashmap扩容默认:2倍大小,  hashtale 扩容:2倍加一\nhashmap的键与值都可以为null; HashTable的键与值都不能为null\nhashmap子啊创建时,可以指向一个初始化容量,系统会调整为2次幂,为了快速的计算出数组的下标\nHashTable也可以指定初始化容量, 系统不调整\n\nProperties\nproperties继承了hashtable,  键与值都是string\n经常用于设置/读取系统属性,setPropertty(属性名,属性值),getProperty(属性名)\n使用Properties读取配置文件\n\nTreeMaptreeMap实现了SortedMap,可以根据键自然排序,排序的原理是二叉树原理\n\nTreeMap的键必须是可比较的\n\n​    指定Comparator比较器\n​    如果没有Comparator比较器, 元素的类实现Comparable接口\n","categories":["-javase"],"tags":["基础","java","集合"]},{"title":"java常用字符转换","url":"http://example.com/2020/11/28/java常用字符转换/","content":"常用的字符转换\n\nint–&gt;Stringint num = 123;String str = &quot;&quot; + num;//字符串与基本类型连接,会先把基本类型转换为字符串再连接String str1 = String.valueOf(num);//参数的字符串表示形式。String str2 = Integer.toString(num);//返回一个表示指定整数的 String 对象。\n\n\n\n  \n\nInteger –&gt;StringInteger integer = new Integer(123);String str3 = Integer.toString(integer);String str4 = integer.toString();System.out.println(str3);System.out.println(str4);\n\n\n\nint –&gt;Integerint i1 = 300;                    //自动装箱      i1 = Integer.valueOf(num);\n\n\n\nString –&gt; IntegerString text = &quot;1231&quot;;      i1 = Integer.valueOf(text);\n\n\n\nString –&gt;intnum = Integer.parseInt(text);\n\n\n\nInteger–&gt;intnum = i1;                //自动拆箱String str5 = &quot;abcdefg&quot;;char[] chars = str5.toCharArray();//字符串转换成为字符数组\n\n符数组–&gt;字符串   String.valueOf(chars);把字符串 转为 字符数组  char[] toCharArray () ;把字符数组 转为 字符串 static String valueOf ( char[] chs)String.valueOf(chars);&#x2F;&#x2F;符数组--&gt;字符串char[] toCharArray () &#x2F;&#x2F;把字符串 转为 字符数组static String valueOf ( char[] chs)&#x2F;&#x2F;&#x2F;把字符数组 转为 字符串\n\n\n\n可以把字符串转换为基本类型数据// 可以把字符串转换为基本类型数据int num = Integer.parseInt(&quot;789&quot;);dd = Double.parseDouble(&quot;45.78&quot;);\n\n\n\n//把基本类型/字符串转换为包装类对象i1 = Integer.valueOf(369);     i2 = Integer.valueOf(&quot;258&quot;);            Integer i1 = new Integer(123);     Integer i2 = new Integer(&quot;456&quot;);\n\nbyte bb = i1.byteValue();double dd = i2.doubleValue();","categories":["-javase"],"tags":["基础","java"]},{"title":"十大排序05快速","url":"http://example.com/2020/11/28/十大排序05快速/","content":"快速排序（Quick Sort）快速排序是冒泡排序的一种改进,\n基本思想(分治):\n通过一趟排序将要排序的数据分割成独立的两个部分,\n其中一部分的所有数据都比另外的一部分的所有数据都要小,\n然而按此方法对两部分数据进行分别进行快速排序,\n整个排序过程可以递归进行,因此可以达到目的\n\n\n\n\n\npublic class QuickSortDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;-9, 78, 0, 23, -567, 70, -1&#125;;        System.out.println(Arrays.toString(quickSort(arr, 0, (arr.length - 1))));    &#125;    public static int[] quickSort(int[] num, int left, int right) &#123;        int a = left;//左下标        int b = right;//有下标        int pivot = num[(a + b) / 2];//中间值        int temp = 0; //临时变量，作为交换时使用        //while 循环的目的是让比 pivot 值小放到左边        //比 pivot 值大放到右边        while (a &lt; b) &#123;            //在 pivot 的左边一直找,找到大于等于 pivot 值,才退出            while (num[a] &lt; pivot) &#123;                a++;            &#125;            //在 pivot 的右边一直找,找到小于等于 pivot 值,才退出            while (num[b] &gt; pivot) &#123;                b--;            &#125;            //如果 l &gt;= r 说明 pivot 的左右两的值， 已经按照左边全部是            //小于等于 pivot 值， 右边全部是大于等于 pivot 值            if (a &gt;= b) &#123;                break;            &#125;            //交换            temp = num[a];            num[a] = num[b];            num[b] = temp;            ////如果交换完后， 发现这个 arr[l] == pivot 值 相等 b--， 前移            if (num[a] == pivot) &#123;                b--;            &#125;            ////            //如果交换完后， 发现这个 arr[r] == pivot 值 相等 a++， 后移            if (num[b] == pivot) &#123;                a++;            &#125;            //            //如果 l == r, 必须 l++, r--, 否则为出现栈溢出            if (a == b) &#123;                a++;                b--;            &#125;            //向左递归            if (left &lt; a) &#123;                quickSort(num, left, a);            &#125;            //向右递归            if (right &gt; b) &#123;                quickSort(num, b, right);            &#125;        &#125;        return num;    &#125;&#125;\n\n总结:平均时间复杂度O(nlogn)\n最好情况 O(nlog n)\n最坏情况 O(n^2^)\n空间复杂度 O(nlog n)\n排序方式 ln-place\n稳定性 不稳定\n写法二\n/** * 快速排序方法 * @param array * @param start * @param end * @return */public static int[] QuickSort(int[] array, int start, int end) &#123;    if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;    int smallIndex = partition(array, start, end);    if (smallIndex &gt; start)        QuickSort(array, start, smallIndex - 1);    if (smallIndex &lt; end)        QuickSort(array, smallIndex + 1, end);    return array;&#125;/** * 快速排序算法——partition * @param array * @param start * @param end * @return */public static int partition(int[] array, int start, int end) &#123;    int pivot = (int) (start + Math.random() * (end - start + 1));    int smallIndex = start - 1;    swap(array, pivot, end);    for (int i = start; i &lt;= end; i++)        if (array[i] &lt;= array[end]) &#123;            smallIndex++;            if (i &gt; smallIndex)                swap(array, i, smallIndex);        &#125;    return smallIndex;&#125; /** * 交换数组内两个元素 * @param array * @param i * @param j */public static void swap(int[] array, int i, int j) &#123;    int temp = array[i];    array[i] = array[j];    array[j] = temp;&#125;\n\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"十大排序-希尔排序","url":"http://example.com/2020/11/28/十大排序04希尔/","content":"希尔排序（Shell Sort)基本思想:\n希尔排序也是一种插入排序,它是简单插入排序经过改进之后的一个更高效的版本,**也称为缩小增量排序**,\n该算法是冲破O(n2）的第一批算法之一,他与插入排序的不同之处在于,他会优先比较距离较远的元素\n\n基本思路:\n希尔排序是把记录按下标的一定增量分组,对每组使用直接插入排序算法排序:\n随着增量逐渐减少,每组包含的关键字越多,\n当增量减之到1时,整个文件恰被分成一组， 算法便终止  \n\n\n\n\n\n\npublic class ShellSortDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;        System.out.println(Arrays.toString(shellSort(arr)));    &#125;    //对交换式的希尔排序进行优化-&gt;移位法    public static int[] shellSort(int[] nums) &#123;        int gap;/*        增量gap, 并逐步的缩小增量        每次缩小二倍        */        for (gap = nums.length / 2; gap &gt; 0; gap /= 2) &#123;            for (int i = gap; i &lt; nums.length; i++) &#123;                    int j = i;                    int temp = nums[j];//比较两个数的 后面那一部分                    //nums[j - gap]表示前面的数                    while (j - gap &gt;= 0 &amp;&amp; temp &lt; nums[j - gap]) &#123;                        //移动                        //将前面小的 移动到后面                        nums[j] = nums[j - gap];                        j -= gap;                    &#125;                    //当退出while后，就给temp找到插入的位置                    nums[j] = temp;                &#125;            &#125;        return nums;    &#125;&#125;\n\n总结:平均时间复杂度O(nlog^n^)\n最好情况 O(nlog^2^n)\n最坏情况 O(nlog^2^n)\n空间复杂度 O(1)\n排序方式 ln-place\n稳定性 不稳定\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"javaSE-hash","url":"http://example.com/2020/11/26/javaSE-hash/","content":"哈希表总结哈希表记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。\n因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。\n若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。\n在此，称这个对应关系f为哈希函数，按这个思想建立的表为哈希表（又称为杂凑法或散列表。\n哈希表不可避免冲突（collision）现象：\n对不同的关键字可能得到同一哈希地址 即key1≠key2，而hash(key1)=hash(key2）。\n\n具有相同函数值的关键字对该哈希函数来说称为同义词（synonym）。\n \n\n因此，在建造哈希表时不仅要设定一个好的哈希函数，而且要设定一种处理冲突的方法。\n\n可如下描述哈希表：根据设定的哈希函数H(key）和所选中的处理冲突的方法，\n\n将一组关键字映象到一个有限的、地址连续的地址集（区间）上并以关键字在地址集中的“象”作为相应记录在表中的存储位置，这种表被称为哈希表。\n\n\n\n\n散列表查找步骤散列表(也叫哈希表,Hash table) ,是根据关键码的值进行访问的数据结构.散列表的实现常常叫做散列（hasing）,散列是一种用于以常数平均时间执行插入,删除和查找的技术\n整个散列过程分为两步\n\n通过散列函数计算记录的散列地址,并按照散列地址储存该记录\n无论什么记录我们都需要用同一个散列函数计算地址，然后再存储。\n\n查找通过同样的散列函数计算记录的散列地址,按此散列地址访问该记录.因为我们存和取的时候用的都是一个散列函数，因此结果肯定相同。\n\n\n散列函数是什么呢？\n\n假设某个函数为 f，使得 存储位置 = f (key) 那样我们就能通过查找关键字不需要比较就可获得需要的记录的存储位置。这种存储技术被称为散列技术。散列技术是在通过记录的存储位置和它的关键字之间建立一个确定的对应关系 f ,使得每个关键字 key 都对应一个存储位置 f(key)\n\n这里的f就是我们所描述的哈希函数(散列函数),我们利用散列技术将记录储存在一块连续的储存空间中,这块连续的储存空间就是—-(哈希)散列\n对不同的关键字可能得到同一散列地址，即k1≠k2，而**f(k1)=f(k2)**，这种现象称为冲（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。对于这种情况我们能找到有效的方法解决\n哈希函数的特殊性:创建哈希函数是必须遵循一下原则:\n\n必须一致性\n无论什么记录我们都需要用同一个散列函数计算地址\n\n计算简单\n在保证不哈希冲突的情况下,使得计算简单,如果这个算法计算复杂，会耗费很多时间.散列函数的计算时间不应该超过其他查找技术与关键字的比较时间，不然的话我们干嘛使用哈希技术了\n\n散列地址分布均匀\n让散列地址尽量均匀分布在储存空间中,这样既保证了空间的有效性,有减少了处理冲突而消耗的时间\n\n\n\n\n散列函数构造方法直接定址法:\n取关键字或关键字的某个线性函数值为散列地址。\n即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。\n若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。\n\n\n优点:\n\n简单,均匀,无冲突\n\n应用场景：\n\n需要事先知道关键字的分布情况，适合查找表较小且连续的情况\n\n\n\n数字分析法\n该方法也是十分简单的方法，就是分析我们的关键字，取其中一段，或对其位移，叠加，用作地址\n比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。\n因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。\n\n优点：\n\n简单、均匀、适用于关键字位数较大的情况\n\n应用场景：\n\n关键字位数较大，知道关键字分布情况且关键字的若干位较均匀\n\n\n\n折叠法\n将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。\n比如我们的关键字是123456789，则我们分为三部分 123 ，456 ，789 然后将其相加得 1368 然后我们再取其后三位 368 作为我们的散列地址。\n\n优点：\n\n事先不需要知道关键字情况\n\n应用场景：\n\n适合关键字位数较多的情况\n\n\n\n除法散列法\n在用来设计散列函数的除法散列法中,通过取key除p的余数,将关键字映射到某一个上,对于散列表长度为 m 的散列函数公式为\nf(k) = k mod p  (p &lt;= m)\n\n如\n如果散列表长度为 12，即 m = 12 ，我们的参数 p 也设为12，那 k = 100时 f(k) = 100 % 12 = 4\n我们只需要做一次除法操作,所以除法散列法非常快\n由上面的公式可以看出，该方法的重点在于 p 的取值，如果 p 值选的不好，就可能会容易产生同义词(哈希冲突)。见下面这种情况。我们哈希表长度为6，我们选择6为p值，则有可能产生这种情况，所有关键字都得到了0这个地址数。\n\n\n那我们在选用除法散列法时选取 p 值时应该遵循怎样的规则呢？\n\nm 不应为 2 的幂，因为如果 m = 2^p ，则 f(k) 就是 k 的 p 个最低位数字。例 12 % 8 = 4 ，12的二进制表示位1100，后三位为100。\n若散列表的长度为m,通常p为小于或者等于表长(接近)的最小质数或者包含不小于20质因子的合数\n\n合数：合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。质因子：质因子（或质因数）在数论里是指能整除给定正整数的质数。\n\n\n\n\n\n\n\n注：这里的2，3，5为质因子\n根据规则选择 5 为 p 值，我们再来看。这时我们发现只有 6 和 36 冲突，相对来说就好了很多。\n\n\n优点:\n\n计算效率高,灵活\n\n应用场景:\n\n不知道关键字分布情况\n\n\n\n乘法散列法构造散列函数的乘法散列法主要包含两个步骤\n\n用关键字 k 乘上常数 A(0 &lt; A &lt; 1)，并提取 k A 的小数部分\n用 m 乘以这个值，再向下取整\n\n散列函数为:\nf (k) = ⌊ m(kA mod 1) ⌋\n这里的 kA mod 1 的含义是取 keyA 的小数部分，即 kA - ⌊kA⌋ 。\n优点：对 m 的选择不是特别关键一般选择它为 2 的某个幂次（m = 2 ^ p ,p为某个整数）\n应用场景：不知道关键字情况\n\n\n平方取中法\n这个方法就比较简单了，假设关键字是 321，那么他的平方就是 103041，再抽取中间的 3 位就是 030 或 304 用作散列地址。\n再比如关键字是 1234  那么它的平方就是 1522756 ，抽取中间 3 位就是 227 用作散列地址.\n\n优点：\n灵活，适用范围广泛\n适用场景：\n不知道关键字分布，而位数又不是很大的情况\n\n\n\n\n随机数法选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。\n处理散列冲突的方法hash 函数之后发现关键字 key1 不等于 key2 ，但是 f(key1) = f(key2)，即有冲突，\n开放地址法一旦发生冲突,就会寻找下一个空的散列地址,只要列表足够大,空的散列地址总能找到,并将记录存入,为了使用开放寻址法插入一个元素,需要连续检查散列表,称为探查,我们常用的有线性探测，二次探测，随机探测。\n线性探测法\n\n\n\n我们来看一个例子，我们的关键字集合为{12，67，56，16，25，37，22，29，15，47，48，21}，表长为12，我们再用散列函数 f(key) =  key mod 12。\n我们求出每个 key 的 f(key)见下表\n\n\n\n\n我们查看上表发现，前五位的 f(key) 都不相同，即没有冲突，可以直接存入，但是到了第六位 f(37) = f(25) = 1,那我们就需要利用上面的公式 f(37)  = f (f(37) + 1 ) mod 12 = 2，这其实就是我们的订包间的做法。下面我们看一下将上面的所有数存入哈希表是什么情况吧。\n注：蓝色为计算哈希值，红色为存入哈希表\n\n\n\n\n他第一次会落在下标为 10 的位置，那么如果继续使用线性探测的话，则需要通过不断取余后得到结果，数据量小还好，要是很大的话那也太慢了吧，但是明明他的前面就有一个空房间呀，如果向前移动只需移动一次即可。\n\n\n二次探测法其实理解了我们的上个例子之后，这个一下就能整明白了，根本不用费脑子，这个方法就是更改了一下di的取值\n\n\n注：这里的是 -1^2  为负值 而不是 （-1)^2\n所以对于我们的34来说，当di = -1时，就可以找到空位置了。\n二次探测法的目的就是为了不让关键字聚集在某一块区域。另外还有一种有趣的方法，位移量采用随机函数计算得到，接着往下看吧.\n随机探测法大家看到这是不又有新问题了，刚才我们在散列函数构造规则的第一条中说\n（1）必须是一致的\n我们 di 是随机生成的呀，这里的随机其实是伪随机数，伪随机数含义为，我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在查找时，用同样的随机种子，它每次得到的数列是相同的，那么相同的 di 就能得到相同的散列地址。\n\n\n\n\n\n\n\n\n随机种子（Random Seed）是计算机专业术语，一种以随机数作为对象的以真随机数（种子）为初始条件的随机数。一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数\n\n\n\n再哈希法这个方法其实也特别简单，利用不同的哈希函数再求得一个哈希地址，直到不出现冲突为止。\nf,(key) = RH,( key )   (i = 1,2,3,4…..k)\n这里的RH就是不同的散列函数,可以把我们之前说的那些散列函数都用上,每当发生哈希冲突时就换一个散列函数，相信总有一个能够解决冲突的。这样的代价就是增加了计算时间\n链地址法\nkey 不同 f(key) 相同的情况,我们将这些同义词储存在一个单链表,这种表叫做同义词子表.散列表中只储存同义词表的头指针….\n关键字集合为{12，67，56，16，25，37，22，29，15，47，48，21}，表长为12，\n我们再用散列函数 f(key) =  key mod 12\n用了链地址法之后就在也不冲突,无论有多少冲突，我们只需在同义词子表中添加结点即可。下面我们看下链地址法的存储情况。\n\n\n\n\n\n链地址法虽然不能够产生冲突,但是查找时需要遍历单链表的性能.\n公共溢出区法将有冲突的,,放入到别的地方(溢出表),这样你就有地方住了。我们为所有冲突的关键字建立了一个公共的溢出区来存放。\n\n\n怎样查找: 通过散列函数计算出散列地址后,先于基本表对比,如果不相等就到溢出表中顺序查找.,,,,,,对于冲突很少的情况性能还是非常高的\n散列表查找算法(线性探测法)首先需要定义散列列表的结构以及一些相关常数，\n\nelem代表散列表数据存储数组\ncount代表的是当前插入元素个数\nsize代表哈希表容量\nNULLKEY散列表初始值\n然后我们如果查找成功就返回索引，如果不存在该元素就返回元素不存在。\n我们将哈希表初始化，为数组元素赋初值。\n\n\n\n\n\n插入操作的具体步骤\n\n通过哈希函数(除法散列法),将key转化为数组下标\n如果该下标中没有元素,则插入,否则说明冲突,则利用线性探测法处理冲突\n\n\n\n\n\n查找\n\n通过哈希函数(同输入时一样),将key转化成为数组下标\n通过数组下标找到key值,如果key一致,则查找成功,否则利用线性探测法继续查找\n\n\n\n完整代码\n\n\n散列表性能分析如果没有冲突的话,散列表查找是效率最高的,时间复杂度为O(1),\n散列查找的平均查找长度取决于哪些方面呢\n\n散列函数是否均匀\n\n处理冲突的方法\n比如我们线性探测有时会堆积，则不如二次探测法好，因为链地址法处理冲突时不会产生任何堆积，因而具有最佳的平均查找性能\n\n散列表的填装因子\n装填因子 α  =  填入表中的记录数  /  散列表长度\n\n\n实际应用什么是文件的hash值呢?\nMD5-Hash-文件的数字文摘通过Hash函数计算得到。不管文件长度如何，它的Hash函数计算结果是一个固定长度的数字。与加密算法不同，这一个Hash算法是一个不可逆的单向函数。采用安全性高的Hash算法，如MD5、SHA时，两个不同的文件几乎不可能得到相同的Hash结果。因此，一旦文件被修改，就可检测出来。\n总结:\n一般的线性表、树中，记录在结构中的相对位置是随机的即和记录的关键字之间不存在确定的关系，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较”的基础上，查找的效率与比较次数密切相关。理想的情况是能直接找到需要的记录，因此必须在记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。在此，称这个对应关系f为哈希函数，按这个思想建立的表为哈希表（又称为杂凑法或散列表）。\n哈希表不可避免冲突（collision）现象：对不同的关键字可能得到同一哈希地址 即key1≠key2，而hash(key1)=hash(key2）。具有相同函数值的关键字对该哈希函数来说称为同义词（synonym）。因此，在建造哈希表时不仅要设定一个好的哈希函数，而且要设定一种处理冲突的方法。可如下描述哈希表：根据设定的哈希函数H(key）和所选中的处理冲突的方法，将一组关键字映象到一个有限的、地址连续的地址集（区间）上并以关键字在地址集中的“象”作为相应记录在表中的存储位置，这种表被称为哈希表。\n对于动态查找表而言，1) 表长不确定；2）在设计查找表时，只知道关键字所属范围，而不知道确切的关键字。因此，一般情况需建立一个函数关系，以f(key）作为关键字为key的录在表中的位置，通常称这个函数f(key）为哈希函数。（注意：这个函数并不一定是数学函数）\n哈希函数是一个映象，即：将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地址集合的大小不超出允许范围即可。\n现实中哈希函数是需要构造的，并且构造的好才能使用的好。\n用途：加密，解决冲突问题。\n\n\n\n转载百度百科\n袁厨的算法小屋\n","categories":["-javase"],"tags":["hash","基础","java"]},{"title":"LC052-最大子序和","url":"http://example.com/2020/11/25/LC052/","content":"53. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n示例:\n输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n方法一:动态规划\n动态规划的是首先对数组进行遍历,当当前最大连续子序列和为sum,结果为ans\n如果sum &gt; 0,则说明sum对结果有增益效果,则sum保留并加上当前遍历数字\n如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字\n每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果\n   \n\n时间复杂度：O(n)\nclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int ans = nums[0];        int sum = 0;        for(int num: nums) &#123;            if(sum &gt; 0) &#123;                sum += num;            &#125; else &#123;                sum = num;            &#125;            ans = Math.max(ans, sum);        &#125;        return ans;    &#125;&#125;\n\n方法二:分治法\n分治法\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"LC084-柱状图中最大的矩形","url":"http://example.com/2020/11/25/LC084/","content":"84. 柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n \n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。\n   \n\n \n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。\n输入: [2,1,5,6,2,3]输出: 10\n\n方法一:暴力破解法遍历到每一个柱子的左右,由这个柱子向两侧延申,直到遇到比其更小的h柱子,确定左右边界.对应的面积为w*h\npublic class LEE084L &#123;    public int largestRectangleArea(int[] heights) &#123;        int res = 0;        int n = heights.length;        for (int mid = 0; mid &lt; n; mid++) &#123;            int midHeight = heights[mid];            int a = mid;            int b = mid;            while (a - 1 &gt;= 0 &amp;&amp; heights[a - 1] &gt;= midHeight) &#123;                a--;            &#125;            while (b + 1 &lt; n &amp;&amp; heights[b + 1] &gt;= midHeight) &#123;                b++;            &#125;            res = Math.max(res, (b - a + 1) * midHeight);        &#125;        return res;    &#125;&#125;\n\n\n\n方法二:单调栈\n单调栈分为单调递增,单调递减\n\n操作规则（下面都以单调递增栈为例）\n如果新的元素比栈顶大,就入栈\n如果新的元素比栈顶小,就弹出栈顶的元素,直到栈顶比新元素小.也就是新元素大\n\n加入这样一个规则之后，会有什么效果\n栈内的元素是递增的当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素\n当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素\n\n\n画图理解\n\n思路\n\n对于一个高度,如果能得到向左向右的边界\n那么就能对每个高度求依次面积\n遍历左所有高度,即可得出最大面积\n使用单调栈,在出栈操作时得到前后边界并计算面积\n\npublic int largestRectangleArea(int[] heights) &#123;    int res = 0;    ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();    int[] newHeight = new int[heights.length + 2];    //给数组前后加零 , 以便数组后面完整的弹出栈中    for (int i = 1; i &lt; heights.length + 1; i++) &#123;        newHeight[i] = heights[i - 1];    &#125;        for (int i = 0; i &lt; newHeight.length; i++) &#123;        //当栈为空,或者 当前栈顶的元素小于 后一个数组的元素        while (!stack.isEmpty() &amp;&amp; newHeight[(int) stack.peek()] &gt; newHeight[i]) &#123;            //弹出栈顶的元素            int cur = stack.pop();            //前一个的元素位置            int l = stack.peek();            //后一个的位置            int r = i;            //计算大小            res = Math.max(res, (r - l - 1) * newHeight[cur]);        &#125;        stack.push(i);    &#125;    return res;&#125;\n\n\n单调栈学习建议）：「力扣」第 42、739、496、316、901、402、581 题。\n\n","categories":["-算法"],"tags":["LeetCode","单调栈"]},{"title":"LC042-接雨水","url":"http://example.com/2020/11/23/LC042/","content":"42. 接雨水官方解说视频\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n \n\n示例 1：\n输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n   \n\n示例 2：\n输入：height &#x3D; [4,2,0,3,2,5]输出：9\n\n\n\n\n\n方法一暴力思想\n遍历出每一个柱子,所对应左右最大的高度,等于两边最大高度的较小值减去当前高度的值\npublic int trap(int[] height) &#123;    int sum = 0;    for(int i = 0; i &lt; height.length; i++) &#123;        // 第一个柱子和最后一个柱子不接雨水        if (i == 0 || i == height.length - 1) continue;        int rHeight = height[i]; // 记录右边柱子的最高高度        int lHeight = height[i]; // 记录左边柱子的最高高度        for (int r = i + 1; r &lt; height.length; r++) &#123;            if (height[r] &gt; rHeight) rHeight = height[r];        &#125;        for (int l = i - 1; l &gt;= 0; l--) &#123;            if (height[l] &gt; lHeight) lHeight = height[l];        &#125;        int h = Math.min(lHeight, rHeight) - height[i];        if (h &gt; 0) sum += h;    &#125;    return sum;&#125;\n\n方法二动态规划\n找到数组中从下标 最后  到最左端最高的条形块高度 left_max。\n找到数组中从下标 0     到最右端最高的条形块高度right_max。\nans += Math.min(left_max[i], right_max[i]) - height[i];\n\n\n\n\n\n\n\npublic int trap(int[] height) &#123;    int sum = 0;    if (height.length &lt;= 2)        return 0;    int[] max_left = new int[height.length];    int[] max_right = new int[height.length];    for (int i = 1; i &lt; height.length - 1; i++) &#123;        //相对于左边  最大值 进行遍历        max_left[i] = Math.max(max_left[i - 1], height[i - 1]);    &#125;    for (int i = height.length - 2; i &gt;= 0; i--) &#123;        ////相对于右边  最大值 进行遍历        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);    &#125;    for (int i = 1; i &lt; height.length - 1; i++) &#123;        int min = Math.min(max_left[i], max_right[i]);        if (min &gt; height[i]) &#123;            sum = sum + (min - height[i]);        &#125;    &#125;    return sum;&#125;\n\n复杂度:\n时间复杂度：O(n)\n​                    存储最大高度数组，需要两次遍历，每次 O(n)​                    最终使用存储的数据更新ans ，O(n)空间复杂度：O(n) 额外空间。\n栈的应用使用单调栈\n单调栈的应用\n单调递减栈\n\n当后面的柱子高度比前面的低时，是无法接雨水的 当找到一根比前面高的柱子，就可以计算接到的雨水所以使用单调递减栈\n\n对更低的柱子入栈\n\n更低的柱子以为这后面如果能找到高柱子，这里就能接到雨水，所以入栈把它保存起来\n\n平地相当于高度 0 的柱子，没有什么特别影响\n\n当出现高于栈顶的柱子时\n\n说明可以对前面的柱子结算了 计算已经到手的雨水，然后出栈前面更低的柱子\n\n\n计算雨水的时候需要注意的是\n\n雨水区域的右边 r 指的自然是当前索引 i\n底部是栈顶 st.top() ，因为遇到了更高的右边，所以它即将出栈，使用 cur 来记录它，并让它出栈\n左边 l 就是新的栈顶 st.top()\n雨水的区域全部确定了，水坑的高度就是左右两边更低的一边减去底部，宽度是在左右中间\n使用乘法即可计算面积\n\n相关解说视频\npublic int trap(int[] height) &#123;    int sum = 0;    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    int current = 0;    while (current &lt; height.length) &#123;        //如果栈部位空的话,并且指向的高度大于栈顶高度就一直循环        while (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;            int h = height[stack.peek()];//取出要出栈的元素            stack.pop();            if (stack.empty()) &#123;                break;            &#125;            int dis = current - stack.peek() - 1; //两堵墙之前的距离。            int min = Math.min(height[stack.peek()], height[current]);            sum = sum + dis * (min - h);        &#125;        stack.push(current); //当前指向的墙入栈        current++; //指针后移    &#125;    return sum;&#125;\n\n双指针和方法 2 相比，我们不从左和从右分开计算，我们想办法一次完成遍历。\n\nleft_max：左边的最大值，它是从左往右遍历找到的right_max：右边的最大值，它是从右往左遍历找到的left：从左往右处理的当前下标right：从右往左处理的当前下标\n定理一：在某个位置i处，它能存的水，取决于它左右两边的最大值中较小的一个。\n定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）\n定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。\n对于位置left而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果left_max&lt;right_max成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当left_max&lt;right_max时，我们就希望去处理left下标，反之，我们希望去处理right下标。\n\n  public int trap(int[] height) &#123;//确定左右指针      int left = 0;      int right = height.length - 1;      int ans = 0;      //确定左右指针      int leftMax = 0;      int rightMax = 0;      while (left &lt; right) &#123;          if (height[left] &lt; height[right]) &#123;              if (height[left] &gt;= leftMax) &#123;                  leftMax = height[left];              &#125; else &#123;                  ans += (leftMax - height[left]);              &#125;              ++left;          &#125; else &#123;              if (height[right] &gt;= rightMax) &#123;                  rightMax = height[right];              &#125; else &#123;                  ans += (rightMax - height[right]);              &#125;              --right;          &#125;      &#125;      return ans;  &#125;\n\n时间复杂度：O(N)。遍历了一遍数组。空间复杂度：O(1)。使用了有限的 left, right, ans, maxleft, maxright。\n","categories":["-算法"],"tags":["LeetCode","数组","单调栈"]},{"title":"LC143-重排链表","url":"http://example.com/2020/11/20/LC143/","content":"143. 重排链表难度中等459收藏分享切换为英文接收动态反馈\n给定一个单链表 L：L0→L1→…→L**n-1→Ln ，将其重新排列后变为： L0→L**n→L1→L**n-1→L2→L**n-2→…\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例 1:\n给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.\n\n示例 2:\n给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.\n\n方法一:储存到线性表.单链表不能由尾部开始遍历取数,只能有头开始遍历,\n   \n\n因此将所有遍历出来,储存到线性表中,\n通过前后双指针进行连接,得到结果\n\n\npublic void reorderList(ListNode head) &#123;    if (head == null) &#123;        return;    &#125;    //存到 list 中去    List&lt;ListNode&gt; list = new ArrayList&lt;&gt;();    while (head != null) &#123;        list.add(head);        head = head.next;    &#125;    //头尾指针依次取元素    int i = 0, j = list.size() - 1;    while (i &lt; j) &#123;        list.get(i).next = list.get(j);        i++;        //偶数个节点的情况，会提前相遇        if (i == j) &#123;            break;        &#125;        list.get(j).next = list.get(i);        j--;    &#125;    list.get(i).next = null;&#125;\n\n方法二,(低效)整体进行递归具体思路如图所示\n\n\n\n\n\n\n\n\npublic void reorderList(ListNode head) &#123;           if (head == null || head.next == null || head.next.next == null)&#123;        return;    &#125;    ListNode temp=head;    while (temp.next.next!=null)&#123;        temp=temp.next;    &#125;    temp.next.next=head.next;    head.next=temp.next;    temp.next=null;    reorderList(head.next.next);&#125;\n\n方法三:(高效)利用反转法,中间值.进行插入思路\n\n利用快慢指针法,求出链表的中间节点\n得到两个子链标后,将最后一个反转\n然后将子链表中的节点依次进行连接,得出的结果\n\n有关合并的解图\n\n\n\n\n\n\n\n\npublic void reorderList(ListNode head) &#123;      if (head == null || head.next == null || head.next.next == null) &#123;          return;      &#125;    //利用快慢指针进行判断中间值      ListNode slow = head;      ListNode fast = head;      while (fast != null &amp;&amp; fast != null) &#123;          slow = slow.next;          fast = fast.next.next;      &#125;      //断开中间点,后半部分进行反转      ListNode head2 = null;      ListNode next = slow.next;      slow.next = null;//将前后端来      while (slow != null) &#123;          next = slow.next;          slow.next = head2;          head2 = slow;          slow = next;      &#125;      //合并      ListNode cur1 = head;      ListNode cur2 = head2;      while (cur1 != null &amp;&amp; cur2 != null) &#123;          next = cur1.next;          cur1.next = cur2;          cur2 = cur2.next;          cur1.next.next = next;          cur1 = next;      &#125;  &#125;\n\n相对于其他递归的解法\nclass Solution &#123;    public void reorderList(ListNode head) &#123;        if(head == null)&#123;            return ;        &#125;        //1. 使用快慢指针,找出链表的中心节点。        // 1-&gt;2-&gt;3-&gt;4-&gt;5,中心节点为3        ListNode middle = middleNode(head);        //2. 将原始链表按照中心链表分割为两个链表，并将右链表反转        //2.1 原始链表：1-&gt;2-&gt;3-&gt;4-&gt;5 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5        ListNode left = head;        ListNode right = middle.next;        middle.next = null;        //2.2 反转右链表        //原始右链表：4-&gt;5 反转后：5-&gt;4        right = reverse(right);        //3. 合并两个链表，将右链表插入到左链表        //左链表：1-&gt;2-&gt;3 右链表：4-&gt;5 合并后：1-&gt;5-&gt;2-&gt;4-&gt;3        merge(left,right);    &#125;    //1. 使用快慢指针,找出链表的中心节点    public ListNode middleNode(ListNode head) &#123;        ListNode slow = head;        ListNode fast = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;        &#125;        return slow;    &#125;    //2. 通过递归反转链表    public ListNode reverse(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125;        ListNode last = reverse(head.next);        head.next.next = head;        head.next = null;        return last;    &#125;    //3. 合并两个链表，将右链表插入到左链表    public void merge(ListNode left, ListNode right)&#123;        ListNode leftTemp;        ListNode rightTemp;        while (left.next != null &amp;&amp; right!= null) &#123;            //1. 保存next节点            leftTemp = left.next;            rightTemp = right.next;            //2. 将右链表的第一个节点插入到左链表中            // 左链表：1-&gt;2-&gt;3 右链表：5-&gt;4             // 合并后的左链表：1-&gt;5-&gt;2-&gt;3             left.next = right;            right.next = leftTemp;            //3. 移动left和right指针            //左链表变为：2-&gt;3 右链表变为：4            left = leftTemp;            right = rightTemp;        &#125;    &#125;&#125;\n\n\n\n","categories":["-算法"],"tags":["LeetCode","链表反转","链表合并"]},{"title":"LC023-合并K个升序链表","url":"http://example.com/2020/11/19/LC023/","content":"23.合并K个升序链表给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例 1：\n输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\n\n\n利用堆做排序   \n\n需要一种辅助数据结构-堆，有了堆这个数据结构，难度等级是困难的题目，瞬间变成简单了。\n只把k个链表的第一个节点放入到堆中\n之后不断从堆中取出节点，如果这个节点还有下一个节点，\n就将下个节点也放入堆中\n\n\npublic ListNode mergeKLists(ListNode[] lists) &#123;      if (lists == null || lists.length == 0) &#123;          return null;      &#125;      //创建一个最小的堆,并定义好内部排序      PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() &#123;          @Override          public int compare(ListNode o1, ListNode o2) &#123;              return (o1.val - o2.val);          &#125;      &#125;);      ListNode dummy=new ListNode(-1);      ListNode cur=dummy;      //把每个链表的第一个节点放入到堆中      for (int i = 0; i &lt;lists.length ; i++) &#123;          ListNode head=lists[i];          if (head!=null)&#123;              queue.add(head);          &#125;      &#125;      //  poll()把检索并删除此队列的头，如果此队列为空，则返回 null 。      //之后不断从堆中取出节点，如果这个节点还有下一个节点，      //就将下个节点也放入堆中      while (queue.size()&gt;0)&#123;          ListNode node=queue.poll();          cur.next=node;          cur=cur.next;          if (node.next!=null)&#123;              queue.add(node.next);          &#125;      &#125;      cur.next=null;      return  dummy.next;  &#125;\n\n两两合并\n\npublic ListNode mergeKLists(ListNode[] lists) &#123;        if (lists == null || lists.length == 0) &#123;            return null;        &#125;        ListNode newList = lists[0];        for (int i = 1; i &lt; lists.length; i++) &#123;            newList = merge(newList, lists[i]);        &#125;        return newList;    &#125;//两两合并的代码，直接把下面这段代码拿来用即可    public ListNode merge(ListNode a, ListNode b) &#123;        if (a == null || b == null) &#123;            return (a == null) ? b : a;        &#125;        if (a.val &lt;= b.val) &#123;            a.next = merge(a.next, b);            return a;        &#125; else &#123;            b.next = merge(a, b.next);            return b;        &#125;    &#125;&#125;\n\n分治分治就是不断缩小其规模，再不断合并扩大的过程\n\n分治就是不断缩小其规模,在不断扩大的过程\n一开始的数组的规模是6,我们找到中间点,将一分为二,然后再分,直到不能在分(规模为一),便返回\n之后合并,合并接用合并两个排序链表的代码\n当两个规模最小的链表合并完后,其规模就变大,\n然后不断重复这个合并过程,直到最终得到一个有序的链表\n\n\n\n复杂度\n\n\npackage com.nie.LEE;public class LEE023L &#123;    /*    分治就是不断缩小其规模,在不断扩大的过程    一开始的数组的规模是6,我们找到中间点,将一分为二,然后再分,直到不能在分(规模为一),    便返回    之后合并,合并接用合并两个排序链表的代码    当两个规模最小的链表合并完后,其规模就变大,    然后不断重复这个合并过程,直到最终得到一个有序的链表      */    public ListNode mergeKLists(ListNode[] lists) &#123;        if (lists == null || lists.length == 0) &#123;            return null;        &#125;        return  helper(lists,0,lists.length-1);    &#125;    //通过mid将数组一分为二，并不断缩小规模，当规模为1时返回并开始合并\t//通过合并两个链表，不断增大其规模，整体看就是不断缩小-最后不断扩大的过程    private ListNode helper(ListNode[] lists, int begin, int end) &#123;        if (begin==end)&#123;            return  lists[begin];        &#125;        int mid=begin+(end-begin)/2;        ListNode left=helper(lists,begin,mid);        ListNode right=helper(lists,mid+1,end);        return  merge(left,right);    &#125;////合并两个有序链表    public ListNode merge(ListNode a, ListNode b) &#123;        if (a == null || b == null) &#123;            return (a == null) ? b : a;        &#125;        if (a.val &lt;= b.val) &#123;            a.next = merge(a.next, b);            return a;        &#125; else &#123;            b.next = merge(a, b.next);            return b;        &#125;    &#125;    public class ListNode &#123;        int val;        ListNode next;        ListNode() &#123;        &#125;        ListNode(int val) &#123;            this.val = val;        &#125;        ListNode(int val, ListNode next) &#123;            this.val = val;            this.next = next;        &#125;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","链表合并"]},{"title":"LC092-反转链表 II","url":"http://example.com/2020/11/19/LC092/","content":"92. 反转链表 II难度中等581\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n说明:1 ≤ m ≤ n ≤ 链表长度。\n示例:\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL\n\n\n\n迭代-1头插法   \n\n思路\n\n定义两个指针,分别称为 g  和 p\nm确定g和p的位置。将g移动到第一个要反转的节点的前面，将p移动到第一个要反转的节点的位置上。\n利用头插法进行反转\n\n\n\n\npublic ListNode reverseBetween(ListNode head, int m, int n) &#123;    ListNode dummy = new ListNode(0);    dummy.next = head;    //定义两个指针,分别称为 g  和 p    ListNode g=dummy;    ListNode p=dummy.next;    int count=0;    // m确定g和p的位置。将g移动到第一个要反转的节点的前面，将p移动到第一个要反转的节点的位置上。    while (count&lt;m-1)&#123;        g=g.next;        p=p.next;        count++;    &#125;    //利用头插法进行反转    for (int i=0; i&lt;n-m;i++)&#123;        ListNode removed=p.next;        p.next=p.next.next;        removed.next=g.next;        g.next=removed;    &#125;    return dummy.next;&#125;\n\n\n\n迭代-2,反转法\n因为要反转中间的链表,所以我把链表分成三条(前部分链表,反转链表和后部分链表)\n\n找到前部分链表的尾节点(第m-1个节点)就可以开始反转,最后把三个链表拼接\n\n前部分链表(1~m-1)\n\n反转链表(m~n)\n\n后部分链表(n~最后)\n\n\nclass Solution &#123;    public ListNode reverseBetween(ListNode head, int m, int n) &#123;            int count = 1;        //虚拟头节点        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode node = dummy;        //找到前部分链表的尾节点        while (count != m) &#123;            node = node.next;            count++;        &#125;        //拼接操作: 前部分链表-&gt;反转链表 (此时的node是前部分链表的尾节点)        node.next = reverse(node.next, n - m + 1);        return dummy.next;    &#125;      private static ListNode reverse(ListNode head, int num) &#123;        ListNode next;        ListNode newNode = null;        //反转链表后的最后一个节点就是一开始的头节点        ListNode reverseTail = head;        for (int i = 0; i &lt; num; i++) &#123;            next = head.next;            head.next = newNode;            newNode = head;            head = next;        &#125;        //拼接操作: 反转链表-&gt;后部分链表 (此时的head=next=后部分链表头节点)        reverseTail.next = head;        return newNode;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n递归递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。\n处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题\n值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。\n详情情况前看\n代码\npublic class LEE092 &#123;    ListNode reverseBetween(ListNode head, int m, int n) &#123;        // base case        if (m == 1) &#123;            return reverseN(head, n);        &#125;        // 前进到反转的起点触发 base case        head.next = reverseBetween(head.next, m - 1, n - 1);        return head;    &#125;    ListNode successor=null;    //反转函数,由头开始的    public ListNode reverseN(ListNode head,int n)&#123;        if (n==1)&#123;            successor=head.next;            return  head;//记录第一个节点        &#125;        ListNode last=reverseN(head.next,n-1);        head.next.next=head;        head.next=successor;        return last;    &#125;    public static class ListNode &#123;        int val;        ListNode next;        ListNode(int x) &#123; val = x; &#125;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","链表反转"]},{"title":"LC025-K个一组翻转链表","url":"http://example.com/2020/11/18/LC025/","content":"25. K 个一组翻转链表难度困难793收藏分享切换为英文接收动态反馈\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n示例：\n给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5\n当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5\n当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5\n   \n\n说明：\n\n你的算法只能使用常数的额外空间。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换\n\n栈有一道经典的题目，反转链表，将1-&gt;2-&gt;3-&gt;4变成4-&gt;3-&gt;2-&gt;1。反转链表的一个解法是用栈作为辅助结构，将[1,2,3,4]放入栈中，然后依次弹出来，再把弹出来的节点串联起来，这样就变成4-&gt;3-&gt;2-&gt;1了。\n对于k个一组反转，我们也可以用同样的方式，只不过这次不是将全部节点放入栈中，而是将k个节点放入栈中，之后再弹出k个节点，并将他们依次串联起来，这样就达到了反转k个节点的效果了。\n有个细节需要注意下，比如链表是:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7，k=3时，整个链表遍历完后，栈的个数不等于k，此时栈中只有一个元素7。判断栈长度不等于k直接退出就可以了。\n当然用栈实现其实并不符合题意，只当扩展下思路。\npublic ListNode reverseKGroup(ListNode head, int k) &#123;    if (head == null || k &lt;=0) &#123;        return head;    &#125;    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();    //设置一个新链表的头    ListNode dummy = new ListNode(-1);    //新节点指向原头    dummy.next = head;    //对于新链表设置一个辅助节点    ListNode p = dummy;    int n = k;    while (p != null &amp;&amp; p.next != null) &#123;        //设置一个辅助节点来进行栈的处理        ListNode temp = p.next;        while (temp != null &amp;&amp; n &gt; 0) &#123;            //进行入栈            stack.add(temp);            temp = temp.next;            --n;        &#125;        //出站        //标记出来第一个节点        //12  就标记的是2        //备份K+1 节点,用于后面的串的作用        ListNode nextNode = stack.peek().next;        //这里n等于零就表示正好存放k个节点        if (n == 0) &#123;            while (stack.size() &gt; 0) &#123;                p.next = stack.pop();                p = p.next;            &#125;        &#125;else &#123;            break;        &#125;        p.next=nextNode;        n=k;    &#125;    return dummy.next;&#125;\n\n\n\n迭代思路\n\n1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7\n反转K个,由于遍历k个链表,然后将第k个节点的next指向空(防止循环)\n这样就得到了长度为k的单链表了。1-&gt;2-&gt;3    4-&gt;5-&gt;6-&gt;7\n然后反转所截的\n如果遍历完整个链表，发现最后几个节点的长度不足k，那么直接退出就可以了。\n把长度k的链表前后指向切断，这样就不会出现循环指向了。\n\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre = null;//新节点        ListNode cur = head;//辅助结点进行反转的        while (cur != null) &#123;            ListNode temp = cur.next;////标记下一次需要反转的节点            cur.next = pre;//已经开始反转            //移动节点  准备下一次反转            pre = cur;            cur = temp;        &#125;        return pre;    &#125;    public ListNode reverseKGroup(ListNode head, int k) &#123;        if (head == null || k &lt; 0) &#123;            return head;        &#125;        ListNode dummy = new ListNode(-1);        //新节点指向头节点        dummy.next = head;        //设置辅助指针进行遍历        ListNode p = dummy;        int n = k;        while (p.next != null) &#123;            //辅助指针进行遍历            ListNode temp = p;            while (temp != null &amp;&amp; temp.next != null &amp;&amp; n &gt; 0) &#123;                //在合法范围之内遍历到  k的位置上                temp = temp.next;                --n;            &#125;            if (n == 0) &#123;                //报先记录下temp.next,方便后面链接链表                ListNode nextNode = temp.next;                //得到开始要遍历的节点                //假设链表为1-&gt;2-&gt;3-&gt;4，下面的nextNode就是4，tail是1                ListNode tail = p.next;                //反转之前需要将下一个节点保存，并设置next为空，防止循环指向                temp.next = null;                //进行反转                //p 也即是dummy指向反转后的节点 dummy-&gt;2-&gt;1                p.next = reverseList(tail);                //翻转后头节点变到最后。通过.next把断开的链表重新链接。                //1&lt;-2 3-&gt;4 转换成为    2-&gt;1-&gt;3-&gt;4                tail.next = nextNode;                //移动p节点进行下一个遍历                p = tail;                n = k;            &#125; else &#123;                break;            &#125;        &#125;        return dummy.next;    &#125;","categories":["-算法"],"tags":["LeetCode","链表反转"]},{"title":"LC206-反转链表","url":"http://example.com/2020/11/17/LC206/","content":"206. 反转链表难度简单1340\n反转一个单链表。\n示例:\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n栈  \n\n反转就想到栈,栈先进先出,实现原理,先全部压入到栈中,然后由头部一个一个取出,链接成一个新链表\npublic ListNode reverseList(ListNode head) &#123;        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        //把链表节点全部放入到栈中        ListNode temp = head;        while (temp != null) &#123;            stack.push(temp);            temp = temp.next;        &#125;        if (stack.isEmpty())            return null;        //取出第一个   作为头        ListNode node = stack.pop();        //标记头节点        ListNode dummy = node;        //把栈中的结点全部出栈,然后从新连成一个新的链表        while (!stack.isEmpty()) &#123;            ListNode tempNode = stack.pop();            node.next = tempNode;            node = node.next;        &#125;        //最后一个结点就是反转前的头结点，一定要让他的next        //等于空，否则会构成环        node.next = null;        return dummy;    &#125;&#125;\n\n双指针迭代我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。第二个指针 cur 指向 head，然后不断遍历 cur。每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。\n\n\npublic ListNode reverseList(ListNode head) &#123;    //新链表    ListNode newHead = null;    while (head != null) &#123;        //先保存访问的节点的下一个节点，保存起来        //留着下一步访问的        ListNode temp = head.next;        //每次访问的原链表节点都会成为新链表的头结点，        //其实就是把新链表挂到访问的原链表节点的        //后面就行了        head.next = newHead;        //更新新链表        newHead = head;        //重新赋值，继续访问        head = temp;    &#125;    //返回新链表    return newHead;&#125;\n\n递归解法这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。递归的两个条件：\n终止条件是当前节点或者下一个节点==null在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句\nhead.next.next = head很不好理解，其实就是 head 的下一个节点指向head。递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。\n\n\nclass Solution &#123;\tpublic ListNode reverseList(ListNode head) &#123;\t\t&#x2F;&#x2F;递归终止条件是当前为空，或者下一个节点为空\t\tif(head&#x3D;&#x3D;null || head.next&#x3D;&#x3D;null) &#123;\t\t\treturn head;\t\t&#125;\t\t&#x2F;&#x2F;这里的cur就是最后一个节点\t\tListNode cur &#x3D; reverseList(head.next);\t\t&#x2F;&#x2F;这里请配合动画演示理解\t\t&#x2F;&#x2F;如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5\t\t&#x2F;&#x2F;而head是4，head的下一个是5，下下一个是空\t\t&#x2F;&#x2F;所以head.next.next 就是5-&gt;4\t\thead.next.next &#x3D; head;\t\t&#x2F;&#x2F;防止链表循环，需要将head.next设置为空\t\thead.next &#x3D; null;\t\t&#x2F;&#x2F;每层递归函数都返回cur，也就是最后一个节点\t\treturn cur;\t&#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","链表反转"]},{"title":"LC024-两两交换链表中的节点","url":"http://example.com/2020/11/17/LC024/","content":"24. 两两交换链表中的节点难度中等741\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3]\n\n  \n\n示例 1：\n\n\n\n\n示例 2：\n输入：head &#x3D; []输出：[]\n\n栈:利用栈的特性不断地进行迭代,每次给栈中放入间隔元素就有栈中取出,\n借助栈的特性,放进去的1,2  拿出的是2 1\n在把其串联起立,就是所求的结果\npublic ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125;//利用栈的特殊性        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        ListNode p = new ListNode(0);//新链表的结点        //设置一个辅助变量temp 进行遍历        ListNode temp = head;        //head指向新的p节点，函数结束时返回head.next即可        head = p;        while (temp != null &amp;&amp; temp.next != null) &#123;            //放入两个结点到栈中            stack.push(temp);            stack.push(temp.next);            //当前节点往前走两步            temp=temp.next.next;            p.next=stack.pop();            //p结点往下也走两步            p=p.next;            p.next=stack.pop();            p=p.next;        &#125;        //注意边界条件，当链表长度是奇数时，cur就不为空        if(temp!=null) &#123;            p.next = temp;        &#125; else &#123;            p.next = null;        &#125;        return head.next;    &#125;\n\n迭代实现迭代需要 三个指针  a b temp\n例如链表\n1 2 3 4 5 6 7 \n\n第一次迭代的时候:  a= 1  b =2\n通过a.next = b,next      b.next=a  反转过来.  也就是1 2  变称 2 1\n当数组变成 2 1 和  4 3时候,这时候需要 1 4 穿起来,这时候就需要第三个指针temp\ntmp指针用来处理边界条件的\n现在链表就变成2-&gt;1-&gt;3-&gt;4\ntemp和b都指向1节点，等下次迭代的时候a就变成3，b就变成4，然后tmp就指向b，也就是1指向4\n\ntemp.next = b;a.next = b.next;b.next = a;temp = a;\n\nclass Solution &#123;\tpublic ListNode swapPairs(ListNode head) &#123;\t\t//增加一个特殊节点方便处理\t\tListNode p = new ListNode(-1);\t\tp.next = head;\t\t//创建a，b两个指针，这里还需要一个tmp指针\t\tListNode a = p;\t\tListNode b = p;\t\tListNode temp = p;\t\twhile(b!=null &amp;&amp; b.next!=null &amp;&amp; b.next.next!=null) &#123;\t\t\t//a前进一位，b前进两位\t\t\ta = a.next;\t\t\tb = b.next.next;\t\t\t//进行换位            //头结点指向2\t\t\ttemp.next = b;          //通过a.next = b,next  \tb.next=a  反转过来.  也就是1 2  变称 2 1\t\t\ta.next = b.next;\t\t\tb.next = a;\t\t   //tmp和b都指向1节点，等下次迭代的时候\t\t\t//a就变成3，b就变成4，然后tmp就指向b，也就是1指向4\t\t\ttemp = a;\t\t\tb = a;\t\t&#125;\t\treturn p.next;\t&#125;&#125;\n\n递归解法class Solution &#123;\tpublic ListNode swapPairs(ListNode head) &#123;\t\t//递归的终止条件\t\tif(head==null || head.next==null) &#123;\t\t\treturn head;\t\t&#125;\t\t//假设链表是 1-&gt;2-&gt;3-&gt;4\t\t//这句就先保存节点2\t\tListNode tmp = head.next;\t\t//继续递归，处理节点3-&gt;4\t\t//当递归结束返回后，就变成了4-&gt;3\t\t//于是head节点就指向了4，变成1-&gt;4-&gt;3\t\thead.next = swapPairs(tmp.next);\t\t//将2节点指向1\t\ttmp.next = head;\t\treturn tmp;\t&#125;&#125;\n\n​                            \n","categories":["-算法"],"tags":["LeetCode","链表反转"]},{"title":"数据结构和算法--005--双向链表","url":"http://example.com/2020/11/17/B站数据结构005/","content":"双向链表应用实例管理单链表的缺点分析\n\n单向链表,查找的方向只能是一个方向,而双链表可以向前或者后查找\n\n单向链表不能自我删除,需要辅助结点,而双向链表,可进行自我删除,所以我们单链表删除节点时,总是找到temp(待删除结点的前一个结点)\n\n\n操作遍历方向和单链表一样,可以向前也可以向后查找\n添加头部插入  \n\n\n要插入放入的节点    Link newNode = new Link(data);\n将还没插入新结点之前链表的第一个结点的previous指向newNode    first.previous = newNode;\n将新结点的next指向first\n将新结点赋给first（链接）成为第一个结点\n\nnewNode.next = first;        \nfirst = newNode;\n\n\n\npublic void insertFirst(int data) &#123;\t\tLink newNode = new Link(data);\t\tif(isEmpty()) &#123;\t\t\tlast = newNode;\t\t&#125;else &#123;//如果不是第一个结点的情况\t\t\tfirst.previous = newNode;\t//将还没插入新结点之前链表的第一个结点的previous指向newNode\t\t&#125;\t\tnewNode.next = first;\t\t//将新结点的next指向first\t\tfirst = newNode;\t\t\t//将新结点赋给first（链接）成为第一个结点\t&#125;\n\n尾部插入当退出while循环,temp就指向链表的最后\n将最后这个节点的next指向新的节点\ntemp.next = heroNode;heroNode.pre = temp;\npublic void add(HeroNode2 heroNode) &#123;     //头节点不能动,需要一个辅助遍历temp     HeroNode2 temp = head;     //遍历链表到最后     while (true) &#123;         if (temp.next == null) &#123;             break;         &#125;         //如果没有找的,将temp后移         temp = temp.next;     &#125;     //当退出while循环,temp就指向链表的最后     //将最后这个节点的next指向新的节点     temp.next = heroNode;     heroNode.pre = temp; &#125;\n\n\n\n指定的位置插入\nheroNode.next = temp.next;\n\nheroNode.pre = temp;\n\ntemp.next = heroNode;\n\ntemp.next.pre = heroNode;    \n\n\n\n\n\n\n   /*     第二种方式在添加英雄时，根据排名将英雄插入到指定位置   (如果有这个排名，则添加失败，并给出提示)        */    public void addByOrder(HeroNode2 heroNode) &#123;//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)        //因为单链表,我们找的temp是位于添加位置的前一个节点,否则插入失败        HeroNode2 temp = head;        boolean flag = false; // flag标志添加的编号是否存在，默认为false        while (true) &#123;            //说明已经在链表最后了            if (temp.next == null) &#123;                break;            &#125;            ////位置找到，就在temp的后面插入            if (temp.next.no &gt; heroNode.no) &#123;                break;                //说明希望添加的heroNode的编号已然存在            &#125; else if (temp.next.no == heroNode.no) &#123;                flag = true; //说明编号存在                break;            &#125;            temp = temp.next;        &#125;        if (flag) &#123;            System.out.println(heroNode.no + &quot;该编号存在&quot;);        &#125; else &#123;            //插入到链表中, temp的后面            heroNode.next = temp.next;            heroNode.pre = temp;            temp.next = heroNode;            temp.next.pre = heroNode;        &#125;    &#125;\n\n修改修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样\n// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样// 只是 节点类型改成 HeroNode2public void update(HeroNode2 newHeroNode) &#123;    // 判断是否空    if (head.next == null) &#123;        System.out.println(&quot;链表为空~&quot;);        return;    &#125;    // 找到需要修改的节点, 根据no编号    // 定义一个辅助变量    HeroNode2 temp = head.next;    boolean flag = false; // 表示是否找到该节点    while (true) &#123;        if (temp == null) &#123;            break; // 已经遍历完链表        &#125;        if (temp.no == newHeroNode.no) &#123;            // 找到            flag = true;            break;        &#125;        temp = temp.next;    &#125;    // 根据flag 判断是否找到要修改的节点    if (flag) &#123;        temp.name = newHeroNode.name;    &#125; else &#123; // 没有找到        System.out.printf(&quot;没有找到 编号 &quot; + newHeroNode.no + &quot; 的节点，不能修改&quot;);    &#125;&#125;\n\n删除\n从双向链表中删除一个节点,\n说明1 对于双向链表，我们可以直接找到要删除的这个节点2 找到后，自我删除即可\n\n// 可以删除// temp.next = temp.next.next;[单向链表]temp.pre.next = temp.next;// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针if (temp.next != null) &#123;    temp.next.pre = temp.pre;&#125;\n\n\n\n\n\n完整代码\npackage com.nie.linkedlist;public class DoubleLinkedListDemo &#123;    public static void main(String[] args) &#123;        HeroNode2 hero1 = new HeroNode2(1, &quot;黎明&quot;);        HeroNode2 hero2 = new HeroNode2(2, &quot;郭富城&quot;);        HeroNode2 hero3 = new HeroNode2(5, &quot;刘德华&quot;);        HeroNode2 hero4 = new HeroNode2(6, &quot;张学友&quot;);        HeroNode2 hero5 = new HeroNode2(9, &quot;张学友&quot;);        //创建链表        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();        //增加结点        //根据插入的顺序进行插入        doubleLinkedList.add(hero1);        doubleLinkedList.add(hero2);        doubleLinkedList.add(hero3);        doubleLinkedList.add(hero4);        doubleLinkedList.list();        doubleLinkedList.addByOrder(hero5);        System.out.println(&quot;按照顺序&quot;);        doubleLinkedList.list();    &#125;&#125;class DoubleLinkedList &#123;    //初始化一个头节点    private HeroNode2 head = new HeroNode2(0, &quot;&quot;);    // 返回头节点    public HeroNode2 getHead() &#123;        return head;    &#125;    // 遍历双向链表的方法    // 显示链表[遍历]    public void list() &#123;        // 判断链表是否为空        if (head.next == null) &#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历        HeroNode2 temp = head.next;        while (true) &#123;            // 判断是否到链表最后            if (temp == null) &#123;                break;            &#125;            // 输出节点的信息            System.out.println(temp);            // 将temp后移， 一定小心            temp = temp.next;        &#125;    &#125;    /*     第二种方式在添加英雄时，根据排名将英雄插入到指定位置   (如果有这个排名，则添加失败，并给出提示)        */    public void addByOrder(HeroNode2 heroNode) &#123;//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)        //因为单链表,我们找的temp是位于添加位置的前一个节点,否则插入失败        HeroNode2 temp = head;        boolean flag = false; // flag标志添加的编号是否存在，默认为false        while (true) &#123;            //说明已经在链表最后了            if (temp.next == null) &#123;                break;            &#125;            ////位置找到，就在temp的后面插入            if (temp.next.no &gt; heroNode.no) &#123;                break;                //说明希望添加的heroNode的编号已然存在            &#125; else if (temp.next.no == heroNode.no) &#123;                flag = true; //说明编号存在                break;            &#125;            temp = temp.next;        &#125;        if (flag) &#123;            System.out.println(heroNode.no + &quot;该编号存在&quot;);        &#125; else &#123;            //插入到链表中, temp的后面            heroNode.next = temp.next;            heroNode.pre = temp;            temp.next = heroNode;            temp.next.pre = heroNode;        &#125;    &#125;    ////添加节点到单向链表    /*    不考虑顺序编号    1.找的当前链表的最后节点    2.将最后这个节点的next指向新的节点     */    public void add(HeroNode2 heroNode) &#123;        //头节点不能动,需要一个辅助遍历temp        HeroNode2 temp = head;        //遍历链表到最后        while (true) &#123;            if (temp.next == null) &#123;                break;            &#125;            //如果没有找的,将temp后移            temp = temp.next;        &#125;        //当退出while循环,temp就指向链表的最后        //将最后这个节点的next指向新的节点        temp.next = heroNode;        heroNode.pre = temp;    &#125;    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样    // 只是 节点类型改成 HeroNode2    public void update(HeroNode2 newHeroNode) &#123;        // 判断是否空        if (head.next == null) &#123;            System.out.println(&quot;链表为空~&quot;);            return;        &#125;        // 找到需要修改的节点, 根据no编号        // 定义一个辅助变量        HeroNode2 temp = head.next;        boolean flag = false; // 表示是否找到该节点        while (true) &#123;            if (temp == null) &#123;                break; // 已经遍历完链表            &#125;            if (temp.no == newHeroNode.no) &#123;                // 找到                flag = true;                break;            &#125;            temp = temp.next;        &#125;        // 根据flag 判断是否找到要修改的节点        if (flag) &#123;            temp.name = newHeroNode.name;        &#125; else &#123; // 没有找到            System.out.printf(&quot;没有找到 编号 &quot; + newHeroNode.no + &quot; 的节点，不能修改&quot;);        &#125;    &#125;    // 从双向链表中删除一个节点,    // 说明    // 1 对于双向链表，我们可以直接找到要删除的这个节点    // 2 找到后，自我删除即可    public void del(int no) &#123;        // 判断当前链表是否为空        if (head.next == null) &#123;// 空链表            System.out.println(&quot;链表为空，无法删除&quot;);            return;        &#125;        HeroNode2 temp = head.next; // 辅助变量(指针)        boolean flag = false; // 标志是否找到待删除节点的        while (true) &#123;            if (temp == null) &#123; // 已经到链表的最后                break;            &#125;            if (temp.no == no) &#123;                // 找到的待删除节点的前一个节点temp                flag = true;                break;            &#125;            temp = temp.next; // temp后移，遍历        &#125;        // 判断flag        if (flag) &#123; // 找到            // 可以删除            // temp.next = temp.next.next;[单向链表]            temp.pre.next = temp.next;            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针            if (temp.next != null) &#123;                temp.next.pre = temp.pre;            &#125;        &#125; else &#123;            System.out.printf(&quot;要删除的 &quot; + no + &quot;节点不存在&quot;);        &#125;    &#125;&#125;class HeroNode2 &#123;    public int no;    public String name;    public HeroNode2 next;//指向下一个结点    public HeroNode2 pre;//指向上一个结点    //构造器    public HeroNode2(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","队列","链表"]},{"title":"javaSE-19-异常","url":"http://example.com/2020/11/16/javaSE19/","content":"异常运行时,由于各种原因导致的不能正常运行,使用java语言异常处理机制,控制的,后面代码可以正常运行的\n广义 所有的异常侠义  运行时异常,可以处理的\n异常可分类:根据在程序中执行所发正的异常可分类\n\nEroor:针对虚拟机无法解决的严重问题 jvm系统内部错误,资源耗尽,不能针对代码进行处理\n\nException   编程错误或偶然的错误, 空指针,下标越界,读取不存在文件,\n网络中断使用java语言异常处理机制,控制的,后面代码可以正常运行的\n \n\n\n\n处理方式:针对异常,一般两种解决方式:\n\n终止程序,\n\n在感受到异常的时候,就应该检测到异常,异常提示等处理\n异常处理\n\n\n\n​      jvm默认异常处理方式:在控制台抛出对应类型的异常类对象(异常信息),​           终止JVM运行\n也可以使用异常处理机制来处理\n\n捕获异常最理想的是在编译期间,有的在运行时才能得到\n\n编译时异常\n运行时异常\n\n常见的异常\n数组索引越界异常ArrayIndexOutOfBoundsException\n类型转换异常ClassCastException\n算术异常ArithmeticException\n数字格式化转换异常NumberFormatException\n控制指针已成. 空指针异常NullPointerException\n\n\n\n案例数组索引越界异常ArrayIndexOutOfBoundsException\n//用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。//ArrayIndexOutOfBoundsException//.数组索引越界异常int[] a = new int[5];a[5] = 1;\n\n\n\n类型转换异常ClassCastException\n//当试图将对象强制转换为不是实例的子类时，抛出该异常。例如，以下代码将生成一个// ClassCastException：//类转换异常Object x = new Integer(0);System.out.println((String)x);String s=&quot;saad&quot;;Object obj=s;Integer j= (Integer) obj;\n\n\n\n算术异常ArithmeticException\n&#x2F;&#x2F;算术异常&#x2F;&#x2F;当出现异常的运算条件时，抛出此异常&#x2F;&#x2F;ArithmeticExceptionint a&#x3D;10;int b&#x3D;0;System.out.println(a&#x2F;0);\n\n\n\n数字格式化转换异常NumberFormatException\n//数字格式化异常//NumberFormatException//当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。int i = Integer.parseInt(&quot;afasf&quot;);\n\n\n\n控制指针已成. 空指针异常NullPointerException\n&#x2F;&#x2F;控制指针异常&#x2F;&#x2F;NullPointerException&#x2F;&#x2F;当应用程序试图在需要对象的地方使用 null 时，抛出该异常String s&#x3D;null;s.length();\n\n异常体系结构\n\n\n\ntry-catch\ntry-执行可能产生 异常的代码\n\ncatch-捕获异常\n\n\ntry&#123;         //可能出现异常的类型         //尽可能最少     &#125;catch (异常类型)&#123;     //当try出现异常,执行catch &#125;\n\nint a = 10;int b = 0;try &#123;    System.out.println(a / 0);    &#125; catch (ArithmeticException e) &#123;    System.out.println(&quot;算数异常:除数不饿能为零&quot;);&#125;//输出:算数异常:除数不饿能为零\n\ntry catch 嵌套注意:有异常   下面的try 跳过 直接运行 对应的catch\ntry &#123;        System.out.println(a / 0);//有异常   下面的try 跳过 直接运行 对应的catch        try &#123;            String s = null;//有异常            s.length();        &#125; catch (NullPointerException n) &#123;            System.out.println(&quot;空&quot;);        &#125;    &#125; catch (ArithmeticException e) &#123;        System.out.println(&quot;算数异常:除数不饿能为零&quot;);&#125;//输出:算数异常:除数不饿能为零\n\n一个try可以对应及格catch有多个异常   下面的try 跳过下面 直接到对应的  直接运行  对应的catch\ntry &#123;    System.out.println(a / 0);//有多个异常   下面的try 跳过下面 直接到对应的  直接运行  对应的catch    System.out.println(&quot;111111&quot;);    String s = null;    s.length();    System.out.println(&quot;222222&quot;);    &#125; catch (ArithmeticException e) &#123;    System.out.println(&quot;算数异常:除数不饿能为零&quot;);    &#125; catch (NullPointerException n) &#123;    System.out.println(&quot;空指针异常&quot;);&#125;\n\ncatch (类型 a)\n编程人员知道具体错误时候用  catch (NullPointerException n)\n不知道具体错误可用具体错误的父类Exception即catch (Exception e) \n\ncatch中没有对应的异常类型catch中没try()有对应的异常类型.jvm也会停止,直接停止运行  进行提示报错\ntry &#123;        System.out.println(a / 2);//有多个异常   下面的try 跳过下面 直接到对应的  直接运行  对应的catch        Integer.parseInt(&quot;frf&quot;);//catch中没有对应的异常类型.jvm也会停止  进行提示报错    &#125; catch (ArithmeticException e) &#123;        System.out.println(&quot;算数异常:除数不饿能为零&quot;);    &#125; catch (NullPointerException n) &#123;        System.out.println(&quot;空指针异常&quot;);    &#125;    System.out.println(&quot;aaaaa&quot;);\n\n输出:\n\n\ngetMessage()parintStackTrace\ngetMessage() 获取异常信息,返回字符串\nparintStackTrace 获取异常类名和异常信息,以及异常出现在程序中的位置.返回值未void\n\ncatch (Exception e) &#123;    System.out.println(&quot;系统繁忙&quot;);//给用户提示    System.out.println(e.getMessage());//程序人员自己看 后期可使用第三方日志组件,向文件中输出信息    e.printStackTrace();//打印异常信息到控制台&#125;\n\n\n\n\n当有catch   有  return时候  执行catch中的reatch 以及finally最终执行\n当finally有return,后面全不执行\n当有异常时 返回值 异常的return ; 和finally的return;  均会执行 但是执行的结果值执行 finally return\n\n   public static int test1() &#123;        int a = 10;        int b = 0;        int c = 1;        /*        一个try 对应多个catch         */        try &#123;            System.out.println(a / 0);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;算数异常:除数不饿能为零&quot;);            return ++c;        &#125; finally &#123;            System.out.println(&quot;222222&quot;);            return ++c;    //当finally有return,后面全不执行            //当有异常时 返回值 异常的return ; 和finally的return;  均会执行 但是执行的结果值执行 finally return        &#125;//        System.out.println(&quot;333333&quot;);//        return 2;    &#125;\n\n输出:\n算数异常:除数不饿能为零2222223\n\nthrows\nthrows声明此方法可能会出现算数异常,  声明的如果是运行时异常,调用时可以不处理,而交给方法调用处进行处理。\npublic void test  throws  异常1，异常2，异常3&#123;   &#125;\n\n任何方法都可以使用throws关键字声明异常类型，包括抽象方法。\n\n子类重写父类中的方法，子类方法不能声明抛出比父类类型更大的异常。\n\n使用了throws的方法，调用时必须处理声明的异常，要么使用try-catch，要么继续使用throws声明。\n\n\n案例1\npackage com.nie.day1;import java.text.ParseException;public class Demo08 &#123;    public static void main(String[] args) &#123;//        chu(2, 0);        try &#123;            chu(2, 0);        &#125; catch (ArithmeticException a) &#123;            System.out.println(&quot;算数异常&quot;);        &#125;        System.out.println(&quot;主线程后面的代码,可以继续执行&quot;);        try &#123;            test();//在此处的调用处,就需要try catch 处理        &#125; catch (ParseException e) &#123;            e.printStackTrace();            System.out.println(&quot;系统忙&quot;);        &#125;    &#125;    /**     * 除法运算  throws声明此方法可能会出现算数异常     * 声明如果是运行时异常,调用时可以不处理     *     * @param a     * @param b     * @return     * @throws ArithmeticException     */    public static int chu(int a, int b) throws ArithmeticException &#123;        return a / b;    &#125;    public static void test() throws ParseException &#123;//编译器异常        test1();//调用,不处理 用throws ParseException 继续抛出    &#125;    public static void test1() throws ParseException, UnknownError &#123;        System.out.println(&quot;test2&quot;);    &#125;&#125;\n\n\n\n子类重写父类中的方法，子类方法不能声明抛出比父类类型更大的异常\npublic abstract class Demo09 &#123;    public abstract void test1() throws ParseException;    public abstract void test2() throws ArithmeticException;&#125;\n\npackage com.nie.day1;import java.text.ParseException;public class Demo09Child extends Demo09 &#123;    //子类重写父类中的方法，子类方法不能声明抛出比父类类型更大的异常    @Override    public void test1() throws ParseException &#123;    &#125;    @Override    public void test2() throws ArithmeticException &#123;    &#125;&#125;\n\nthrow\n\nthrow关键字用于显示抛出异常,抛出的时候是抛出的是一个异常类的实力化对象\n在异常处理中,try语句要捕获的是一个异常对象,那么此异常对象也可以自己抛出\n\npublic static void someMethod() &#123;if (1==1) &#123;    throw new RuntimeException(&quot;错误原因&quot;);&#125;&#125;\n\n使用throw用于方法体中，用来抛出一个实际的异常对象，使用throw后要么使用try catch捕获异常，要么使用throws声明异常\npackage com.nie.day1;public class Demo11 &#123;    /*    throw用于方法体中，用来抛出一个实际的异常对象，使用throw后    要么使用try catch捕获异常，要么使用throws声明异常     */        public static void main(String[] args) &#123;        try &#123;            c(1111);        &#125; catch (RuntimeException r) &#123;            System.out.println(r.getMessage());        &#125;    &#125;    public static int c(int a) throws RuntimeException &#123;        if (a &gt;= 10) &#123;            throw new RuntimeException(&quot;不及格&quot;);        &#125;        return a;    &#125;&#125;\n\n自定义异常自定义异常就是自己定义的异常类,也就是API中标准异常类的直接或者间接的子类\n作用:用自定义的异常标记业务逻辑的异常,避免与标准混淆\n使用\n基本语法\npublic  class 异常类名 extends Exception/RuntimeException&#123;        public 异常类名(String msg)&#123;            super(msg);       &#125; &#125;\n\n自定义异常类中往往不写其他方法，只重载需要使用的构造方法\n\n继承Exception,在方法中使用throw抛出后,必须在方法中try-catch或throws抛出\n\n\npackage com.nie.day1;public class Demo10  &#123;    public static void main(String[] args) &#123;                try &#123;            c(1111) ;        &#125; catch (ScoreException e) &#123;            e.printStackTrace();            System.out.println(e.getMessage());        &#125;        System.out.println(&quot;----&quot;);    &#125;    public  static int c(int a) throws ScoreException&#123;        if (a&gt;=10)&#123;            throw new ScoreException(&quot;不及格&quot;);        &#125;        return a;    &#125;&#125;\n\n当分数不满足条件时,抛出此对象\npublic class ScoreException extends Exception &#123;    public ScoreException() &#123;        super();    &#125;    public ScoreException(String message) &#123;        super(message);    &#125;&#125;\n\n\n总结throws\n作为子啊方法的声明,此方法可能会出现异常,\nthrows后面声明多个异常类型,多为编译期异常\n\nthrow\n在方法体中主动抛出异常对象,想当于程序出现异常的情况,后面的程序不执行\n在不满足条件的情况下以抛出异常的形式告诉调用处\n\n参考throws与throw\nthrows\nthrows：用来声明一个方法可能产生的所有异常，不做任何处理而是将异常往上传，谁调用我我就抛给谁。\n用在方法声明后面，跟的是异常类名\n可以跟多个异常类名，用逗号隔开\n表示抛出异常，由该方法的调用者来处理\nthrows表示出现异常的一种可能性，并不一定会发生这些异常\n\nthrow\nthrow：则是用来抛出一个具体的异常类型。\n用在方法体内，跟的是异常对象名\n只能抛出一个异常对象名\n表示抛出异常，由方法体内的语句处理\nthrow则是抛出了异常，执行throw则一定抛出了某种异常  \n\n\n\n自定义异常\n由于java中封装的异常类都是与语法相关的\n在我们业务中出现一些不满足条件的情况时,也可以自定义异常类,来表示某种情况\n\n","categories":["-javase"],"tags":["基础","java","异常"]},{"title":"javaSE-18-Date类-math类","url":"http://example.com/2020/11/16/javaSE18/","content":"时间Date类使用Date类代表当前系统时间         Date d = new Date();         Date d = new Date(long  d);\nDate d &#x3D; new Date();System.out.println(d);Fri Nov 13 13:59:48 CST 2020\n\n获得当前日期距离1970-1-1 00:00:00 经过的毫秒数\n  \n\nlong millis = System.currentTimeMillis(); System.out.println( millis );Date date=new Date();System.out.println(date.getTime());\n\n\n\n根据毫秒数创建Date对象\nDate date2 = new Date(millis);System.out.println( date2 ); \t\t//Fri Nov 13 14:09:48 CST 2020\n\n根据当前时间加一天\ndate2 = new Date(millis + 1000*60*60*24);System.out.println( date2 );\n\n输出\nFri Nov 13 14:08:24 CST 2020Sat Nov 14 14:08:24 CST 2020\nCalendar类\nCalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\nCalendar c = Calendar.getInstance();//GregorianCalendar返回子类对象\n\nSystem.out.println(c.get(Calendar.YEAR));//年System.out.println(c.get(Calendar.MONTH)+1);//月份System.out.println(c.get(Calendar.DATE));//多少号System.out.println(c.get(Calendar.DAY_OF_YEAR));//一年的多少天System.out.println(c.get(Calendar.DAY_OF_WEEK));//一周中的第几天System.out.println(c.get(Calendar.SECOND));2020111331865\n\nSimpleDateFormat类SimpleDateFormat日期格式化类\n可以把日期转换为指定的格式\n//可以把日期转换为指定的格式Date date3=new Date();//yyyy年MM月dd日 HH:mm:ss 格式输出SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);System.out.println( sdf.format(date3) );   \n\n输出:2020年11月13日 14:14:13\n把日期字符串转换为Date对象\n注意:格式必须匹配\nString text = &quot;2020-11-13 14:16:15&quot;;//格式必须匹配sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);date = sdf.parse(text);System.out.println( date );\n\n输出:Fri Nov 13 14:16:15 CST 2020\nmath类Math.random()Math.random(), 可以生成[0.0 , 1.0 )范围内的随机小数\nRandom random = new Random();\n\nrandom.nextDouble() 随机小数\nrandom.nextInt() 随机整数\nrandom.nextInt(100) 在[0,100)之间随机整数\n\nRandom random = new Random();//产生10个随机小数for(int i=1; i&lt;=10; i++)&#123;System.out.println( random.nextDouble() );&#125;System.out.println(&quot;------------------&quot;);//产生10个随机整数for(int i=1; i&lt;=10; i++)&#123;System.out.println( random.nextInt());&#125;System.out.println(&quot;------------------&quot;);//产生10个随机整数,在[0,100)之间for(int i=1; i&lt;=10; i++)&#123;System.out.println( random.nextInt(100));&#125;\n\nBigInteger类型BigInteger类型   的数字范围较Integer，Long类型的数字范围要大得多，它支持任意精度\nBigDecimal类型BigDecimal类 如果运算的精度要求比较高, 使用BigDecimal类\n\nadd()，\nsubtract()，\nmultiply()，\ndivide() \n\nBigDecimal bd1 = new BigDecimal(&quot;123468549878979453131548674987897651321654897897894313.123&quot;);BigDecimal bd2 = new BigDecimal(&quot;1234685498779453131548674987897651321654897897894313.123&quot;);BigDecimal result = bd1.add(bd2);System.out.println(result);result = bd1.subtract(bd2);        //相减result = bd1.multiply(bd2);        //相乘//相除时,可以会出现除不断的情况,可能会出现算术异常//\t\tresult = bd1.divide(bd2);result = bd1.divide(bd2, RoundingMode.DOWN);        //尾数的处理方式System.out.println(result);\n\nRoundingMode根据给定的舍入模式将输入数字舍入为一位数的结果\n\n\n\n输入数字\nUP\nDOWN\nCEILING\nFLOOR\nHALF_UP\nHALF_DOWN\nHALF_EVEN\nUNNECESSARY\n\n\n\n5.5\n6\n5\n6\n5\n6\n5\n6\n抛出 ArithmeticException\n\n\n2.5\n3\n2\n3\n2\n3\n2\n2\n抛出 ArithmeticException\n\n\n1.6\n2\n1\n2\n1\n2\n2\n2\n抛出 ArithmeticException\n\n\n1.1\n2\n1\n2\n1\n1\n1\n1\n抛出 ArithmeticException\n\n\n1.0\n1\n1\n1\n1\n1\n1\n1\n1\n\n\n-1.0\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n\n\n-1.1\n-2\n-1\n-1\n-2\n-1\n-1\n-1\n抛出 ArithmeticException\n\n\n-1.6\n-2\n-1\n-1\n-2\n-2\n-2\n-2\n抛出 ArithmeticException\n\n\n-2.5\n-3\n-2\n-2\n-3\n-3\n-2\n-2\n抛出 ArithmeticException\n\n\n-5.5\n-6\n-5\n-5\n-6\n-6\n-5\n-6\n抛出 ArithmeticException\n\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"javaSE-17-Arrays类","url":"http://example.com/2020/11/16/javaSE17/","content":"Arrays类java.util.Arrays类\n用于操作数组工具类,里面定义了常见操作数组的静态方法\nequals\n比较两个非同一数组是否相等，而数组本身的equals判断另一个数组是否它本身。\n\n声明：public static boolean equals(type[]a,type[]a2)\n\n参数的类型可以是原生数据类型和引用类型的任意一种类型。\n\n返回：如果两个相等，则返回true，否则返回false\n \n\n\n\nint[] a=&#123;1,2,3&#125;;int[] b=&#123;1,2,3&#125;;System.out.println(Arrays.equals(a,b));System.out.println(a==b);\n\n输出  true false\n源码\npublic static boolean equals(int[] a, int[] a2) &#123;if (a==a2)return true;if (a==null || a2==null)return false;int length = a.length;if (a2.length != length)return false;for (int i=0; i&lt;length; i++)if (a[i] != a2[i])return false;return true;&#125;\n\nsort －排序public static void main(String[] args) &#123;    int [] a = &#123;3,4,1,7,5,2&#125;;    Arrays.sort(a);//对整个数组 升序排列 底层使用快速排序法    Arrays.sort(a,0,4);//对数组指定区间排序  包含开始,不包含结束位置    Integer[] b = &#123;3,4,1,7,5,2&#125;;    Arrays.sort(b);    System.out.println(Arrays.toString(b));    String[] s = &#123;&quot;c&quot;,&quot;a&quot;,&quot;d&quot;,&quot;b&quot;&#125;;    Arrays.sort(s);    System.out.println(Arrays.toString(s));&#125;\n\ncompareTo自定义对象排序自定义类实现Comparable接口重写compareTo方法\n主类StuDemo\npackage day3;import java.util.Arrays;public class StuDemo &#123;    public static void main(String[] args) &#123;        Stu s0 = new Stu(&quot;dd&quot;, 2);        Stu s1 = new Stu(&quot;td&quot;, 5);        Stu s2 = new Stu(&quot;4d&quot;, 3);        Stu s3 = new Stu(&quot;yd&quot;, 1);        Stu[] stu = &#123;s0, s1, s2, s3&#125;;        Arrays.sort(stu);        System.out.println(Arrays.toString(stu));        String[] s = &#123;&quot;e&quot;, &quot;w&quot;, &quot;wq&quot;, &quot;e&quot;&#125;;        Arrays.sort(s);        System.out.println(Arrays.toString(s));        System.out.println(&quot;++++++&quot;);        //调用专门为学生类提供排序功能        Arrays.sort(stu, new StudentSort());        System.out.println(Arrays.toString(stu));        System.out.println();    &#125;    /*      在Arrays类中,SORT方法中,       */&#125;\n\npackage day3;//排序接口public class Stu implements Comparable&lt;Stu&gt; &#123;    private String name;    private Integer num;    /**     * 在Arrays类中的sort方法在排序比较时每次会调用compareTo方法     * 自定义排序规则     */    @Override    public int compareTo(Stu Stu2) &#123;//        return this.num - Stu2.num;//第一个减第二个,升序//        return Stu2.num-this.num ;//第二个减第一个 降序//        return this.name.compareTo(Stu2.name);//升序,只能字符        return this.num.compareTo(Stu2.num);//不同用int    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getNum() &#123;        return num;    &#125;    public void setNum(Integer num) &#123;        this.num = num;    &#125;    public Stu(String name, int num) &#123;        this.name = name;        this.num = num;    &#125;    @Override    public String toString() &#123;        return &quot;Stu&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, num=&quot; + num +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n//调用专门为学生类提供排序功能\npackage day3;import java.util.Comparator;//调用专门为学生类提供排序功能class StudentSort implements Comparator&lt;Stu&gt; &#123;    @Override    public int compare(Stu o1, Stu o2) &#123;        return o2.getNum()-o1.getNum();//降序    &#125;&#125;\n\nbinarySearch -使用二分搜索算法搜索指定数组二分查找 , 找到对应的下标\nint index = Arrays.binarySearch(a, 6);System.out.println(index);\n\n根据范围进行查找\n\n二分查找法\n必须是有序的\n\n//根据范围进行查找            开始  结束  需要找的数值index = Arrays.binarySearch(a, 3, 5, 5);\n\n\n\npublic class Search &#123;    /**     * 二分查找法     * 必须是有序的     *     * @param args     */    public static void main(String[] args) &#123;        int[] a = &#123;1, 5, 2, 6, 2, 5&#125;;        //必须排序后 进行查找 二分查找法        Arrays.sort(a);        //二分查找 , 找到对应的下标        int index = Arrays.binarySearch(a, 6);        System.out.println(index);        //根据范围进行查找                开始        结束        需要找的数值        index = Arrays.binarySearch(a, 3, 5, 5);    &#125;&#125;\n\n重写二分查找\npackage day3;import java.util.Arrays;public class Search1 &#123;    public static void main(String[] args) &#123;        int[] a = &#123;2, 2, 5, 645, 7, 83, 3&#125;;        Arrays.sort(a);        Search1.sort(a, 77);    &#125;    private static void sort(int[] a, int key) &#123;        int low = 0;        int high = a.length - 1;        while (low &lt;= high) &#123;            int mid = (low + high) &gt;&gt;&gt; 1;//除二            int midVal = a[mid];            if (midVal &lt; key) &#123;                low = mid + 1;            &#125; else if (midVal &gt; key) &#123;                high = mid - 1;            &#125; else &#123;                System.out.println(mid);                return;            &#125;        &#125;        System.out.println(-1);  // key not found.    &#125;&#125;","categories":["-javase"],"tags":["基础","java","包装类"]},{"title":"合并两个有序链表-021","url":"http://example.com/2020/11/13/LC021-合并两个有序链表/","content":"21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n示例：\n输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n方法一:递归什么是递归呢？函数在运行时调用自己，这个函数就叫递归函数，调用的过程叫做递归。比如定义函数 f(x)=x+f(x-1)f(x)=x+f(x−1)：\n\n递归函数必须要有终止条件，否则会出错；\n递归函数先不断调用自身，直到遇到终止条件后进行回溯，最终返回答案。\n\n思路  \n\n\n终止条件：当两个链表都为空时，表示我们对链表已合并完成。\n如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）\n\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;    //当两个链表都为空时，表示我们对链表已合并完成。      if (l1 == null) &#123;          return l2;      &#125;      if (l2 == null) &#123;          return l1;      &#125; else if (l1.val &lt; l2.val) &#123;          //较小结点的 next 指针指向其余结点的合并结果。（调用递归）          l1.next = mergeTwoLists(l1.next, l2);          return l1;      &#125; else &#123;          l2.next = mergeTwoLists(l1, l2.next);          return l2;      &#125;  &#125;\n\n方法二：迭代思路\n一个 temp指针，我们需要做的是调整它的 next 指针。\n重复以下过程，直到 l1 或者 l2 指向了 null ：\n\n如果 l1 当前节点的值小于等于 l2 ，\n就把 l1 当前的节点接在 temp 节点的后面同时将 l1 指针往后移一位。\n否则，我们对 l2 做同样的操作。\n不管我们将哪一个元素接在了后面，我们都需要把temp 向后移一位。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。\n    //设置一个新链表    ListNode listNode = new ListNode();    //用temp进行遍历    ListNode temp = listNode;    while (l1 != null || l2 != null) &#123;        if (l1.val &gt; l2.val) &#123;            temp.next = l2;            l2 = l2.next;        &#125; else &#123;            //就把 l1 当前的节点接在 temp 节点的后面同时将 l1 指针往后移一位。            temp.next = l1;            l1 = l2.next;        &#125;        temp = temp.next;    &#125;    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可    temp.next = (l1 == null ? l2 : l1);    return listNode.next;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","递归"]},{"title":"删除链表倒数n节点-019","url":"http://example.com/2020/11/13/LC019-删除链表倒数n节点/","content":"19. 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.\n\n方法一：栈\n常规思维 算链表长度，然后再找倒数第n个。\n\n栈 先压栈，然后弹栈，弹n个\n \n\n双指针，预制位置，j 在 i后面 n的位置，然后两个指针同时移动，就能找到倒数第n个位置\n\nListNode pre = stack.peek();\npre.next = pre.next.next;\n\n\npublic ListNode removeNthFromEnd(ListNode head, int n) &#123;    //创建一个新链表    ListNode listNode = new ListNode(0, head);    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();    //创建一个辅助变量    ListNode temp = listNode;    while (temp != null) &#123;        //将全部压入栈中        stack.push(temp);        temp = temp.next;    &#125;    for (int i = 0; i &lt; n; i++) &#123;        //弹出栈顶        stack.pop();    &#125;    //返回栈顶元素    ListNode pre = stack.peek();    pre.next = pre.next.next;    ListNode ans = listNode.next;    return ans;&#125;\n\n方法二：计算链表长度\n首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。\n\n为了与题目中的 n保持一致，节点的编号从 11 开始，头节点为编号 11 的节点\n\n当遍历到第 L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。\n\nListNode pre = stack.peek();\npre.next = pre.next.next;\n\n\n代码:\npublic ListNode removeNthFromEnd(ListNode head, int n) &#123;    ListNode pre = new ListNode(0, head);    int length = getLength(head);    ListNode cur = pre;    for (int i = 1; i &lt; length - n + 1; i++) &#123;        cur = cur.next;    &#125;    cur.next = cur.next.next;    ListNode ans = pre.next;    return ans;&#125;public int getLength(ListNode head) &#123;    int length = 0;    while (head != null) &#123;        length++;        head = head.next;    &#125;    return length;&#125;\n\n","categories":["-算法"],"tags":["链表","LeetCode","栈"]},{"title":"二分查找扩展(搜索旋转排序数组)-033-081-153-154","url":"http://example.com/2020/11/13/LC031-081-153-154-二分查找扩展/","content":"33. 搜索旋转排序数组给你一个升序排列的整数数组 nums ，和一个整数 target 。\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。\n请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n示例 1：\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0输出：4\n\n\n示例 2：\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3输出：-1\n\n思路利用二分法\n  \n\n题目要求时间复杂度 O(logn)，显然应该使用二分查找。二分查找的过程就是不断收缩左右边界，而怎么缩小区间是关键。\n如果数组[未旋转],在此数组中找一个特定的元素target 的过程\n\n若target==nums[mid] 直接返回\n若target&lt;nums[mid],则target位于左侧区间[left,mid)中,经right=mid-1;在左侧区间查找\n若target&gt;nums[mid],则target位于左侧区间(left,mid]中,经left = mid+1在左侧区间查找\n\n由于数组「被旋转」，所以左侧或者右侧区间不一定是连续的\n当元素不重复时,如果 nums[i] &lt;= nums[j],说明区间说明区间 [i,j] 是「连续递增」的。\ni、j 可以重合，所以这里使用的比较运算符是「小于等于」\n因此，在旋转排序数组中查找一个特定元素时：\n\n若 target == nums[mid]，直接返回\n\n若 nums[left] &lt;= nums[mid]，说明左侧区间 [left,mid]「连续递增」。此时：\n\n若 nums[left] &lt;= target &lt;= nums[mid]，说明 target 位于左侧。令 right = mid-1，在左侧区间查找\n\n否则，令 left = mid+1，在右侧区间查找\n\n\n\n否则，说明右侧区间 [mid,right]「连续递增」。此时：\n\n若 nums[mid] &lt;= target &lt;= nums[right]，说明 target 位于右侧区间。令 left = mid+1，在右侧区间查找\n\n否则，令 right = mid-1，在左侧区间查找注意：区间收缩时不包含 mid，也就是说，实际收缩后的区间是 [left,mid) 或者 (mid,right]\n\n\n\n\n例图:\n\n\nclass Solution &#123;    public int search(int[] nums, int target) &#123;  int n = nums.length;        int left = 0;        int right = n - 1;        if (n == 0) &#123;            return -1;        &#125;        if (n == 1) &#123;            return nums[0] == target ? 0 : -1;        &#125;        while (left &lt;= right) &#123;            int mid = (left + right) &gt;&gt; 1;            // 等号：考虑 left==right，即只有一个元素的情况            if (nums[mid] == target) &#123;                return mid;            &#125;            // [left,mid] 连续递增            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;                    // 加等号，因为 left 可能是 target                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                // [mid,right] 连续递增                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) &#123;                    // 加等号，因为 right 可能是 target                    // 在右侧 (mid,right] 查找                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        System.out.println(&quot;未找到&quot;);        return -1;    &#125; &#125;\n\n81.搜索旋转排序数组-ii 搜索旋转排序数组 II\n难度中等242\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。\n编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。\n示例 1:\n输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0输出: true\n\n示例 2:\n输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3输出: false\n\n道题是 33 题的升级版，元素可以重复。当 nums[left] == nums[mid] 时，无法判断 target 位于左侧还是右侧，此时无法缩小区间，退化为顺序查找。\nleft++，去掉一个干扰项，本质上还是顺序查找：\nif nums[left] == nums[mid] {    left++    continue}\n代码\npublic boolean search(int[] nums, int target) &#123;       int n &#x3D; nums.length;       int left &#x3D; 0;       int right &#x3D; n - 1;       if (n &#x3D;&#x3D; 0) &#123;           return false;       &#125;       if (n &#x3D;&#x3D; 1) &#123;           return nums[0] &#x3D;&#x3D; target ? true : false;       &#125;       while (left &lt;&#x3D; right) &#123;           int mid &#x3D; left + (right - left) &gt;&gt; 1;           if (nums[mid] &#x3D;&#x3D; target) &#123;               return true;           &#125;           if (nums[left] &#x3D;&#x3D; nums[mid]) &#123;               left++;               continue;           &#125;           &#x2F;&#x2F;前半部分有序           if (nums[left] &lt;&#x3D; nums[mid]) &#123;               &#x2F;&#x2F;target在前半部分               if (nums[left] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid]) &#123;                   right &#x3D; mid - 1;               &#125; else &#123;                   left &#x3D; mid + 1;               &#125;           &#125; else &#123;               &#x2F;&#x2F;后半部分有序               &#x2F;&#x2F;target在后半部分               if (nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[n - 1]) &#123;                   left &#x3D; mid + 1;               &#125; else &#123;                   right &#x3D; mid - 1;               &#125;           &#125;       &#125;       return false;   &#125;\n\n\n\n\n\n153. 寻找旋转排序数组中的最小值难度中等293\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。\n请找出其中最小的元素。\n示例 1：\n输入：nums &#x3D; [3,4,5,1,2]输出：1\n\n示例 2：\n输入：nums &#x3D; [4,5,6,7,0,1,2]输出：0\n\n\n\n方法一class Solution &#123;    public int findMin(int[] nums) &#123;         int n=nums.length;        int left=0;        int right=n-1;        if (n==0)&#123;            return -1;        &#125;        if (n==1)&#123;            return nums[0];        &#125;        while (left&lt;=right)&#123;// 实际上是不会跳出循环，当 left==right 时直接返回             if (nums[left]&lt;=nums[right])&#123;// 如果 [left,right] 递增，直接返回                return nums[left];            &#125;             int mid=(left+right)&gt;&gt;1;            if (nums[left]&lt;=nums[mid])&#123;// [left,mid] 连续递增，则在 [mid+1,right] 查找                left=mid+1;            &#125;else &#123;                right=mid;// [left,mid] 不连续，在 [left,mid] 查找            &#125;        &#125;        return -1;    &#125;&#125;\n\n方法二int left=0;   int right=nums.length-1;   while(right&gt;left)   &#123;       int mid=left+(right-left)/2;       if(nums[mid]&gt;nums[right])           left=mid+1;       else           right=mid;   &#125;   return nums[left];\n\n154. 寻找旋转排序数组中的最小值 II假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n请找出其中最小的元素。\n注意数组中可能存在重复的元素。\n示例 1：\n输入: [1,3,5]输出: 1示例 2：输入: [2,2,2,0,1]输出: 0\n\n\n\nclass Solution &#123;    public int findMin(int[] nums) &#123;       int n = nums.length;        int left = 0;        int right = n - 1;        if (n == 0) &#123;            return -1;        &#125;        if (n == 1) &#123;            return nums[0];        &#125;        while (left &lt;= right) &#123;            // 实际上是不会跳出循环，当 left==right 时直接返回        // 这里增加判断 ↓↓↓            if (nums[left] &lt; nums[right] || left == right) &#123;// 如果 [left,right] 递增，直接返回                return nums[left];            &#125;            int mid =(right + left) &gt;&gt; 1;            if (nums[left] == nums[mid]) &#123;                left++;// 无法判断 mid 位于哪一部分，去掉干扰项//有重复的值                   &#125;          else if (nums[left] &lt; nums[mid]) &#123;              // [left,mid] 连续递增，则在 [mid+1,right] 查找                left = mid + 1;            &#125; else &#123;                right = mid;            &#125;        &#125;        return -1;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","二分查找"]},{"title":"数据结构和算法--004--链表","url":"http://example.com/2020/11/10/B站数据结构004/","content":"链表链表是有序的列表， 但是它在内存中是存储如下  \n\n链表是以节点的方式来储存.链式储存\n每个节点包含data 域， next 域： 指向下一个节点  \n如图： 发现链表的各个节点不一定是连续存储.  \n链表分带头节点的链表和没有头节点的链表， 根据实际的需求来确定  \n\n单链表(带头结点) 逻辑结构示意图如下  \n  \n\n\n\n\n\n\n\n单链表的应用实例第一种方法在添加英雄时， 直接添加到链表的尾部不考虑顺序编号\n\n找的当前链表的最后节点\n将最后这个节点的next指向新的节点\n将最后这个节点的next指向新的节点      temp.next = heroNode;\n\npublic void add(HeroNode heroNode) &#123;      //头节点不能动,需要一个辅助遍历temp      HeroNode temp = head;      //遍历链表到最后      while (true) &#123;          if (temp.next == null) &#123;              break;          &#125;          //如果没有找的,将temp后移          temp = temp.next;      &#125;      //当退出while循环,temp就指向链表的最后      //将最后这个节点的next指向新的节点      temp.next = heroNode;  &#125;\n\n\n\n第二种方式在添加英雄时，根据排名将英雄插入到指定位置\n因为头节点不能动，因此我们仍然通过一个辅助指针(变量)\n因为单链表,我们找的temp是位于添加位置的前一个节点,否则插入失败\ntemp = temp.next;\n插入到链表中, temp的后面\nheroNode.next = temp.next;\ntemp.next = heroNode;\n\n   HeroNode temp = head;    boolean flag = false; // flag标志添加的编号是否存在，默认为false    while (true) &#123;        //说明已经在链表最后了        if (temp.next == null) &#123;            break;        &#125;        ////位置找到，就在temp的后面插入        if (temp.next.no &gt; heroNode.no) &#123;            break;            //说明希望添加的heroNode的编号已然存在        &#125; else if (temp.next.no == heroNode.no) &#123;            flag = true; //说明编号存在            break;        &#125;        temp = temp.next;    &#125;    if (false) &#123;        System.out.println(heroNode.no + &quot;该编号存在&quot;);    &#125; else &#123;        //插入到链表中, temp的后面        heroNode.next = temp.next;        temp.next = heroNode;    &#125;&#125;\n\n\n\n\n\n修改节点的信息\n根据 newHeroNode 的 no 来修改即可\n找到需要修改的节点, 根据no编号定义一个辅助变量\n找到该节点\n根据flag 判断是否找到要修改的节点\ntemp.name = newHeroNode.name;\n\n//修改节点    public void update(HeroNode heroNode) &#123;        if (head.next == null) &#123;            System.out.println(&quot;此节点为空&quot;);            return;        &#125;        //找到要修改的节点,根据no修改        //定义一个辅助变量        HeroNode temp = head;        boolean flag = false;//表示是否找到该节点        while (true) &#123;            if (temp == null) &#123;                break;//遍历完毕            &#125;            if (temp.no == heroNode.no) &#123;                //找到                flag = true;                break;            &#125;            temp = temp.next;        &#125;        //根据flag判断是否是要修改的节点        if (flag) &#123;            temp.name = heroNode.name;        &#125; else &#123;            System.out.println(&quot;没有找到要修改的编号&quot; + heroNode.no);        &#125;    &#125;\n\n\n\n\n\n删除节点\nhead 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点\n说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较\n遍历链表,找到对应的链表\ntemp.next = temp.next.next;\n\n1.head不能动,需要一个辅助变量temp 辅助节点找到要删除的节点   1.我们在比较的时候只需要找到temp.next.no 和要需要的no作比较    */   public void del(int no) &#123;       //找到要修改的节点,根据no修改       //定义一个辅助变量       HeroNode temp = head;       boolean flag = false;// 标志是否找到待删除节点的       while (true) &#123;           if (temp.next == null) &#123; //已经到链表的最后               break;//遍历完毕           &#125;           if (temp.next.no == no) &#123;               //找到的待删除节点的前一个节点temp               flag = true;               break;           &#125;           temp = temp.next;       &#125;       if (flag) &#123;           temp.next = temp.next.next;       &#125; else &#123;           System.out.println(&quot;要删除的节点不在&quot; + no);       &#125;   &#125;\n\n\n\n\n\n\n\n获取到单链表的节点个数(不统计头节点)\n定义一个辅助变量\ncur = cur.next;//遍历\n\npublic static int getLength(HeroNode head) &#123;    if (head.next == null) &#123;        return 0;    &#125;    int length = 0;    //定义一个辅助变量    HeroNode cur = head.next;    while (cur != null) &#123;        length++;        cur = cur.next;//遍历    &#125;    return length;&#125;\n\n查找单链表中的倒数第k个结点\n编写一个方法接受head节点,同时接收一个index\nindex 表示说倒数index个系欸但\n得到链表的总的长度 getLength\n得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到\n如果找到了，则返回该节点，否则返回nulll\n\n /*   查找单链表中的倒数第k个结点   思路:   1.编写一个方法接受head节点,同时接收一个index   2.index 表示说倒数index个系欸但   3.得到链表的总的长度 getLength   4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到   5.如果找到了，则返回该节点，否则返回nulll    */    public static HeroNode findLastIndexNode(HeroNode head, int index) &#123;        //判断是否为空 返回null        if (head.next == null) &#123;            return null;        &#125;        //遍历得到其长度        int size = getLength(head);        if (index &lt;= 0 || index &gt; size) &#123;            return null;        &#125;        //定义辅助遍历 cur, 通过 size-index 确定其位置        HeroNode cur = head.next;        for (int i = 0; i &lt; size - index; i++) &#123;            cur = cur.next;        &#125;        return cur;    &#125;    /*    获取到单链表的节点个数(不统计头节点)     */    public static int getLength(HeroNode head) &#123;        if (head.next == null) &#123;            return 0;        &#125;        int length = 0;        //定义一个辅助变量        HeroNode cur = head.next;        while (cur != null) &#123;            length++;            cur = cur.next;//遍历        &#125;        return length;    &#125;&#125;\n\n\n\n反转链表\n//设置一个辅助遍历 cur 用来遍历    HeroNode cur = head.next;\n\n//用来存放cur的下一个结点,辅助遍历   HeroNode next = null; 特别注意\n\n设置一个新链表每取出一个链表的头结点,每次放到新链表reverseHead的头部\n\n暂时保存cur下一个节点\n//必须保存 保存的是被反转的下一个的节点/** 这种必然失败cur.next=reverseHead.next;reverseHead.next=cur;cur= cur.next;*/\n\n暂时保存cur下一个节点next=cur.next;//\n\n将cur的下一个节点指向新的链表的最前端cur.next=reverseHead.next;//\n\n将cur 连接到新的链表上reverseHead.next=cur;//\n\n将暂时保存cur下一个的节点归还给curcur= next; //\n\n将head.next 指向 reverseHead.next , 实现单链表的反转  head.next = reverseHead.next;             \n\n\n//反转链表 public static void reverList(HeroNode head) &#123;     //当前链表为空     if (head.next == null || head.next.next == null) &#123;         return;     &#125;     //设置一个辅助遍历 cur 用来遍历     HeroNode cur = head.next;     //用来存放cur的下一个结点,辅助遍历     HeroNode next = null;     //设置一个新链表     HeroNode reverseHead = new HeroNode(0, &quot;&quot;);     //每取出一个链表的头结点,每次放到新链表reverseHead的头部     while (cur != null)&#123;         //必须保存 保存的是被反转的下一个的节点         /** 这种必然失败          cur.next=reverseHead.next;          reverseHead.next=cur;          cur= cur.next;          */         next=cur.next;//暂时保存cur下一个节点         cur.next=reverseHead.next;//将cur的下一个节点指向新的链表的最前端         reverseHead.next=cur;//将cur 连接到新的链表上         cur= next; //将暂时保存cur下一个的节点归还给cur     &#125;     //将head.next 指向 reverseHead.next , 实现单链表的反转     head.next = reverseHead.next; &#125;\n\n\n\n逆序打印\n思路一: 将其反转,然后打印,这样会破环链表的本身结构,不利后续的操作\n思路二: 利用栈的这个数据结构的特殊性,先进后出,将各个节点的数据压入到栈中,然后将其输出就可以\n\npublic static  void  reversePrint(HeroNode head)&#123;       if (head.next==null)&#123;           return;       &#125;       //创建一个栈,将各各节点的数据压入栈中       Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();       //辅助遍历进行操作       HeroNode cur =head.next;       while (cur!=null)&#123;           stack.push(cur);           cur=cur.next;//cur后移，这样就可以压入下一个节点       &#125;       //将栈中的节点进行打印,pop 出栈       while ((stack.size()&gt;0))&#123;           System.out.println(stack.pop());//stack的特点是先进后出       &#125;   &#125;\n\n\n\n完整代码package com.nie.linkedlist;import java.util.Stack;public class SingleLinkListDemo &#123;    public static void main(String[] args) &#123;        HeroNode hero1 = new HeroNode(1, &quot;黎明&quot;);        HeroNode hero2 = new HeroNode(2, &quot;郭富城&quot;);        HeroNode hero3 = new HeroNode(5, &quot;刘德华&quot;);        HeroNode hero4 = new HeroNode(6, &quot;张学友&quot;);        //创建链表        SingleLinkList singleLinkList = new SingleLinkList();        //增加结点        //根据插入的顺序进行插入        singleLinkList.add(hero1);        singleLinkList.add(hero2);        singleLinkList.add(hero3);        singleLinkList.add(hero4);        //增加结点        //根据节点的编号进行插入//        singleLinkList.addByOrder(hero1);//        singleLinkList.addByOrder(hero2);//        singleLinkList.addByOrder(hero4);//        singleLinkList.addByOrder(hero3);        singleLinkList.list();        System.out.println(&quot;+++++++++++&quot;);        System.out.println(&quot;-------逆序----------&quot;);        System.out.println(&quot;逆序打印单链表, 没有改变链表的结构~~&quot;);        reversePrint(singleLinkList.getHead());        System.out.println(&quot;-------反转----------&quot;);        reverList(singleLinkList.getHead());        singleLinkList.list();        System.out.println(&quot;-------修改-----------&quot;);        HeroNode newHeroNode = new HeroNode(2, &quot;舞王郭富城&quot;);        singleLinkList.update(newHeroNode);        singleLinkList.list();        System.out.println(&quot;-------删除-----------&quot;);        singleLinkList.del(1);        singleLinkList.list();        System.out.println(&quot;有效结点的个数&quot; + getLength(singleLinkList.getHead()));        //测试第倒数几的结点的        int indexLast = 1;        HeroNode res = findLastIndexNode(singleLinkList.getHead(), indexLast);        System.out.println(&quot;倒数第&quot; + indexLast + &quot;的结点为&quot; + res);    &#125;    //逆序打印    /*    思路一: 将其反转,然后打印,这样会破环链表的本身结构,不利后续的操作    思路二: 利用栈的这个数据结构,将各个节点的数据压入到栈中,然后将其输出就可以     */    public static void reversePrint(HeroNode head) &#123;        if (head.next == null) &#123;            return;        &#125;        //创建一个栈,将各各节点的数据压入栈中        Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();        //辅助遍历进行操作        HeroNode cur = head.next;        while (cur != null) &#123;            stack.push(cur);            cur = cur.next;//cur后移，这样就可以压入下一个节点        &#125;        //将栈中的节点进行打印,pop 出栈        while ((stack.size() &gt; 0)) &#123;            System.out.println(stack.pop());//stack的特点是先进后出        &#125;    &#125;    //反转链表    public static void reverList(HeroNode head) &#123;        //当前链表为空        if (head.next == null || head.next.next == null) &#123;            return;        &#125;        //设置一个辅助遍历 cur 用来遍历        HeroNode cur = head.next;        //用来存放cur的下一个结点,辅助遍历        HeroNode next = null;        //设置一个新链表        HeroNode reverseHead = new HeroNode(0, &quot;&quot;);        //每取出一个链表的头结点,每次放到新链表reverseHead的头部        while (cur != null) &#123;            //必须保存 保存的是被反转的下一个的节点            /** 这种必然失败             cur.next=reverseHead.next;             reverseHead.next=cur;             cur= cur.next;             */            next = cur.next;//暂时保存cur下一个节点            cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端            reverseHead.next = cur;//将cur 连接到新的链表上            cur = next; //将暂时保存cur下一个的节点归还给cur        &#125;        //将head.next 指向 reverseHead.next , 实现单链表的反转        head.next = reverseHead.next;    &#125;    /*   查找单链表中的倒数第k个结点   思路:   1.编写一个方法接受head节点,同时接收一个index   2.index 表示说倒数index个系欸但   3.得到链表的总的长度 getLength   4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到   5.如果找到了，则返回该节点，否则返回nulll    */    public static HeroNode findLastIndexNode(HeroNode head, int index) &#123;        //判断是否为空 返回null        if (head.next == null) &#123;            return null;        &#125;        //遍历得到其长度        int size = getLength(head);        if (index &lt;= 0 || index &gt; size) &#123;            return null;        &#125;        //定义辅助遍历 cur, 通过 size-index 确定其位置        HeroNode cur = head.next;        for (int i = 0; i &lt; size - index; i++) &#123;            cur = cur.next;        &#125;        return cur;    &#125;    /*    获取到单链表的节点个数(不统计头节点)     */    public static int getLength(HeroNode head) &#123;        if (head.next == null) &#123;            return 0;        &#125;        int length = 0;        //定义一个辅助变量        HeroNode cur = head.next;        while (cur != null) &#123;            length++;            cur = cur.next;//遍历        &#125;        return length;    &#125;&#125;class SingleLinkList &#123;    //初始化一个头节点    private HeroNode head = new HeroNode(0, &quot;&quot;);    //返回头节点    public HeroNode getHead() &#123;        return head;    &#125;    ////添加节点到单向链表    /*    不考虑顺序编号    1.找的当前链表的最后节点    2.将最后这个节点的next指向新的节点     */    public void add(HeroNode heroNode) &#123;        //头节点不能动,需要一个辅助遍历temp        HeroNode temp = head;        //遍历链表到最后        while (true) &#123;            if (temp.next == null) &#123;                break;            &#125;            //如果没有找的,将temp后移            temp = temp.next;        &#125;        //当退出while循环,temp就指向链表的最后        //将最后这个节点的next指向新的节点        temp.next = heroNode;    &#125;    /*  第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)     */    public void addByOrder(HeroNode heroNode) &#123;//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)        //因为单链表,我们找的temp是位于添加位置的前一个节点,否则插入失败        HeroNode temp = head;        boolean flag = false; // flag标志添加的编号是否存在，默认为false        while (true) &#123;            //说明已经在链表最后了            if (temp.next == null) &#123;                break;            &#125;            ////位置找到，就在temp的后面插入            if (temp.next.no &gt; heroNode.no) &#123;                break;                //说明希望添加的heroNode的编号已然存在            &#125; else if (temp.next.no == heroNode.no) &#123;                flag = true; //说明编号存在                break;            &#125;            temp = temp.next;        &#125;        if (false) &#123;            System.out.println(heroNode.no + &quot;该编号存在&quot;);        &#125; else &#123;            //插入到链表中, temp的后面            heroNode.next = temp.next;            temp.next = heroNode;        &#125;    &#125;    //修改节点    public void update(HeroNode heroNode) &#123;        if (head.next == null) &#123;            System.out.println(&quot;此节点为空&quot;);            return;        &#125;        //找到要修改的节点,根据no修改        //定义一个辅助变量        HeroNode temp = head;        boolean flag = false;//表示是否找到该节点        while (true) &#123;            if (temp == null) &#123;                break;//遍历完毕            &#125;            if (temp.no == heroNode.no) &#123;                //找到                flag = true;                break;            &#125;            temp = temp.next;        &#125;        //根据flag判断是否是要修改的节点        if (flag) &#123;            temp.name = heroNode.name;        &#125; else &#123;            System.out.println(&quot;没有找到要修改的编号&quot; + heroNode.no);        &#125;    &#125;    //修改节点    /*    思路    1.head不能动,需要一个辅助变量temp 辅助节点找到要删除的节点    1.我们在比较的时候只需要找到temp.next.no 和要需要的no作比较     */    public void del(int no) &#123;        //找到要修改的节点,根据no修改        //定义一个辅助变量        HeroNode temp = head;        boolean flag = false;// 标志是否找到待删除节点的        while (true) &#123;            if (temp.next == null) &#123; //已经到链表的最后                break;//遍历完毕            &#125;            if (temp.next.no == no) &#123;                //找到的待删除节点的前一个节点temp                flag = true;                break;            &#125;            temp = temp.next;        &#125;        if (flag) &#123;            temp.next = temp.next.next;        &#125; else &#123;            System.out.println(&quot;要删除的节点不在&quot; + no);        &#125;    &#125;    //显示链表    public void list() &#123;        if (head.next == null) &#123;            System.out.println(&quot;为空&quot;);            return;        &#125;        //因为头节点，不能动，因此我们需要一个辅助变量来遍历        HeroNode temp = head.next;        while (true) &#123;            if (temp == null) &#123;                break;            &#125;            //输出结点            System.out.println(temp);            temp = temp.next;        &#125;    &#125;&#125;class HeroNode &#123;    public int no;    public String name;    public HeroNode next;//指向下一个结点    //构造器    public HeroNode(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","队列","链表"]},{"title":"下一个排序--031","url":"http://example.com/2020/11/09/LC031-1109-下一个排序/","content":"31. 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须原地修改，只允许使用额外常数空间。\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1\n\n要找到下一个更大的排列，根据字典序的排序关系，大的越在前边其优先级越大，所以应该从后往前寻找操作的区间。基本的思路如下：\n  \n\n\n由后往前查找到第一个相邻的升序对，即nums[i] &gt;= nums[i + 1]；\n //由后向前找到 前一个比后面大的 进行标记 //  比如   465432  中的   46\n\n之后在[i:]的区间找到比nums[i-1]更大的最小数，交换两者的位置；\n\n由于此时[i:]必然为降序，所以下一个更大排列中，此段应该为升序，翻转一下就好；\n\n\n思路动图\n\n\n时间复杂度O(n)\nclass Solution &#123;       public void nextPermutation(int[] nums) &#123;        int i = nums.length - 2;//比较两个数字 所以长度减2        //由后向前找到 前一个比后面大的 进行标记        //  比如   465432  中的   46        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;//            i--;        &#125;        if (i &gt;= 0) &#123;            int j = nums.length - 1;            while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;                j--;            &#125;            swaps(nums, i, j);        &#125;        reverse(nums, i + 1);    &#125;    //反转    private void reverse(int[] nums, int start) &#123;        int i = start;        int j = nums.length - 1;        while (i &lt; j) &#123;            swaps(nums, i, j);            i++;            j--;        &#125;    &#125;    //交换    private void swaps(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"javaSE-16-包装类","url":"http://example.com/2020/11/08/javaSE16/","content":"基本数据类型包装类Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类.\n为了编程方便\n包装类（如：Integer，Double等）这些类封装了一个相应的基本数据类型数值，并为其提供了一系列操作。\n在java中, 系统为每一个基本类型都提供 了 一个对应的包装类型\n  \n\n\n\n\n基本数据类型\n包装类\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\n基本类型\n包装类\n\n\ndouble\nDouble\n\n\nchar\nCharacter\n\n\nboolean\nBoolean\n\n\n\n\n不能直接把基本类型数据赋值给引用类型变量当前程序没有语法错误,是因为Java把这些基本类型数据自动转换为了包装类对象, 再把包装 类对象传递给obj形参\npublic class Test01 &#123;\tpublic static void main(String[] args) &#123;\t\tm1(true);\t\tm1(456);\t\tm1(3.14);\t\tm1(&quot;abc&quot;);\t\t/*\t\t * 不能直接把基本类型数据赋值给引用类型变量\t\t * 当前程序没有语法错误,是因为Java把这些基本类型数据自动转换为了包装类对象, 再把包装 类对象传递给obj形参\t\t */\t&#125;\t// 需求: 定义方法, 可以处理任意类型的数据\tpublic static void m1(Object obj) &#123;\t&#125;&#125;\n\n装箱拆箱\n装箱:把基本类型转换为包装类对象\n拆箱:把包装类对象转换为基本类型\n在Java中, 可以自动的进行装箱与拆箱 \n\nInteger i1 = 147; \t\t//自动装箱int num = i1; \t\t\t//自动拆箱\n\nInteger i2 = 666;         \nInteger i3 = 666;        //重新创建了一个包装类对象\nInteger i2 = 666; \t\t//根据基本类型数据666创建了一个包装类对象, 把这个包装类对象的引用赋值给i2Integer i3 = 666;\t\t//重新创建了一个包装类对象System.out.println( i2.equals(i3));  \t//trueSystem.out.println( i2 == i3 ); \t\t//false\n\n\n\nInteger i4 = 77;Integer i5 = 77;System.out.println( i4 == i5 ); \t\t//true\n\nJava认为-128~127之间的整数使用最频繁,所以这个范围内整数创建的包装类对象采用享元模式,即把包装类对象存储到共享池中\nLong gg1 = 15L;Long gg2 = 15L;System.out.println( gg1 == gg2 ); \t\t//true\n\n\n\n\n\n包装类对象的创建\n根据基本类型创建包装类对象\n根据字符串创建包装类对象// 字符串的格式要符合数字的格式\n布尔类型的包装类把”true”字符串转换为true, 其他的字符串都转换为false\nCharacter包装类只有一个构造方法..character1 = new Character(“A”);\n\nBoolean  boolean1 = new Boolean(true);short s = 123;Short short1 = new Short(s);Integer integer1 = new Integer(78945);Double  double1 = new Double(3.14);Character character1 = new Character(&#x27;a&#x27;);boolean1 = new Boolean(&quot;true&quot;);integer1 = new Integer(&quot;456&quot;);double1 = new Double(&quot;45.789&quot;);double1 = new Double(&quot;23e3&quot;);\t//科学计数法System.out.println(double1);\t\t//23000.0\n\n输出常用字段\nSystem.out.println( Integer.BYTES); \t\t\t//字节数, 4System.out.println( Integer.SIZE);\t\t\t\t//位数:  32System.out.println( Integer.TYPE);\t\t\t\t//基本类型 : intSystem.out.println( Integer.MIN_VALUE);System.out.println( Integer.MAX_VALUE);\n\n\n\n包装类的常用方法**可以把字符串转换为基本类型数据 **         经常用\nint num = Integer.parseInt(&quot;789&quot;);  \tdd = Double.parseDouble(&quot;45.78&quot;);\n\n把基本类型/字符串转换为包装类对象\ni1 &#x3D; Integer.valueOf(369);i2 &#x3D; Integer.valueOf(&quot;258&quot;);\n\n\n\nInteger i1 = new Integer(123);\nInteger i2 = new Integer(&quot;456&quot;);\n\n\n从Number继承的 方法, 可以把包装类对象转换为基本类型数据\nbyte bb = i1.byteValue();double dd = i2.doubleValue();\n\n\n\n包装类实现了Comparable接口,重写了compareTo()方法, 根据包装类的value字段比较大小每个包装类都有一个value字段,保存对应基本类型的数据\nSystem.out.println( i1.compareTo(i2) ); \t\t//-1Character c1 = new Character(&#x27;A&#x27;);Character c2 = new Character(&#x27;a&#x27;);System.out.println( c1.compareTo(c2));  \t\t//-32Boolean b1 = new Boolean(true);Boolean b2 = new Boolean(false);System.out.println( b1.compareTo(b2));  \t\t//1\n\n\n\nequals(), 根据value字段进行判断是否相等\nSystem.out.println( i1.equals(i2));\n\n注意, 字符串要符合数字格式\n","categories":["-javase"],"tags":["基础","java","包装类"]},{"title":"javaSE-15-正则表达式","url":"http://example.com/2020/11/08/javaSE15/","content":"正则表达式\n正则表达式,即规则表达式\n模式匹配的语法,用特定的符号,表示某种规则,取匹配某个字符串\n如果字符串与规则相匹配,返回true,否则返回false\n\ns.matches(&quot;\\\\d&quot;);//匹配\n\n\n\\\\d   匹配数字\n[4-9] 控制区间\n [4567] 只能匹配出现数字的一次\n X?  一次或者一次也没有\n X*  零次或者多次\n X+  一次或者多次[即不能为空] \n \n\n//表示次数   X{n] 恰好n次   X{n,}  至少n次   x{n,m}  至少n次,最多m次\n\n\n\n\n *\\\\d   匹配数字   X  零次或者多次**\nString s1 = &quot;13667890876&quot;;boolean c1= s1.matches(&quot;\\\\d*&quot;);//匹配//X*  零次或者多次System.out.println(c1);//true\n\n\n\n*X?  一次或者一次也没有  X  零次或者多次**\nString s2=&quot;1&quot;;boolean c2=s2.matches(&quot;\\\\d?&quot;);//X?  一次或者一次也没有System.out.println(c2);//trueString s3=&quot;111&quot;;boolean c3=s3.matches(&quot;\\\\d+&quot;);// X*  零次或者多次System.out.println(c3);//true\n\n\n\n匹配11位电话号  只能1开头,  第二位只能是35789\nboolean c2 = s1.matches(&quot;[1][35789]\\\\d&#123;9&#125;&quot;);System.out.println(c2);//true\n\n\n\n//[4-9] 控制区间//[4567] 只能匹配出现数字的一次\nString s4 = &quot;9&quot;;boolean c4 = s4.matches(&quot;[4-9]&quot;); //左边 右边 闭合System.out.println(c4);//true\n\n\n\n五到九位的qq号\nString s4=&quot;1443906329&quot;;boolean c4=s4.matches(&quot;[1-9]\\\\d&#123;5,9&#125;&quot;);System.out.println(&quot;QQQQqq&quot;);System.out.println(c4);\n\n\n\n\n\n\n\\d  数字:[\\1-9]\\D  非数字:[^0-9]\\s  空白字符\\S  非空白字符\\w  单词字符\\W  非单词字符\n\n\n\n*空白字符   \\s 多个**\nString d1 = &quot;   &quot;;boolean e1 = d1.matches(&quot;\\\\s*&quot;);//小写字母  // 空白字符   \\\\s* 多个System.out.println(&quot;空白字符&quot;);System.out.println(e1);//true\n\n\n\n非空白字符\nString d2 = &quot;fadsda&quot;;boolean e2 = d2.matches(&quot;\\\\S*&quot;);//大写字母// 非空白字符System.out.println(&quot;非空白字符&quot;);System.out.println(e2);//trueSystem.out.println(&quot;----&quot;);\n\n\n\n//\\w 单词字符：[a-zA-Z_0-9]//\\W 非单词字符：[^\\w]\nString d3 = &quot;werwer&quot;;boolean e3 = d3.matches(&quot;\\\\w*&quot;);// 单词字符System.out.println(&quot;单词字符&quot;);System.out.println(e3);System.out.println(&quot;----&quot;);String d4 = &quot;@#$@#$@#$@#%@#%&quot;;boolean e4 = d4.matches(&quot;\\\\W*&quot;);// 非单词字符System.out.println(&quot;非单词字符&quot;);System.out.println(e4);System.out.println(&quot;----&quot;);\n\n\n\n通用邮箱\n\n//  .  表示任意字符\n//需要时对其转义  \\.\n//(com|com.cn)表示com 或者 com.cn\n\nString s5 = &quot;123sas231@qq.com.cn&quot;;//  .  表示任意字符//需要时对其转义  \\\\.//(com|com.cn)表示com 或者 com.cnboolean c5 = s5.matches(&quot;\\\\w&#123;6,15&#125;@\\\\w&#123;2,6&#125;\\\\.(com|com.cn)&quot;);System.out.println(&quot;youxiang&quot;);System.out.println(c5);\n\nString s6 = &quot;asada23j424k231&quot;;String[] c6 = s6.split(&quot;\\\\d&quot;);System.out.println(Arrays.toString(c6));System.out.println(s6.replaceFirst(&quot;\\\\d&quot;, &quot;W&quot;));//转换第一个","categories":["-javase"],"tags":["正则表达式","基础","java"]},{"title":"javaSE-14-StringBuffer,StringBuilder","url":"http://example.com/2020/11/08/javaSE14/","content":"StringBuffer,StringBuilder概述\nString 值不可变  常量\nStringBuffer  值可变  多线程安全 效率低\nStringBuilder 值可变  多线程不安全 效率高\n\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n  \n\nStringBuffer ,StringBuilder上的主要操作是 append 和 insert 方法可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append  方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 \n将 StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 StringBuffer。\nStringBuilder/StringBuffer\n可变的字符串 , 适用于频繁进行字符串连接\n最常用的方法: append() \nStringBuffer是线程安全的, StringBuilder不是线程安全的\nStringBuilder/StringBuffer默认初始化容量: 16\n默认扩容: newCapacity = value.length * 2 + 2\n\n\n\ns2.append(1);//向末尾添加,不会创建新的,,\n能有效地将给定的数据转换成字符串，\nStringBufferStringBuffer s2 = new StringBuffer(&quot;abc&quot;);s2.append(1);//向末尾添加,不会创建新的\n\n\n\nappend向末尾添加字符串,不会创建新的StringBuffer对象\ninsert向指定位置插入一个字符串\nStringBuffers2.append(&quot;asdasd&quot;);s2.insert(0, &quot;nihao&quot;);System.out.println(s2);\n\n\n\ndeleteCharAt(1);//删除指定位置delete(0, 4)//删除区间的 左开右闭\ns2.deleteCharAt(1);//删除指定位置System.out.println(s2);s2.delete(0, 4);//删除区间的 左开右闭System.out.println(s2);\n\n\n\n替换功能左开右闭\ns2.replace(0, 4, &quot;tttt&quot;);System.out.println(s2);s2.reverse();System.out.println(s2);\n\n\n\n返回值类型是String类型，本身没有发生改变必须赋值给新的字符串\nString s3 = s2.substring(0, 4);System.out.println(s3);\n\n完整代码:\npackage day4;public class StringBufferDemo &#123;    public static void main(String[] args) &#123;/*String 值不可变  常量StringBuffer  值可变  多线程安全StringBuilder 值可变  多线程不安全多次字符串拼接 使用  StringBuffer  StringBuilder */        StringBuffer s1 = new StringBuffer();//默认长度位16        StringBuffer s2 = new StringBuffer(&quot;abc&quot;);        s2.append(1);//向末尾添加,不会创建新的        s2.append(&quot;asdasd&quot;);        s2.insert(0, &quot;nihao&quot;);        System.out.println(s2);        s2.deleteCharAt(1);//删除指定位置        System.out.println(s2);        s2.delete(0, 4);//删除区间的 左开右闭        System.out.println(s2);        //替换功能左开右闭        s2.replace(0, 4, &quot;tttt&quot;);        System.out.println(s2);        s2.reverse();        System.out.println(s2);        //返回值类型是String类型，本身没有发生改变        //必须赋值给新的字符串        String s3 = s2.substring(0, 4);        System.out.println(s3);    &#125;&#125;\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"数据结构和算法--003--队列","url":"http://example.com/2020/11/08/B站数据结构003/","content":"队列介绍概述:\n队列是一个有序列表,可以用数组或者链表实现\n先进先出,先存入队列的数据， 要先取出。 后存入的要后取出  \n\n数组模拟队列思路\n队列本身就是有序列表,若使用数组的结构来储存队列的数据,则maxSize是从该队列的最大容量\n\n因为队列的输出,输入是分别从前后端来处理,因此需要两个变量front以及rear分别记录队列前后端的下标,front 会随着数据输出而改变， 而 rear 则是随着数据输入而改变，   \n \n\n\n\n![屏幕截图 2020-11-08 122227](B站数据结构003/屏幕截图 2020-11-08 122227.png)\n存入数据的思路,addQueue\n将尾指针后移:rear+1,当front == rear  为空\n\n若尾指针 rear 小于队列的最大下标 maxSize-1， 则将数据存入 rear 所指的数组元素中， 否则无法存入数据。rear == maxSize - 1[队列满]  \npublic void addQueue(int n) &#123;    //判断队列是否满    if (isFull()) &#123;        System.out.println(&quot;队列已满&quot;);        return;    &#125;    rear++;    arr[rear] = n;&#125;\n\n\n\n\n\n取出数据getQueue\n将头指针后移 front++;当front == rear  为空\npublic int getQueue() &#123;      //判断是否为空      if (isEmpty()) &#123;          //抛出异常          throw new RuntimeException(&quot;为空&quot;);      &#125;      front++;      return arr[front];  &#125;\n\n\n\n创建队列public ArrayQueue(int arrmaxSize) &#123;     maxSize = arrmaxSize;     arr = new int[maxSize];     front = -1;//指向队列头部,分析出front是指向队列头的一个位置     rear = -1;//指向尾部, &#125;\n\n\n\n判断队列是否满public boolean isFull() &#123;      return rear == maxSize - 1;  &#125;\n\n判断是否为空public boolean isEmpty() &#123;    return rear == front;&#125;\n\n显示所有数据public void showQueue() &#123;    //遍历    if (isEmpty()) &#123;        System.out.println(&quot;队列为空&quot;);        return;    &#125;    for (int i = 0; i &lt; arr.length; i++) &#123;        System.out.println(&quot;第&quot; + i + &quot;元素未:\\t&quot; + arr[i]);    &#125;&#125;\n\n查看头元素public int headQueue() &#123;     if (isEmpty()) &#123;         throw new RuntimeException(&quot;为空&quot;);     &#125;     return arr[front + 1]; &#125;\n\n完整代码package com.nie.queue;import java.util.Scanner;public class ArrayQueueDemo &#123;    public static void main(String[] args) &#123;        //测试        //4个数据        ArrayQueue arrayQueue = new ArrayQueue(4);        Scanner scanner = new Scanner(System.in);        boolean tag = true;//标签        while (tag) &#123;            System.out.println(&quot;输入[s]\\t 显示队列&quot;);            System.out.println(&quot;输入[e]\\t 退出&quot;);            System.out.println(&quot;输入[a]\\t 增添元素到队列&quot;);            System.out.println(&quot;输入[g]\\t 由队列中取出数据&quot;);            System.out.println(&quot;输入[h]\\t 查看头部的一个数据&quot;);            char key = scanner.next().charAt(0);//接收一个字符            switch (key)&#123;                case &#x27;s&#x27;:                    arrayQueue.showQueue();                    break;                case &#x27;e&#x27;:                    //退出                    scanner.close();                    tag = false;                    break;                case &#x27;a&#x27;:                    System.out.println(&quot;输入一个数据&quot;);                    int val=scanner.nextInt();                    arrayQueue.addQueue(val);                    break;                case &#x27;g&#x27;:                    try &#123;                        int res=arrayQueue.getQueue();                        System.out.println(&quot;取数的数据为\\t:&quot;+res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                    &#125;                    break;                case &#x27;h&#x27;:                    int res = arrayQueue.headQueue();                    System.out.printf(&quot;队列头的数据是%d\\n&quot;, res);                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class ArrayQueue &#123;    private int maxSize;//表示最大的总量    private int front;//头    private int rear;//尾部    private int[] arr;//利用数组存放数据,模拟队列    /**     * 创建队列     *     * @param arrmaxSize     */    public ArrayQueue(int arrmaxSize) &#123;        maxSize = arrmaxSize;        arr = new int[maxSize];        front = -1;//指向队列头部,分析出front是指向队列头的一个位置        rear = -1;//指向尾部,    &#125;    /**     * 判断队列是否满     */    public boolean isFull() &#123;        return rear == maxSize - 1;    &#125;    /**     * 判断是否为空     *     * @return     */    public boolean isEmpty() &#123;        return rear == front;    &#125;    /**     * 添加元素     */    public void addQueue(int n) &#123;        //判断队列是否满        if (isFull()) &#123;            System.out.println(&quot;队列已满&quot;);            return;        &#125;        rear++;        arr[rear] = n;    &#125;    /**     * 取出数据     * @return     */    public int getQueue() &#123;        //判断是否为空        if (isEmpty()) &#123;            //抛出异常            throw new RuntimeException(&quot;为空&quot;);        &#125;        front++;        return arr[front];    &#125;    /**     * 显示所有数据     */    public void showQueue() &#123;        //遍历        if (isEmpty()) &#123;            System.out.println(&quot;队列为空&quot;);            return;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(&quot;第&quot; + i + &quot;元素未:\\t&quot; + arr[i]);        &#125;    &#125;    /**     * 查看头元素     *     * @return     */    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;为空&quot;);        &#125;        return arr[front + 1];    &#125;&#125;\n\n\n\n\n\n数组的循环队列概述利用数组,将数组看成为一个环形,(通过取模来实现)\n说明\n尾索引的下一个为头索引时表示队列满，  (rear + 1) % maxSize == front 满\nrear == front  队空\n\n\n\n\n\n\n\n\nront 指向队列元素的一个元素,初始值为   0\nrear 指向队列的最后一个元素的后一个位置. 空出一个空间,以便控制是否满. 初始值为 0\n判断队列满  (rear + 1) % maxSize == front \nrear == front  队空\n有效的元素为:(rear+maxSize-front)%maxSize\n\n代码实现显示所有数据通过取模    i%maxSize  获取数据\nSystem.out.println(“第” + i%maxSize + “元素未:\\t” + arr[i%maxSize]);\npublic void showQueue() &#123;      &#x2F;&#x2F;遍历      if (isEmpty()) &#123;          System.out.println(&quot;队列为空&quot;);          return;      &#125;      for (int i &#x3D; front; i &lt; front+size(); i++) &#123;          System.out.println(&quot;第&quot; + i%maxSize + &quot;元素未:\\t&quot; + arr[i%maxSize]);      &#125;  &#125;\n\n取出数据\n这里需要分析出 front 是指向队列的第一个元素先把 front 对应的值保留到一个临时变量  int val=arr[front];\n将 front 后移, 考虑取模  front=(front+1)%maxSize;\n将临时保存的变量返回        return val;\n\npublic int getQueue() &#123;    &#x2F;&#x2F;判断是否为空    if (isEmpty()) &#123;        &#x2F;&#x2F;抛出异常        throw new RuntimeException(&quot;为空&quot;);    &#125;    &#x2F;&#x2F;将头部元素赋值    int val&#x3D;arr[front];    front&#x3D;(front+1)%maxSize;    return val;&#125;\n\n添加元素\n直接将数据加入  arr[rear] = n;\n将 rear 后移, 这里必须考虑取模    rear = (rear + 1) % maxSize;\n\npublic void addQueue(int n) &#123;     //判断队列是否满     if (isFull()) &#123;         System.out.println(&quot;队列已满&quot;);         return;     &#125;     //直接将数据加入     arr[rear] = n;     //将 rear 后移, 这里必须考虑取模     rear = (rear + 1) % maxSize; &#125;\n\n完整代码package com.nie.queue;import java.util.Scanner;public class CircleArrayQueueDemo &#123;    public static void main(String[] args) &#123;        //测试        //4个数据        CircleArray circleArray = new CircleArray(3);        Scanner scanner =new Scanner(System.in);        boolean tag = true;//标签        while (tag) &#123;            System.out.println(&quot;当前的数据个数为:\\t&quot;+circleArray.size());            System.out.println(&quot;输入[s]\\t 显示队列&quot;);            System.out.println(&quot;输入[e]\\t 退出&quot;);            System.out.println(&quot;输入[a]\\t 增添元素到队列&quot;);            System.out.println(&quot;输入[g]\\t 由队列中取出数据&quot;);            System.out.println(&quot;输入[h]\\t 查看头部的一个数据&quot;);            char key = scanner.next().charAt(0);//接收一个字符            switch (key)&#123;                case &#x27;s&#x27;:                    circleArray.showQueue();                    break;                case &#x27;e&#x27;:                    //退出                    scanner.close();                    tag = false;                    break;                case &#x27;a&#x27;:                    System.out.println(&quot;输入一个数据&quot;);                    int val=scanner.nextInt();                    circleArray.addQueue(val);                    break;                case &#x27;g&#x27;:                    try &#123;                        int res=circleArray.getQueue();                        System.out.println(&quot;取数的数据为\\t:&quot;+res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                    &#125;                    break;                case &#x27;h&#x27;:                    int res = circleArray.headQueue();                    System.out.printf(&quot;队列头的数据是%d\\n&quot;, res);                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class CircleArray &#123;    private int maxSize;//表示最大的总量    //front 指向队列元素的一个元素,初始值为   0    private int front;//头    //rear 指向队列的最后一个元素的后一个位置. 空出一个空间,以便控制是否满. 初始值围殴 0    private int rear;//尾部    private int[] arr;//利用数组存放数据,模拟队列    /**     * 创建队列     *     * @param arrmaxSize     */    public CircleArray(int arrmaxSize) &#123;        maxSize = arrmaxSize;        arr = new int[maxSize];    &#125;    /**     * 判断队列是否满     */    public boolean isFull() &#123;        return (rear + 1) % maxSize == front;    &#125;    /**     * 判断是否为空     *     * @return     */    public boolean isEmpty() &#123;        return rear == front;    &#125;    /**     * 添加元素     */    public void addQueue(int n) &#123;        //判断队列是否满        if (isFull()) &#123;            System.out.println(&quot;队列已满&quot;);            return;        &#125;        //直接将数据加入        arr[rear] = n;        //将 rear 后移, 这里必须考虑取模        rear = (rear + 1) % maxSize;    &#125;    /**     * 取出数据     * @return     */    public int getQueue() &#123;        //判断是否为空        if (isEmpty()) &#123;            //抛出异常            throw new RuntimeException(&quot;为空&quot;);        &#125;        //将头部元素赋值        int val=arr[front];        front=(front+1)%maxSize;        return val;    &#125;    /**     * 显示所有数据     */    public void showQueue() &#123;        //遍历        if (isEmpty()) &#123;            System.out.println(&quot;队列为空&quot;);            return;        &#125;        for (int i = front; i &lt; front+size(); i++) &#123;            System.out.println(&quot;第&quot; + i%maxSize + &quot;元素未:\\t&quot; + arr[i%maxSize]);        &#125;    &#125;    /**     * 取出元素     *     * @return     */    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;为空&quot;);        &#125;        return arr[front + 1];    &#125;    /**     * 当前有效数据的个数     * @return     */    public int size()&#123;        return  (rear+maxSize-front)%maxSize;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","队列"]},{"title":"数据结构和算法--002--稀疏数组","url":"http://example.com/2020/11/06/B站数据结构002/","content":"稀疏数组当一个数组中的很多值默认是0,因此记录了很多没有意义的数据,因而需要稀疏数组\n基本介绍:当一个数组中大部分是由零,或者为同一个值的数组时,可以使用稀疏数组.\n稀疏数组处理方法:\n\n记录数组中一共有几行几列,有多少个不同的值\n\n把具有不同的元素的行列以及值记录在一个小规模中,从而缩小程序的规模\n \n\n\n\n\n二维数组转化稀疏数组的思路\n遍历原始数组的二维数组,得到有效数据的个数sum\n\n根据sum就可以创建sparseArrayint[sum+1][3]\n[sum+1]:表示行数,,,第一行用来存放原始数组的行列数,和一共有多少个值\n\n列数 \n\n\n将二维数组的有效数据存入到稀疏数组\n\n\n稀疏数组转化为原始数组的思路\n\n先读取稀疏数组的第一行,根据第一行的存放原始数组的行列数,创建二维数组\n在读取稀疏数组后几行的数据,赋值给二维数组\n\npackage day1.work;public class SparseArray &#123;    public static void main(String[] args) &#123;        int allNum = 10;//总行数和总列数        int[][] array = new int[allNum][allNum];        //创建一个原始数组        array[1][1] = 2;        array[2][3] = 3;        array[5][5] = 1;        System.out.println(&quot;原始的二维数组:&quot;);        for (int[] a : array) &#123;            for (int data : a) &#123;                System.out.print(data + &quot;\\t&quot;);            &#125;            System.out.println();        &#125;        //二维数组转换到稀疏数组        //遍历非零的个数        int sum = 0;        for (int i = 0; i &lt; array.length; i++) &#123;            for (int j = 0; j &lt; array[i].length; j++) &#123;                if (array[i][j] != 0) &#123;                    sum++;                &#125;            &#125;        &#125;        //创建稀疏数组        int[][] sparseArray = new int[sum + 1][3];        sparseArray[0][0] = allNum;//行        sparseArray[0][1] = allNum;//列        sparseArray[0][2] = sum;//数的数量        //遍历二维数组给稀疏数组赋值        int countNum = 0;//记录一共及格数字        for (int i = 0; i &lt; array.length; i++) &#123;            for (int j = 0; j &lt; array[i].length; j++) &#123;                if (array[i][j] != 0) &#123;                    countNum++;                    sparseArray[countNum][0] = i;                    sparseArray[countNum][1] = j;                    sparseArray[countNum][2] = array[i][j];                &#125;            &#125;        &#125;        //输出稀疏数组        System.out.println(&quot;稀疏数组为&quot;);        System.out.println(&quot;行\\t列\\t值&quot;);        for (int[] a : sparseArray) &#123;            for (int data : a) &#123;                System.out.print(data + &quot;\\t&quot;);            &#125;            System.out.println();        &#125;//将稀疏数组转换称为正常数组        int[][] array2 = new int[sparseArray[0][0]][sparseArray[0][0]];        for (int i = 1; i &lt; sparseArray.length; i++) &#123;            /*                        行\t列\t值                        10\t10\t3                        1\t1\t2                        2\t3\t3                        5\t5\t1             */            //     行\t                列\t                    值            array2[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];        &#125;        System.out.println(&quot;转换后的正常组&quot;);        for (int[] a : array2) &#123;            for (int data : a) &#123;                System.out.print(data + &quot;\\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n输出:\n\n","categories":["-数据结构和算法-体系"],"tags":["数据结构","稀疏数组"]},{"title":"数据结构和算法--001--概述","url":"http://example.com/2020/11/06/B站数据结构001/","content":"数据结构和算法概述程序=数据结构+算法\n数据结构是算法的基础\n线性结构\n特点:数据元素之间存在一对一的线性关系\n\n两种不同的储存结构,顺序储存结构(数组)和链式储存结构(链表).顺序储存的线性表称为顺序表,顺序表中的储存式连续的\n \n\n链式储存的线性表称为链表,链表中的储存元素不一定式连续的,元素节点中存放数据元素以及相邻元素的地址信息\n\n线性结构常见的由:数组,队列,链表和栈\n\n\n非线性结构包括二维数组,多维数组,广义表,树,图结构\n","categories":["-数据结构和算法-体系"],"tags":["数据结构"]},{"title":"01背包-穷举法递归","url":"http://example.com/2020/11/05/算法实验-01背包穷举法/","content":"穷举法解决01背包利用暴力破解法(穷举法)问题描述：给定n个重量为{w1, w2, … ,wn}、价值为{v1, v2, … ,vn}的物品和一个容量为C的背包，求这些物品中的一个最有价值的子集，且要能够装到背包中。\n包的总容量15kg\n物品情况\n\n\n\n物品编号\n价值\n重量\n\n\n\n1\n4$\n12kg\n\n\n2\n2$\n2kg\n\n\n3\n2$\n1kg\n\n\n4\n1$\n1kg\n\n\n5\n10$\n4kg\n\n\n  \n\n思路:\n利用递归进行遍历求出各个的可能性\n将遍历出的结果存入int[] back = new int[N],,进行缓存\n没存入一个back[]数组,进行遍历,将符合的题目要求allWigth[总的重量]&lt;=15的,存入到Map&lt;String, Integer&gt;中\nString表示背包情况. Integer表示总价值\n在存入的Map&lt;String, Integer&gt;的所有数据中,遍历出最大的Integer,也就是最大的价值\n根据Integer值,遍历出对应的String,就是背包的情况\n\n代码利用递归求出所有的背包情况\npublic class GiveBack &#123;     //\t定义一个int数组\tint array[]=new int[1000]; \tint N=5;    //n为当前层数\t//求n的子集\tpublic  void giveback(int n)&#123;\t\tif(n&gt;=N)&#123;\t\t\tfor (int i = 0; i &lt;N; i++) &#123;\t\t\t\tSystem.out.print(array[i]);\t\t\t&#125;\t\t\tSystem.out.println();\t\t\treturn;\t\t&#125;\t\tarray[n]=0;\t\tgiveback(n+1);\t\tarray[n]=1;\t\tgiveback(n+1);\t\treturn;\t&#125;\tpublic static void main(String[] args) &#123;\t\tGiveBack giveback=new GiveBack();\t\tgiveback.giveback(0);\t&#125;&#125;\n\n结果\n所有背包情况\n00000\t00001\t00010\t00011\t00100\t00101\t00110\t00111\t01000\t01001\t01010\t01011\t01100\t01101\t01110\t01111\t10000\t10001\t10010\t10011\t10100\t10101\t10110\t10111\t11000\t11001\t11010\t11011\t11100\t11101\t11110\t11111\t\n\n最终代码\npackage school;import java.util.*;public class GiveBack3 &#123;    //\t定义一个int数组    int array[] = new int[1000];    int N = 5;    int[] value = &#123;4, 2, 2, 1, 10&#125;;//价格    int[] wight = &#123;12, 2, 1, 1, 4&#125;;//体积    int[] back = new int[N];//用来缓存所便利的可能存在的背包    int all = 0;  //总的价值    int allWigth = 0;//总的重量    int count = 0;//标记遍历的次数    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    public void giveback(int n) &#123;        if (n &gt;= N) &#123;            all = 0;//每次遍历一个循环后要置零,防止对后的影响            allWigth = 0;            count = 0;            for (int i = 0; i &lt; N; i++) &#123;                back[i] = array[i];                //遍历back数组 ,所存放的背包 00100  1表示已经由背包,0表示没有                if (back[i] == 1) &#123;                    all += value[i];                    allWigth += wight[i];                    count++;//标记遍历的次数                &#125; else &#123;                    count++;                &#125;                //当遍历的次数为5和所存放的总重量小于等于15 放入Map中                if (count == 5 &amp;&amp; allWigth &lt;= 15) &#123;                    map.put(Arrays.toString(back), all);                &#125;            &#125;            return;        &#125;        //运用递归进行调用        array[n] = 0;        giveback(n + 1);        array[n] = 1;        giveback(n + 1);        return;    &#125;    /**     * @param map   遍历存入输入的图     * @param value 重量     * @return 返回value所对应的kye值     */    private &lt;K, V&gt; K getKeyByLoop(Map&lt;K, V&gt; map, V value) &#123;        for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;            if (Objects.equals(entry.getValue(), value)) &#123;                return entry.getKey();            &#125;        &#125;        return null;    &#125;    public static void main(String[] args) &#123;        GiveBack3 giveback = new GiveBack3();        giveback.giveback(0);        //通过迭代遍历values        Collection&lt;Integer&gt; values = giveback.map.values();        Iterator&lt;Integer&gt; iterator = values.iterator();        Integer temp = 0;        while (iterator.hasNext()) &#123;            Integer integer = iterator.next();            //遍历最大的values,并且赋值给temp            if (integer &gt; temp) &#123;                temp = integer;            &#125;        &#125;        System.out.print(&quot;最大的价格\\t&quot;);        System.out.println(temp + &quot;\\t&quot;);        //通过values值    利用getKeyByLoop函数遍历出对应的key值,也就是符合题意的而背包        System.out.print(&quot;所选符合题意的背包\\t&quot;);        System.out.println(giveback.getKeyByLoop(giveback.map, temp));    &#125;&#125;\n\n输出\n最大的价格\t15\t所选符合题意的背包\t[0, 1, 1, 1, 1]\n\n\n\n\n\n中间符合标准的,能放入背包的情况\n&#123;[0, 0, 0, 1, 0]=1, [0, 0, 0, 1, 1]=11, [0, 0, 1, 1, 0]=3, [0, 1, 0, 1, 0]=3, [1, 1, 0, 1, 0]=7, [0, 1, 1, 0, 1]=14, [0, 1, 1, 1, 0]=5, [0, 1, 0, 1, 1]=13, [0, 1, 1, 1, 1]=15, [0, 1, 0, 0, 1]=12, [0, 1, 0, 0, 0]=2, [0, 1, 1, 0, 0]=4, [0, 0, 1, 1, 1]=13, [1, 0, 0, 1, 0]=5, [1, 0, 1, 1, 0]=7, [0, 0, 0, 0, 0]=0, [1, 1, 0, 0, 0]=6, [1, 1, 1, 0, 0]=8, [0, 0, 1, 0, 1]=12, [0, 0, 1, 0, 0]=2, [0, 0, 0, 0, 1]=10, [1, 0, 1, 0, 0]=6, [1, 0, 0, 0, 0]=4&#125;\n\n","categories":["-算法"],"tags":["01背包","穷举法"]},{"title":"javaSE-13-String类","url":"http://example.com/2020/11/05/javaSE13/","content":"String类java.lang.String类表示字符串的类字符串是由多个字符组成的一串数据(字符序列)的字符串常量,值改变后会重新创建一个新的对象.\n两种创建方式\n直接赋值字符串字面量\n\nString s1 &#x3D; &quot;hello&quot;;\n\n\n无参构造    String()\n\nString s2 &#x3D; new String();\t\tSystem.out.println( s2 &#x3D;&#x3D; null ); \t\n\n\n第一种先在栈中创建一个对String类的对象引用变量s，然后去查找”abc”是否被保存在字符串常量池中，如果没有则在堆中创建一个String对象object，第一种特点：JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象\n\n第二种一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象\n \n\n\n\n构造方法public String()public String(String str)public String(byte[] bytes) 把Char数组转换位字符串public String(char[] value) 把byte数转换成字符串\ngetBytes(“utf-8”); 把字符串转为byte数组  指定字符集(编码格式)\n使用指定的进行填充value\nString s &#x3D; new String(&quot;aa&quot;);\n\n根据数值创建String\nchar[] c = &#123;&#x27;s&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;h&#x27;&#125;;String s2 = new String(c);//通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 System.out.println(s2);//输出//sddh\n\n由2 开始 取 两个\nString s3 = new String(c2, 2, 2);System.out.println(s3);\n\n输出//dh\n把字节数组中的字节,按照utf-8编码转换为字符串\nString s4 = &quot;你&quot;;byte[] b = s4.getBytes(&quot;GBK&quot;);//把能够看到的转换成字符数组GBKSystem.out.println(Arrays.toString(b));String s5 = &quot;你&quot;;byte[] b1 = s5.getBytes(&quot;utf-8&quot;);//把能够看到的转换成字符数组 utf-8System.out.println(Arrays.toString(b1));\n\n输出//[-60, -29][-28, -67, -96]\nString字符串的getBytes()方法,可以把字符串以当前默认的编码(utf-8)转换为字节数组\n将获得到的字符数组通过GBK\nString s6 = &quot;你好世界&quot;;byte[] b2 = s6.getBytes(&quot;utf-8&quot;);//把能够看到的转换成字符数组 utf-8System.out.println(Arrays.toString(b2));//将获得到的字符数组通过GBKString s7 = new String(b2, &quot;GBK&quot;);//三个System.out.println(s7);\n\n输出\n[-28, -67, -96, -27, -91, -67, -28, -72, -106, -25, -107, -116]浣犲ソ涓栫晫\n判断功能boolean equals(Object obj)  //值是否相等boolean equalsIgnoreCase(String str)//值是否相等,不去别大小写boolean contains(String str)//是否包含boolean isEmpty()//是否为空boolean startsWith(String prefix)// //判断是否已指定字符串开头boolean endsWith(String suffix)//判断是否已指定字符串结尾\nboolean equals(Object obj)  //值是否相等\nString s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;);String s3 = new String(&quot;abC&quot;);System.out.println(s1 == s2); //falseSystem.out.println(s1.equals(s2));//true\n\nboolean equalsIgnoreCase(String str)//值是否相等,不去别大小写\nSystem.out.println(s1.equalsIgnoreCase(s3));//不区别大小写\n\n输出:true\n字符串进行比较  进行相减\nSystem.out.println(&quot;a&quot;.compareTo(&quot;b&quot;));System.out.println(&quot;a&quot;.compareTo(&quot;c&quot;));\n\n输出\n\n-1\n-2\n\n当且仅当此字符串包含指定的 char 值序列时，返回 true。\nSystem.out.println(s1.contains(&quot;b&quot;));//trueSystem.out.println(s1.contains(&quot;ab&quot;));//true\n\n\n\n判断字符串是否为空   “” 空串  为null//当且仅当 length() 为 0 时返回 true。\nSystem.out.println(s1.isEmpty());System.out.println(&quot;&quot;.isEmpty());//判断字符串是否为空   &quot;&quot; 空串  为null//当且仅当 length() 为 0 时返回 true。 // &quot;&quot;/null不同\n\nboolean startsWith(String prefix)// //判断是否已指定字符串开头boolean endsWith(String suffix)//判断是否已指定字符串结尾\nSystem.out.println(s1.startsWith(&quot;a&quot;));//判断是否已指定字符串开头System.out.println(s1.startsWith(&quot;ab&quot;));System.out.println(s1.endsWith(&quot;ab&quot;));////判断是否已指定字符串结尾\n\n获取功能int length() //通过数组获得长度char charAt(int index)//;//返回指定位置的元素int indexOf(String str)///获得首次出现的位置int indexOf(String str,int fromIndex)// 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。String substring(int start)//截取String substring(int start,int end)////通过指定的位置进行截取\nint length() //通过数组获得长度\nString s1 = &quot;abcdefgcs&quot;;//  012345678System.out.println(s1.length());\n\n 字符串的底层是数组通过数组获得长度\npublic int length() &#123;return value.length;&#125;\n\n//返回指定位置的元素\nSystem.out.println(s1.charAt(4));//返回指定位置的元素/*         public char charAt(int index) &#123;        if ((index &lt; 0) || (index &gt;= value.length)) &#123;            throw new StringIndexOutOfBoundsException(index);        &#125;        return value[index];    &#125;         */\n\n\n\n//获得首次出现的位置\nSystem.out.println(s1.indexOf(&quot;a&quot;));\n\n从指定的索引开始,,,,indexOf(String str, int fromIndex)返回指定子字符串在此字符串中第一次出现处的索引，。\n嵌套一个s1.indexOf(&#x27;a&#x27;)+1)d        System.out.println(s1.indexOf(&#x27;a&#x27;, s1.indexOf(&#x27;a&#x27;) + 1));\n\n\n\n//获得字符首次出现的位置  从后向前找\nSystem.out.println(s1.lastIndexOf(&quot;c&quot;));//获得字符首次出现的位置  从后向前找\n\n//截取//截取操作  返回的是一个新的字符串,重新创造一个新的//返回一个新字符串，它是此字符串的一个子字符串。//原来的不变\nSystem.out.println(s1.substring(3));//通过指定的位置进行截取System.out.println(s1.substring(3, 4));\n\n\n\n转换功能byte[] getBytes() //可以把字符串以当前默认的编码转换为字节数组char[] toCharArray()  //把字符串 转为 字符数组static String valueOf(char[] chs)///把字符数组 转为 字符串String toLowerCase()//转为小写字母String toUpperCase()//转为大写字母String concat(String str)//把两个字符串连接起来  返回一个新的字符串Stirng[] split(分割符);//用正则表达式 将字符串分割为数组\nchar [] c = &quot;abc&quot;.toCharArray();//把字符串 转为 字符数组String s = String.valueOf(c);//把字符数组 转为 字符串new String(c);String s1 = &quot;abcdEFG&quot;;System.out.println(s1.toLowerCase());//转为小写字母System.out.println(s1.toUpperCase());//转为大写字母String s2 = s1.concat(&quot;xxxx&quot;);//把两个字符串连接起来  返回一个新的字符串System.out.println(s2);String s3 = &quot;a:b:c:def&quot;;String [] array =   s3.split(&quot;:&quot;);//用正则表达式 将字符串分割为数组System.out.println(Arrays.toString(array));\n\n\n\n替换功能String replace(char old,char new)String replace(String old,String new)replaceAll(String regex, String replacement)replaceFirst(String regex, String replacement) String trim()  去除字符串两空格\nSystem.out.println(s3.replace(&quot;:&quot;,&quot;|&quot;));System.out.println(s3.replaceAll(&quot;|&quot;,&quot;:&quot;));String s4 = &quot; a bc &quot;;System.out.println(s4.length());System.out.println(s4.trim().length());//去掉字符串首位空格System.out.println(s4.replace(&quot; &quot;,&quot;&quot;).length());\n\n\n\nString  text = &quot;d:/Chapter04/src/com/bjpowernode/chapter04/string/Test02.java&quot;;\tint lastSlashIndex = text.lastIndexOf(&quot;/&quot;);\tint dotIndex = text.indexOf(&quot;.&quot;);\tString folder = text.substring(0, lastSlashIndex);\tString filename = text.substring(lastSlashIndex+1 , dotIndex);\tString suffix = text.substring(dotIndex+1);\tSystem.out.println( folder );\tSystem.out.println( filename);\n\n附件\n常用方法\n\n\nchar\ncharAt(int index) 返回指定位置的字符\n\n\n\nint\ncompareTo(#compareTo-java.lang.String-)(String anotherString) 字符串大小的比较, String类实现了Comparable接口, 重写了接口的抽象方法, 字符大小的比较根据字符串第一个不相等的字符进行码值相减 “abc”.compareTo(“abx”)\n\n\nString\nconcat(String str) 在当前字符串的后面连接str串.\n\n\nboolean\ncontains(CharSequence s) 判断当前字符串是否包含s串\n\n\nboolean\nendsWith(String suffix) 判断是否以suffix结尾.\n\n\nboolean\nequals(Object anObject)判断两个字符串是否相等.\n\n\nstatic String\nformat(String format, Object… args)字符串的格式化\n\n\nbyte[]\ngetBytes() 返回字符串在当前编码下对应的字节数组.\n\n\nbyte[]\ngetBytes(String charsetName) 返回字符串在指定编码下对应的字节数组.\n\n\nvoid\ngetChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 把当前字符串[srcBegin,srcEnd) 范围内的字符复制到dst数组的dstBegin位置\n\n\nint\nhashCode()\n\n\nint\nindexOf(int ch) 返回字符ch在当前字符串中第一次出现的索引值\n\n\nint\nindexOf(String str) 返回字符串str在当前字符串中第一次出现的索引值\n\n\nString\nintern() 返回字符串对应的常量.\n\n\nboolean\nisEmpty() 判断 是否为空串,是否长度为0.\n\n\nint\nlastIndexOf(int ch) 返回字符ch在当前字符串中最后一次出现的索引值\n\n\nint\nlastIndexOf(String str)\n\n\nint\n length() 返回字符串中字符的个数\n\n\nboolean\nmatches(String regex) 判断字符串是否匹配正则表达式.\n\n\nString\nreplaceAll(String regex, String replacement) 把符合regex正则表达式的字符串都替换为replacement\n\n\nString\nreplaceFirst(String regex, String replacement)\n\n\nString[]\nsplit(String regex) 使用regex正则表达式把字符串分隔\n\n\nboolean\nstartsWith(String prefix) 判断是否以指定的字符串开始.\n\n\nString\nsubstring(int beginIndex) 返回从beginIndex开始的子串.\n\n\nString\nsubstring(int beginIndex, int endIndex) 返回[beginIndex, endIndex)范围内的子串\n\n\nchar[]\ntoCharArray() 把字符串转换为字符数组\n\n\nString\ntoLowerCase() 把字符串中 的大写字母转换为小写字母\n\n\nString\ntoString()\n\n\nString\ntoUpperCase() 小写转大写\n\n\nString\ntrim() 去掉字符串前面和后面的空白字符\n\n\nstatic String\nvalueOf(int i) 把基本类型转换为字符串\n\n\nstatic String\nvalueOf(Object obj) 把对象转换为字符串\n\n\n","categories":["-javase"],"tags":["基础","java","String类"]},{"title":"最接近三数之和--016","url":"http://example.com/2020/11/05/LC016-1105-最接近三数之和/","content":"最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n示例：\n输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。\n\n\n\n排序和双指针  \n\n本题要计算三个数,暴力枚举的话时间复杂度会到 O(n^3)，需要降低时间复杂度\n\n首先进行数组排序，时间复杂度 O(nlogn)\n在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 nums[i]\n再使用前指针指向 start = i + 1 处，后指针指向 end = nums.length - 1 处，也就是结尾处\n根据 sum = nums[i] + nums[start] + nums[end] 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans\n同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end–，如果 sum &lt; target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果\n整个遍历过程，固定值为 n 次，双指针为 n 次，时间复杂度为 O(n^2)\n总时间复杂度：O(nlogn) + O(n^2) = O(n^2)\n\n时间复杂度：O(N^2)\n空间复杂度：O(\\log N)    排序需要使用 O(log N)的空间\npublic int threeSumClosest(int[] nums, int target) &#123;       Arrays.sort(nums);       int num = nums[0] + nums[1] + nums[2];       for (int i = 0; i &lt; nums.length; i++) &#123;           //指针指向 start = i + 1 处，后指针指向 end = nums.length - 1 处，也就是结尾处           int start = i + 1, end = nums.length-1;           while (start &lt; end) &#123;              //根据 sum = nums[i] + nums[start] + nums[end] 的结果，               // 判断 sum 与目标 target 的距离，如果更近则更新结果 num               int sum = nums[start] + nums[end] + nums[i];               if (Math.abs(target - sum) &lt; Math.abs(target - num))                   num = sum;               //判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end--，               // 如果 sum &lt; target 则 start++，               if (sum &gt; target)                   end--;               else if (sum &lt; target)                   start++;               else                   return num;           &#125;       &#125;       return num;   &#125;\n\n","categories":["-算法"],"tags":["LeetCode","双指针","排序"]},{"title":"删除排序数组中的重复项--026","url":"http://example.com/2020/11/05/LC026-1105-删除重复项/","content":"删除排序数组中的重复项给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。\n\n双指针  \n\n\n首先注意数组是有序的，那么重复的元素一定会相邻。\n\n要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n\n考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：\n\n1.比较 p 和 q 位置的元素是否相等。\n\n如果相等，q 后移 1 位如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位重复上述过程，直到 q 等于数组长度。\n\n返回 p + 1，即为新数组长度。\n\n\n时间复杂度：O(n)。空间复杂度：O(1)。\nclass Solution &#123;    public int removeDuplicates(int[] nums) &#123;        int p=0;        int q=1;        //排除非法数组        if (nums == null || nums.length == 0) &#123;            System.out.println(&quot;0&quot;);        &#125;        while (q &lt; nums.length) &#123;            if (nums[p] != nums[q]) &#123;                if(q-p&gt;1)&#123;//判断中间两个数字直接是否由数字减少交换的次数                    //例如  0\t1\t2\t3\t4\t5                    //0 和 1 不相等 就不交换                        nums[p + 1] = nums[q];                                       &#125;                 p++;            &#125;            q++;        &#125;       return  p+1;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode","双指针"]},{"title":"LC011-1103-最大容器","url":"http://example.com/2020/11/03/LC011-1103-最大容器/","content":"盛最多水的容器给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器。\n   \n\n示例 1：\n\n输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n思路算法流程： 设置双指针i.j分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 area，直到 i==j时返回area。\n指针移动规则与证明：\n指针移动规则与证明： 每次选定围成水槽两板高度 h[i]h[j]中的短板，向中间收窄 11 格。以下证明：\n设每一状态下水槽面积为 S(i, j),(0 &lt;= i &lt; j &lt; n)，由于水槽的实际高度由两板中的短板决定，则可得面积公式 S(i, j) = min(h[i], h[j]) × (j - i)\n在每一个状态下，无论长板或短板收窄 1 格，都会导致水槽 底边宽度 −1：\n若向内移动短板，水槽的短板 min(h[i], h[j])可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。\n若向内移动长板，水槽的短板 min(h[i], h[j])不变或变小，下个水槽的面积一定小于当前水槽面积。\n因此，向内收窄短板可以获取面积最大值。换个角度理解：\n因为短指针已经限制了高度，如果移动高指针不可能增加整体的高度，而底在不断减少，所以移动短指针来尝试增加最大高度\nclass Solution &#123;    public int maxArea(int[] height) &#123;              int i = 0;        int j = (height.length - 1);        int area=0;        while (i &lt; j) &#123;            area = (height[i] &lt; height[j]) ? Math.max(area , (j - i) * height[i++]) :            \t\t\t\t\t\t\t\t Math.max(area, (j - i) *height[j--]);        &#125;        return area;    &#125;&#125;\n\n双指针法正确性证明复杂度分析：\n\n时间复杂度 O(N)，双指针遍历一次底边宽度 N 。\n\n空间复杂度 O(1)，指针使用常数额外空间。\n\n\n  \n  \n  \n  \n  \n\n\n\n","categories":["-算法"],"tags":["LeetCode","双指针"]},{"title":"操作系统1.1_2操作系统四个特征","url":"http://example.com/2020/11/03/操作系统1-1-3/","content":"操作系统的发展与分类\n\n手工操作阶段输入输出速度慢\n\n缺点:用户独占全机,人机速度矛盾造成的资源利用率低\n\n\n\n批处理阶段单道批处理系统引用脱机输入/输出技术(用磁带完成),并监督程程序责控制作业的输入,输出\n督程程序==操作系统的雏形\n  \n\n\n主要优点:缓解了一定程度上的人机速度矛盾,资源利用率有所提升\n主要缺点:内存中仅能有一道程序运行,只有该程序运行结束之后才能调用下一道程序,cup中有大量的时间时空闲等待I/O完成,资源利用率低\n\n\n\n多道批处理系统每次往内存中输入多道程序–&gt;操作系统正式诞生,并引用了中断技术,由操作系统负责管理这些程序的运行,各个程序并发执行\n主要优点:多道程序并发执行,共享计算机资源,资源利用率大幅提升,CPU和其他资源保持”忙碌”状态,系统吞吐量增大\n主要缺点:用户响应时间长,没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成,中间不能控制自己的作业执行)\n为何多道批处理系统使用资源利用率大幅度提高.\n\n\n\n\n\n\n\n\n分时操作阶段计算机以时间为单位轮流为各个用户/作业服务,多个用户可通过终端与计算机进行交互.\n优点:解决了人机交互问题\n缺点:**不能优先处理一些紧急的任务.**操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。\n\n\n实时操作阶段主要优点:能够优先相应一些紧急任务,\n在实时操作系统的控制下,计算机系统接收外部信号后及时处理,并且要在严格的时限内处理完事件,实时系统操作的主要特点及时性和可靠性\n\n\n\n\n网络操作阶段网络操作系统:是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享)和各台计算机之间的通信。(如: Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）\n\n\n分布式操作阶段分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。\n\n\n个人计算机操作系统个人计算机操作系统:如 Windows XP、MacOs，方便个人使用。\n\n\n","categories":["-操作系统"],"tags":["基础"]},{"title":"javaSE-12-API常用类|默认继承Object|toString()|==与equals()","url":"http://example.com/2020/11/02/javaSE12/","content":"API_常用类\nAPI应用程序编程接口\n\nAPI文档\n\n是对Java预定定义的类或接口功能和方法功能的说明文档,目的是提供给开发人员进行使用帮助说明\n\nObjectArrays类String类/StringBuffer类/StringBuilder类Math类/Random类/System类Date类/Calendar类/ SimpleDateFormat类BigInteger/BigDecimal\n\n\n默认继承Object,Java中所有类没有显示的继承类,默认继承Object,因为要实现多态(Object类型,可以表示任何类型)\n\n\n\n\npublic class ObjectDemo extends Object&#123;    public static void main(String[] args) &#123;         ObjectDemo obj = new ObjectDemo();         int[] a = new int[5];//数组也是继承了Object               a.hashCode();&#125;\n\ntoString();输出对象时:会自动调用对象中的toString();如果对象中没有,则会调用Object类中的toString(),对象中的hashCode值转为16进制\nreturn getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\n\n 我们为了显示更简单 ,可以在子类中重写toString(),从而调用子类中的.\npublic class Person extends  Object&#123;    String name;    int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nPerson p &#x3D; new Person(&quot;jim&quot;,18);System.out.println(p);System.out.println(&quot;info&#x3D;&#x3D;&#x3D;&quot;+p);\n\n输出\nPerson&#123;name=&#x27;jim&#x27;, age=18&#125;info===Person&#123;name=&#x27;jim&#x27;, age=18&#125;\n\n\n\n\n\n==与equals()\njava基本类型\n比较包装类型\n比较String类型\n比较对象\n\nJava基本类型\nbyte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。\n\n比较包装类型\n==基本类型比较的就是具体的值.\n==再对引用类型进行比较的时,比较的时引用的对象地址是否相同\nequals()一般类重写Object类中equals(),他们有自己的方式,比较的时对象中包含的类容(仅限类容)是否相同\n\nString s1 = new String(&quot;abc&quot;);String s2 = new String(&quot;abc&quot;); // == 基本类型比较的就是具体的值 // == 再对引用类型进行比较时,比较的是引用的对象地址是否相同System.out.println(s1==s2); //一般类都重写Object类中equals(), 他们有自己的实现方式,比较的是对象中包含的内容(具体值)是否相等System.out.println(s1.equals(s2));\n\n输出\nfalsetrue\n\n附件:equals源码public boolean equals(Object anObject) &#123;        if (this == anObject) &#123;            return true;        &#125;        if (anObject instanceof String) &#123;            String anotherString = (String)anObject;            int n = value.length;            if (n == anotherString.value.length) &#123;                char v1[] = value;                char v2[] = anotherString.value;                int i = 0;                while (n-- != 0) &#123;                    if (v1[i] != v2[i])                        return false;                    i++;                &#125;                return true;            &#125;        &#125;        return false;    &#125;\n\n比较String类型==比较的是内存地址，equal比较的是值\nString s3 = new String(&quot;abc&quot;);   String s4 = new String(&quot;abc&quot;);   System.out.println(s3==s4);//false   System.out.println(s3.equals(s4));//true   String  s1 = &quot;abc&quot;;   String  s2 = &quot;abc&quot;;   System.out.println(s1==s2);//true   System.out.println(s1.equals(s2));//true\n\nString类\nJava中所有字符串,都是String类的对象,值一旦给给定就不能改变,一旦修改描绘重新创建一个新的对象\n两种创建方法:\n\nString s = “abc”;\n第一种先在栈中创建一个对String类的对象引用变量s,然后去查找”abc”是否被保存在**字符串常量池中,**如果没有则在堆中创建一个String对象object，\n第二次创建时,常量池已经存在,直接让引用变量指向已有的字符串对象\n\n特点\njvm会自动根据栈中数据的实际情况来决定是否有必要创建新对象\n\n\n\nString s = new String(“abc”)\n一概在队中创建新对象,而不管其字符串值是否相等，是否有必要创建新对象。\n\n\n","categories":["-javase"],"tags":["基础","java","面向对象"]},{"title":"十大排序-插入排序","url":"http://example.com/2020/11/02/十大排序03插入/","content":"十大排序-插入排序插入排序Insertion Sort基本思想:在要排序的一组数中,假定前n-1个数已经排好序,现将第n个数插到前面的有序数列中,使得这n个数也是排好顺序.\n算法描述\n从第一个元素开始,该元素可以被认为已经被排序\n取出下一个元素,在已经排序的元素序列中从后向前扫描\n如果该元素(已排序)大于新元素,将该元素移动到下一位置\n重复步骤三,直到直到已经排序的元素最小或者等于新元素的位置\n将新元素插入到该位置后\n重复步骤2~5\n\n\n\n\n代码private static int[] insertionSort(int[] a) &#123;    int current;//现在记录的数    for (int i = 0; i &lt; a.length - 1; i++) &#123;        current = a[i + 1];//需要进行比较插入的数        int preIndex = i;//与需要插入的数的 进行比较的下标        while (preIndex &gt;= 0 &amp;&amp; current &lt; a[preIndex]) &#123;            a[preIndex + 1] = a[preIndex];            preIndex--;        &#125;        a[preIndex + 1] = current;    &#125;    return a;&#125;\n\n总结:平均时间复杂度O(n^2^)\n最好情况    O(n)\n最坏情况    O(n^2^)\n空间复杂度    O(1)\n排序方式    ln-place\n稳定性    稳定\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"十大排序-选择排序","url":"http://example.com/2020/11/02/十大排序02选择/","content":"十大排序-选择排序Selection Sort基本思想:\n选择排序Selection Sort时一种简单直观的排序算法.\n首先在末排序序列中找到最小(大)元素,\n然后存放在排序序列中起始位置,\n在从我i排序中继续寻找最小(大)的元素,然后放到已排序序列的末尾,\n重复以上方法直到所有元素均排序完毕.\n\n\n\n\n代码代码一\nprivate static int[] selectionSort(int[] a) &#123;        //小的往前放        for (int i = 0; i &lt; a.length - 1; i++) &#123;            for (int j = i + 1; j &lt; a.length; j++) &#123;                if (a[i] &gt; a[j]) &#123;                    int temp = a[i];                    a[i] = a[j];                    a[j] = temp;                &#125;            &#125;        &#125;        return a;    &#125;\n\n代码二[优化1]\nprivate static int[] selectionSort1(int[] a) &#123;      for (int i = 0; i &lt; a.length - 1; i++) &#123;          int minSub = i;//最小的下标          //标记每趟的最小值          for (int j = i + 1; j &lt; a.length; j++) &#123;              if (a[minSub] &gt; a[j]) &#123;                  minSub = j;              &#125;          &#125;          //将遍历的最小放到数组的最前面 进行位置交换          int temp = a[i];          a[i] = a[minSub];          a[minSub] = a[i];      &#125;      return a;  &#125;\n\n总结:平均时间复杂度O(n^2^)\n最好情况    O(n^2^)\n最坏情况    O(n^2^)\n空间复杂度    O(1)\n排序方式    ln-place\n稳定性    不稳定\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"十大排序-冒泡排序","url":"http://example.com/2020/11/02/十大排序01冒泡/","content":"十大排序-冒泡排序冒泡排序Bubble Sort基本思想:两个数比较大小,较大的数下沉,较小的数冒起来\n思路描述:\n\n比较两个相邻的元素,如果第一个比迪二个大,就交换他们两个\n对没一对相邻元素作同样的工作,从开始第一对到结束的最后一对,这样在最后元素应该会是虽大的数\n针对所有的元素重复以上的步骤,除了最后一个;\n重复步骤1~3,直到排序结束\n\n\n\n\n代码实现代码一[未优化]public static int[] bubbleSort(int[] array) &#123;    for (int i = 0; i &lt; array.length; i++) &#123;        for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;            if (array[j] &gt; array[j + 1]) &#123;                int temp = array[j];                array[j] = array[j + 1];                array[j + 1] = temp;            &#125;        &#125;    &#125;    return array;&#125;\n\n代码二[优化1]\n如果原来的数组时有序数组1   2   3   4\n如果按照原来的方法bubbleSort,还是要遍历n-1趟,有点浪费时间\n于是,每跑完一趟,就判断一次数组现在是否有序,如果有序;\n直接return   设置一个标签flag 进行判断\n\nprivate static int[] bubbleSort1(int[] array) &#123;        for (int i = 0; i &lt; array.length; i++) &#123;            int flag = 0;//判别的标签            for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;                if (array[j] &gt; array[j + 1]) &#123;                    int temp = array[j];                    array[j] = array[j + 1];                    array[j + 1] = temp;                    flag = 1;//如果发生交换，标签值改变                &#125;            &#125;            if (flag == 0) &#123;//如果这趟走完，没有发生交换，则原数组有序；                return array;            &#125;        &#125;        return array;    &#125;\n\n代码三[优化2]针对代码2的优化\n原数组: 4    3    2    5    6\n第一趟:3    2    4    5    6       第一次交换后发生在2 和4 记住2的下标j\n第二趟:2    3    4    5    6       第二次   内部比较的时候,只比较j次:下标从 j到最后的已经有序了,就不需要进行比较了\n按照上面的描述可以较少比较的次数,从而达到需要的优化\nprivate static int[] bubbleSort2(int[] array) &#123;       int n = 0;       int k = array.length - 1;       for (int i = 0; i &lt; array.length; i++) &#123;           int flag = 0;//判别的标签           for (int j = 0; j &lt; k; j++) &#123;               if (array[j] &gt; array[j + 1]) &#123;                   int temp = array[j];                   array[j] = array[j + 1];                   array[j + 1] = temp;                   flag = 1;                   n = j;               &#125;           &#125;           if (flag == 0) &#123;               return array;           &#125;           k = n;       &#125;       return array;   &#125;\n\n\n\n总结:平均时间复杂度O(n^2^)\n最好情况    O(n)\n最坏情况    O(n^2^)\n空间复杂度    O(1)\n排序方式    ln-place\n稳定性    稳定\n","categories":["-算法"],"tags":["排序","十大排序"]},{"title":"javaSE-11-数组","url":"http://example.com/2020/10/31/javaSE10/","content":"数组概念:\n相同数据类型元素的集合,多个数据\n引用数据类型,对象,,,数组可以存储基本数据类型,也可以储存引用数据类型\n\n**是一种线性数据结构,**在内存空间是连续的\n作用:储存多个数据,并且类型相同\n声明方式:\nint[]    a;     ||    数据类型[]  数组名字    ||    建议使用第一种\n数据类型数组中的数据类型\n\nint    a[];     ||    数据类型 数组名字[]\n\n\n\n\nJava数组在创建时必须给给定的长度,一旦定义就不可修改    \n在内存空间中是一个连续的空间 为其中每个存储空间初始化值\n\n\n\n变量的数据类型\n默认初始化值\n\n\n\nbyte\n0\n\n\nshort\n0\n\n\nint\n0\n\n\nlong\n0\n\n\ndouble\n0.0\n\n\nfloat\n0.0\n\n\nboolean\nfalse\n\n\nchar\n\\u0000(空格的UNICODE码)\n\n\nstring\nnull\n\n\n\nint [] a=new int[10];  堆空间创建了一个数组对象,有10连续的空间. 初始化和为零\n\n创建方式:\nint[] a = new int[10];\n堆空间创建了一个数组对象,有10连续的空间. 初始化和为零\n数据类型和前面的声明类型对应  int[] a 数组数据为int,元素都是默认的初始化值\n\nint[] arry = new int[]{1, 3, 4, 5, 24};\n在创建时直接初始化,根据内容的数量,确定数组的长度,分配内存，同时将其初始化\n\nint[] arr2 = {1, 2, 34, 5, 6};\n简写\n\n\n将对象(数组)以字符串的形式进行输出\nSystem.out.println(Arrays.toString(a))\n\n案例:\nimport java.util.Arrays;public class Array01 &#123;    public static void main(String[] args) &#123;        //创建的三种方式        //int[] a = new int[10];        //堆空间创建了一个数组对象,有10连续的空间. 初始化和为零        //数据类型和前面的声明类型对应  int[] a 数组数据为int,元素都是默认的初始化值        int[] a = new int[10];        //将对象(数组)以字符串的形式进行输出        System.out.println(Arrays.toString(a));        boolean[] b = new boolean[10];        System.out.println(Arrays.toString(b));        //在创建时直接初始化,根据内容的数量,确定数组的长度,分配内存，同时将其初始化        int[] arry = new int[]&#123;1, 3, 4, 5, 24&#125;;        //简写        int[] arr2 = &#123;1, 2, 34, 5, 6&#125;;        System.out.println(Arrays.toString(arry));        System.out.println(Arrays.toString(arr2));    &#125;&#125;\n\n\n\n\n一旦创建对象创建就会在堆空间中有一个存储位置,\n如果存储的是引用类(类类型),会存储对向的引用\n数组中如果存储的是基本类型,存储的是具体的值\n\n车类\npublic class Car &#123;     private String name;    public Car(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    //重写Object类toString()方法    @Override    public String toString() &#123;        return &quot;Car :name=&quot;+this.name;    &#125;&#125;\n\n引用类\nCar car0 = new Car(&quot;car0&quot;);//一旦创建对象创建就会在堆空间中有一个存储位置 Car car1 = new Car(&quot;car1&quot;); Car car2 = new Car(&quot;car2&quot;); Car car3 = new Car(&quot;car3&quot;); Car car4 = new Car(&quot;car4&quot;);          //如果存储的是引用类(类类型),会存储对向的引用 Car[] cars = new Car[]&#123;car0,car1,car2,car3,car4&#125;; System.out.println(Arrays.toString(cars));\n\n数组的访问:\n数组名字[索引]    例如：a[0],a[1];\n\n注意\n\n数组的索引从0开始。\n索引的数据类型是整型\n索引最大值和数组长度始终差1\n\n注意使用合法的索引访问,否则会程序终止,抛出异常\n 数组越界:ArrayIndexOutOfBoundsException\n数组迭代的两种方式：第一种:for循环int [] a = &#123;1,2,3,4,5,6,7&#125;;               // 0 1 2 3 4 5 6      for (int i = 0; i &lt; a.length; i++) &#123;          System.out.println(a[i]);//取出数组第i个元素      &#125;\n\n第二种：增强for循环for(数组元素的类型  临时变量名字 ：数组的名字){System.out.println(临时变量名字 );}\nfor (int item :a) &#123;          System.out.println(item);      &#125;\n\n","categories":["-javase"],"tags":["数组","基础","java"]},{"title":"LC005-最大回文子串","url":"http://example.com/2020/10/30/LC005-最大回文子串/","content":"5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。\n\n\n\n方法一:暴力匹配法思路分析:\n\n\n\n根据回文子串的定义,美剧所有长度大于等于2的长度,依次判断他们是否是回文\n只针对当前得到的最长回文子串长度的子串进行”回文验证”.\n在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。\n\npackage com.nie.Leec.exercise;public class lee_005 &#123;    public static void main(String[] args) &#123;        String str = &quot;babad&quot;;        lee_005 a = new lee_005();        System.out.println(a.longestPalindrome(str));    &#125;    public String longestPalindrome(String s) &#123;        int len = s.length();        if (len &lt; 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        //先将字符串转换成数组        char[] charArray = s.toCharArray();        for (int i = 0; i &lt; len - 1; i++) &#123;   //第一个数子,当开始比如  babad中表示b 一直往后遍历一直到结束            for (int j = i + 1; j &lt; len; j++) &#123;//在一次循环中,babad   第一个遍历到b 第二个循环就有其后紧邻的开始遍历 即b                //j-i+1&gt;maxLen判断是否比保存的长度长,,如果长,,进行判断是否是回文                if (j - i + 1 &gt; maxLen &amp;&amp; validPalidromic(charArray, i, j)) &#123;                    maxLen = j - i + 1;//目前最长的回文的长度                    begin = i;//回文开始的位置                &#125;            &#125;        &#125;        return s.substring(begin, maxLen + begin);    &#125;    private boolean validPalidromic(char[] charArray, int left, int right) &#123;        while (left &lt; right) &#123;            if (charArray[left] != charArray[right]) &#123;  //进行截取的                return false;            &#125; else &#123;                left++;                right--;            &#125;        &#125;        return true;    &#125;&#125;\n\n复杂度分析:\n时间复杂度:O(N^3),这里 NN 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 NN 相关；\n空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。\n\n\n\n方法二:动态规划主要思想:主要思想:一旦在一个回文串的两端,对称的加上相同的元素,那么新形成的字符串仍然是一个回文串\n方法:设定两个下标,从左到右扫描,一旦i和j下标重回,那么i下标移动的头部,从头开始扫描,j下标向后移动一个元素\n当i下标和j下标指向的元素相同的时候,判断除去这两个相同元素剩下的字符串是否是回文串,,如果是,那么最长回文串就是当前形成的新串,,如果不是则继续扫描.\n分布思路\n先考虑题目的特解，本题的特解要考虑字符串为空串和字符串为1的情况，这两种情况都符合题意，所以直接返回字符串s。\n\n声明两个变量maxLen为最大长度，begin为最大长度的回文的开始位置\n\n二维数组dp[][],dp[i][j]为下标i到j的位置上的字符为回文 ,,初始化的dp[i][i],因为单个字符串必然为回文\n\n两重循环,j从第二个字符（下标为1）一直遍历到字符串末尾，同时保证 i从0遍历到j-1(i&lt;j)。\n\ndp[i][j]为回文的判定条件第一个就是c[i] == c[j] ，符合这一条件的继续判定，不符合的直接置为false\n\nj-i&lt;3，说明 j-i+1&lt;4, 表明i到j没有4个字符，i到j中间只有0个或者1个字符，上一步已经判定c[i] == c[j]，所以dp[i][j]必为回文，置为true。\n\n边界条件为 j-i&gt;=3，即j-i+1&gt;=4,i到j至少有4个字符。这种情况下dp[i][j]要为回文，dp[i+1][j-1]必须为回文，即dp[i][j] = dp[i + 1][j - 1] 同正同错。\n\n当dp[i][j]为回文且 i到j的字符串个数大于当前维护的最大长度，即 j-i+1&gt;maxLen时候，需要把maxLen这个最大长度改为i到j的个数（j-i+1），开始位置begin改为i。\npublic class Solution &#123;    public String longestPalindrome(String s) &#123;        // 特判        int len = s.length();        if (len &lt; 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        // dp[i][j] 表示 s[i, j] 是否是回文串        boolean[][] dp = new boolean[len][len];        char[] charArray = s.toCharArray();        for (int i = 0; i &lt; len; i++) &#123;            dp[i][i] = true;        &#125;        for (int j = 1; j &lt; len; j++) &#123;            for (int i = 0; i &lt; j; i++) &#123;                if (charArray[i] != charArray[j]) &#123;                    dp[i][j] = false;                &#125; else &#123;                    //j-i&lt;3，说明 j-i+1&lt;4, 表明i到j没有4个字符，i到j中间只有0个或者1个字符，                    //上一步已经判定c[i] == c[j]，所以dp[i][j]必为回文，置为true。                    if (j - i &lt; 3) &#123;                        dp[i][j] = true;                    &#125; else &#123;                        // j-i&gt;=3，即j-i+1&gt;=4,i到j至少有4个字符。这种情况下dp[i][j]要为回文，                        //dp\\[i+1]\\[j-1]必须为回文，即dp\\[i]\\[j] = dp\\[i + 1]\\[j - 1] 同正同错。                        dp[i][j] = dp[i + 1][j - 1];                    &#125;                &#125;                // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;                    maxLen = j - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substring(begin, begin + maxLen);    &#125;&#125;\n\n\n\n复杂度分析:\n时间复杂度:O(N^2);\n空间复杂度:O(N^2^),二维数组,因此空间复杂度为O(N^2^);\n\n总结:\n用动态规划解题问题,有的时候并不是直接面向问题的\n动态规划依然是(空间换取时间)的思想的体现,而且本身动态规划就是一种打表格,就是空间换取时间\n动态规划的本质还是(暴力解法),因为需要枚举左右边界,有O(N^2^);\n\n方法三:中心扩散法文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。\n\n\n奇数回文串的“中心”是一个具体的字符，例如：回文串 “aba” 的中心是字符 “b”；\n偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 “abba” 的中心是两个 “b” 中间的那个“空隙”。\n\npublic class Solution &#123;    public String longestPalindrome(String s) &#123;        int len = s.length();        if (len &lt; 2) &#123;            return s;        &#125;        int maxLen = 1;        String res = s.substring(0, 1);        // 中心位置枚举到 len - 2 即可        for (int i = 0; i &lt; len - 1; i++) &#123;            String oddStr = centerSpread(s, i, i);            String evenStr = centerSpread(s, i, i + 1);            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;            if (maxLenStr.length() &gt; maxLen) &#123;                maxLen = maxLenStr.length();                res = maxLenStr;            &#125;        &#125;        return res;    &#125;    private String centerSpread(String s, int left, int right) &#123;        // left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数//左边        // right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数        int len = s.length();        int i = left;        int j = right;        while (i &gt;= 0 &amp;&amp; j &lt; len) &#123;            if (s.charAt(i) == s.charAt(j)) &#123;                i--;                j++;            &#125; else &#123;                break;            &#125;        &#125;        // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j        return s.substring(i + 1, j);    &#125;&#125;\n\n复杂度分析\n时间复杂度:O(N^2^),枚举”中心位置”时间复杂度O(N),由中心位置扩展到回文O(N),,,,,所以为O(N^2^)\n空间复杂度O(1)，只使用到常数个临时变量，与字符串长度无关。\n\n","categories":["-算法"],"tags":["LeetCode","动态规划","双指针"]},{"title":"操作系统1.1_2","url":"http://example.com/2020/10/30/操作系统1-1-2/","content":"操作系统四个特征\n并发{最基本的特征}\n共享{最基本的特征}\n虚拟\n异步\n\n操作系统的特征–并发\n并发:是指两个或者多个事件在同一时间间隔内发生,这事件宏观上是同时发生的,但是微观上是交替发生的.\n并行:是两个或者多个事件在同时同刻发生\n\n操作系统的并发性:是指计算机系统中同时存在着多个运行的程序.操作系统和程序的并发是一起诞生的.\n  \n\n操作系统的特征–共享共享资源共享方式:\n\n互斥共享方式\n系统中的某些资源,虽然可以提供给多个进程使用,但一个时间段内只允许一个进程访问资源\n\n同时共享方式\n系统中的某些资源,允许一个时间段内由多个进程”同时”对他们进行访问\n\n\n并发和共享的关系\n并发:计算机系统中同时存在多个运行的程序\n共享:系统资源可以提供内存中多个并发执行的进程共同使用(需要共享的访问硬盘资源)\n\n操作系统的特性–虚拟虚拟:是指把一个物理上的实体变为若干个逻辑上的对应物.物理实体(前者)是实际存在的,在逻辑上对应物(后者)是用户感受.\n一个程序需要放入内存并给他分配CPU才能执行\n\n虚拟技术中的”空分复用技术”\n虚拟技术中的”时分复用技术”,微观上处理机在各个微小的时间段内交替着为各个进程服务——–\n如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性\n\n\n\n操作系统的特性–异步异步:在多道程序环境下,允许多个程序并发操作,但由于资源有限,进程的执行不是一贯到底的,而是走走停停,以不可预知的速度向前推进,这就是进程的异步性.\n显然.如果失去了并发性,则系统只能串行的处理各个进程,每个进程的执行会一贯到底,只有系统拥有并发性,才有可能导致异步性.\n\n没有并发和共享,就谈不上虚拟和异步,因此并发和共享是操作系统的两个最基本的特征\n","categories":["-操作系统"],"tags":["基础"]},{"title":"操作系统1.1_1概念功能和目标","url":"http://example.com/2020/10/30/操作系统1-1-1/","content":"操作系统的概念功能和目标熟悉的操作系统:windows,安卓,ios,linux\n概念\n应用程序:QQ,浏览器等\n操作系统:\n\n负责关系协调硬件,软件等计算机资源的工作\n\n  \n\n\n为上层的应用程序,用户提供简单易用的服务\n操作系统是系统软件,而不是硬件\n\n硬件:\n\ncpu,硬盘,内存等\n\n操作系统(**os)是指控制和管理整个计算机系统的而硬件和软件资源,并合理的组织调用计算机的工作和资源分配,以提供给用户和其他软件方便的接口和环境,它是计算机系统中最基本的系统软件**\n功能和目标\n操作系统作为计算机资源的管理者\n操作系统作为用户与计算机硬件之间的接口\n操作系统作为最接近硬件的层次\n\n\n1操作系统作为计算机资源的管理者提供功能:\n\n处理机管理\n储存器管理\n文件管理\n设备管理\n\n目标:安全,高效\n进程是一个程序的执行过程,执行前需要将该程序放到内存中,才能被cpu处理\n2作为用户和计算机硬件之间的接口提供功能:\n\n命令接口:[允许用户直接使用]\n\n联机命令接口\n脱机命令接口\n\n\n程序接口:[允许用户通过程序间接使用]\n命令接口程序接口统称为**”用户接口”**\n\nGUI(图形用户界面):[现代操作系统中最流行的图形用户接口]\n\n\n目标\n\n方便用户使用\n\n命令接口,允许用户直接使用\n联机命令接口;用户说一句,系统做一句 或者称为交互式命令接口\n脱机命令接口:用户说一堆,系统做一堆或者称为批处理命令接口\n\n程序接口:[允许用户通过程序间接使用]\n由一组系统调用组成(程序接口=系统调用) \n只能通过用户程序间接使用\n\n\n系统调用=系统调用命令=广义指令\nGUI(图形用户界面)\nGUI用户可以使用形象的图形界面进行操作,而不是需要记忆复杂的命令,参数\n\n\n操作系统作为最接近硬件的层次提供的功能和目标:实现对硬件机器的拓展\n通常把覆盖了软件的机器成为扩充机器,由称为虚拟机\n类比:\n硬件:催子,锯子,木头,定子    操作系统:优秀的工匠\n有点封装的思想\n操作系统对硬件机器的拓展:通过优秀工匠，这些简单的原料可以组织成房子、帆船、…………普通用户可直接使用工匠提供的房子、帆船      而无需关心这些东西在底层是怎么组织起来工作的\n\n\n总结\n","categories":["-操作系统"],"tags":["基础"]},{"title":"javaSE-10-抽象类-接口","url":"http://example.com/2020/10/29/javaSE09/","content":"final关键字\nfinal用于声明属性,方法和类,可以修饰类,修饰字段,修饰方法,修饰局部变量,修饰形参\n\n属性:定义就必须直接赋值或者在构造方法中进行赋值,并且后期不能修改,\n\n修饰修饰类,最终类,不能被继承,不能被定义为抽象类或者接口\n\n修饰字段,必须显示初始化,不能被修改,一般final与static同时修饰某个字段,所有字母都大写,表示final常量\n\n修饰方法:bueng子类不能被覆盖 能被子类继承\n\n修饰局部变量, 一旦初始化就不能再修改, 注意final修饰引用类型变量, 是指这个引用类型变量不能再指向其他对象,可以修饰它的属性值\n\n修饰方法形参, 在方法体中不能修改final形参的值\n\n\n\n\nfinal属性赋值:\n–在声明时同时赋值,往往与static一起使用\nfinal static int Num &#x3D; 10;\n\n\n\npackage com.nie.day5.demo06;public class Filal &#123;    //用于声明方法和类    //final修饰常量,常量值不能变,利用static 修饰 节省空间    final static int Num = 10;    final int a = 100;    public final void eat() &#123;        System.out.println(&quot;你好&quot;);    &#125;    //定义就必须直接赋值或者在构造方法中进行中进行赋值,后期不能修改    public void num(int a) &#123;//       this.a=1000;        System.out.println(a);    &#125;    //在方法参数前加final关键字,防止数据在方法题中被修改.    public void num1(final int b) &#123;//        b=11;    &#125;&#125;\n\n抽象类为什么定义抽象类?\n如果一个类中没有包含足够的信息来描绘一个具体的对象,这样的类就是抽象类\n\n抽象类除了不能实例化对象之外,类的其他功能依然存在,名成变量,成员方法和构造方法的访问方式和普通类一样.\n\n\n\n\n如何定义抽象类\n用abstract修饰的类就是抽象类,如果某个类中包含抽象方法,那么这个类就必须定义抽象类.\n\n\n\n为什么定义抽象方法:当一个类的某个操作无法具体实现时,这个操作可以定义为抽象方法,,使用abstract修饰方法, 只有方法的声明, 没有方法体\n\n抽象方法时一种特殊的方法:他只有声明,而没有具体的实现\n抽象方法必须用abstract关键字进行修饰\n\n\n\n如何使用抽象类\n抽象类一般作为其他类的父类存在,,\n子类继承了抽象类,子类需要重写抽象类中所有的抽象方法,如果没有重写所有的抽象方法子类也需要为定义抽象方法\n\n注意:\n抽象类中不一定含有抽象方法\n\n抽象类可以有成员属性和非抽象方法\n\n抽象类不能被实例化,但可以有构造函数.因为抽象类中含有无具体实现的方法,所以不能用抽象类创建对象\n\n抽象类不能创建对象:抽象类只能做基类,表示一种继承关系.\n\n构造方法和静态方法不可以用abstract,\n\n\n\n\nabstract与final不共存\n\n因为abstract不能实例bai化（没有构造方法），du需要有子类zhi来实现，而final为“最终的”，修饰类时表示不能被继承既没有子类，这两个就矛盾了。但是呢，一个abstract类里面可以有final关键字存在，前提是这个final修饰的方法必须在abstract类中已经实现，作用是继承它的子类不能重写这个方法\n\n\n\n\n\n[访问权限] abstract class 类名 &#123;\t\t成员列表\t&#125;public abstract class Shapes &#123;\tpublic abstract void draw();&#125;public abstract class Shapes &#123;\tpublic void draw()&#123;         //具体代码       &#125;&#125;\n\n然后我们定义个抽象类\n\n\n\n\n抽象类无法被直接实例化，我们可以让子类继承然后实例化子类\n\n然后我们实例化子类\n\n接口接口的基本概念:Java中只支单继承,如果向定义一些功能,想让一个子类都能继承实现,提供接口,这样我们就可以用一个子类去实现多个接口.**.可以理解为接口时特殊的抽象类.**这种抽象类中只包含常量和方法的定义,没有变量和方法的实现.\n接口设计时候:关系实现类有何做哟个,不关心内部细节,,,,,面向接口的约定而不考虑接口的具体实现.\n接口的定义:public interface Animal1 &#123;    //所有属性默认为: public static final    void eat1();    //所有方法都是：public abstract    void foo();&#125;\n\n\n\n\n定义接口:    interface\n[访问修饰符]  interface  接口名称  [extends 其他的接口名1,….其他的接口名n] &#123; \t        // 声明常量       // 抽象方法 &#125;\n\n接口使用 :implements\n[访问修饰符] class 类名 implements 接口名1，接口名2……&#123; &#125;\n\n结合继承：\n[访问修饰符] class 类名 extends 父类名 implements 接口名1，接口名2……&#123; &#125;\n\n\n\n\n\n接口的特性:接口不能被实例化,实现类必须重写接口的所有方法,实现类可以实现多个接口,接口中的变量都是静态.\n接口一\n/** * 本质上说接口就是一个抽象类, * 抽象类中只包含常量和方法的定义, * 没有变量和方法的实现 */public interface animal extends Animal1 &#123;    //所有属性默认为 public static final    // public static final int age=10;    //变量必须赋值    int age = 10;    //默认的为public  abstract    //抽象方法访问时必须进行重写    void eat();    public abstract void test();    //jdk8后接口可以使用默认方法,和静态方法    //比抽象方法更加灵活,根据功能方法进行选择    public default void test1() &#123;  //被子类重写        System.out.println(&quot;默认方法&quot;);    &#125;    public static void test2() &#123;//通过类名访问4        System.out.println(&quot;静态方法&quot;);    &#125;&#125;\n\n接口二\npublic interface Animal1 &#123;    //所有属性默认为: public static final    void eat1();    //所有方法都是：public abstract    void foo();&#125;\n\n接口三\npublic interface Animal2 &#123;    void  test3();&#125;\n\n类\n//定义为抽象类  或者//重写抽象方法/** * 一个类可以实现多个接口, * &lt;p&gt; * 一个类可以实现继承一个类 * 但是可以实现多个接口 */public class Dog implements animal, Animal1, Animal2 &#123;    //抽象方法访问时必须进行重写    @Override    public void eat() &#123;        System.out.println(&quot;抽象方法\\t吃&quot;);    &#125;    @Override    public void test() &#123;        System.out.println(&quot;抽象方法测试&quot;);    &#125;    @Override    public void eat1() &#123;    &#125;    @Override    public void foo() &#123;    &#125;    @Override    public void test3() &#123;    &#125;&#125;\n\n测试\npublic class Test &#123;    public static void main(String[] args) &#123;        Dog dog =new Dog();        dog.eat();        dog.test();        dog.test1();//默认方法//        animal.test2();//静态方法    &#125;&#125;\n\n接口的特性:\n接口是特殊的抽象类,当声明一个接口的时候必须要声明abstract关键字\n接口中每一个方法也是隐式抽象的,默认public   abstract 。jdk8以后有默认和静态方法   public static 方法,  public default方法\n接口中声明的属性默认为 public  static  final\n接口不能被继承,要被实现implements\n接口不能实例化对象(灭有构造方法),但是可以声明对象的引用(多态性)\n有接口多有多态。多态的条件（子类重写父类方法，继承，父类引用指向子类对象）因为接口中有抽象方法，所以必须要重写，实现（implements）可以理解为在接口环境下继承（extends）的另一个名字\n多个类可以使用一个接口\n一个类可以实现多个接口,但只能继承一个类\n一个类可以继承多个接口,,使用关键字extends，可以继承多个接口，使用 逗号 分割\n在类实现接口的时候,类要实现接口的所有方法,或者类必须设置为抽象类\n接口体现的是is-a的关系\n\n接口的好处\n快速增强子类功能,符合面向对象的思想\n可扩展性强,当需要增强原有类的功能不需要修改原有类的代码,只需要增加接口.\n\n接口和抽象类的区别:区别\n\n抽象类可以构造方法,接口不可以\n抽象类可以有普通成员变量,抽象类不行\n抽象类有非抽象的普通方法,而接口中所有的方法必须是抽象的(jdk8以后有默认和静态方法)\n抽象类中的抽象方法访问类型可以是public ，protected和默认类型,但接口中的抽象方法只能是public类型的\n抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义静态常量。\n\n不同点:\n\n意义不同\n\n抽象类是对事物更高层级的抽象\n接口是对功能的封装\n\n\n定义方式不同 \n\n抽象类用 abstract class定义 \n接口用interface定义\n\n\n内容不同  \n\n抽象类中除了抽象方法外,还可以定义构造方法等普通类中定义的所有成员   \n\n接口除了抽象方法等这四个内容外, 不能定义构造方法等内容  \npublic abstract修饰, 接口中还可以定义public static final常量 , public static 方法,  public default方法\n\n\n\n使用方式不同    \n\n抽象类需要被子类extends继承    \n接口需要被实现类implements实现\n\n\n类只支持单继承, 接口支持多继承\n\n应用场景不同    \n\n一般情况下, 对类进行功能的扩展,优先选择接口     \n除了扩展功能外, 还需要保存不同的数据,只能选择抽象类; \n抽象类的抽象方法需要子类重写, \n抽象类还可以约束所有的子类都具有相同的功能.\n\n\n\n相同点:\n​    1)都可以定义抽象方法\n​    2)都不能实例化对象,创建对象\n​    3)定义的抽象方法都需要被重写\n​    4)都可以定义public static方法, public static final常量 \n","categories":["-javase"],"tags":["基础","java","面向对象"]},{"title":"javaSE-09-包-面向对象三大特征","url":"http://example.com/2020/10/25/javaSE08/","content":"面向对象特征封装封装概念:\n封装,将类的某些信息隐藏在类内部,不允许外部访问,而且时通过该类提供的方法来实现对隐藏信息的操作和访问\n\n\n(封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。)\n\n\n优点:\n\n隐藏类的实现细节\n类内部的结构可以自由的修改\n可以对成员精确的控制\n只能通过规定方法访问\n良好的封装能够减少耦合\n\n\n\n具体表现\n属性使用private权限\n方法使用public权限\n\npublic class Person &#123;    private String name;    private int age;&#125;\n\n将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏\n其构造方法，及Setter，Gestter方法.即每个值属性提供对外的公共方法访问,也就是创建一堆赋值的方法,用于访问私有属性的访问,例如:\npublic class EncapTest&#123;    private String name;    private int age;​    public int getAge()&#123;      return age;    &#125;​    public String getName()&#123;      return name;    &#125;​    public void setAge(int age)&#123;      this.age = age;    &#125;​    public void setName(String name)&#123;      this.name = name;    &#125;&#125;\n\n this 关键字是为了解决实例变量（private String name）和局部变（setName(String name)中的name变量）之间发生的同名的冲突。\n测试:\npublic class RunEncap&#123;   public static void main(String args[])&#123;      EncapTest encap = new EncapTest();      encap.setName(&quot;James&quot;);      encap.setAge(20);      encap.setIdNum(&quot;12343ms&quot;);       System.out.print(&quot;Name : &quot; + encap.getName()+                              &quot; Age : &quot;+ encap.getAge());    &#125;&#125;\n\nthis关键字this关键字代表自身类的对象\n\n使用this关键字引用成员变量\n\n使用this关键字引用成员方法\n注意:this关键字必须放在非静态方法里面\n\n\n使用“this.成员变量名”这样的格式来引用成员变量名，,常常硬来区分同名的成员变量呵和局部变量\n继承继承是面向对象程序设计思想,是实现代码可重用的根基,是提高代码可扩展性的主要途径。并减少代码的冗余.\n\n继承是从已有的类中派生出新的类,新类能吸收已有类的属性和行为，并能扩展新的能力\nJava中使用extends关键字来表示继承关系\njava不支持多继承,一个子类只有一个父类\n继承后子类可以调用父类的所有非私有属性和非私有方法\n\n\n\n使用继承\n符合is-a关系的设计,使用继承\n\n将子类共有的属性和行为放到父类中\n例如: 猫是动物,   (子类)猫类的(父类)就是动物类\n继承是代码重用的一种方式\n\n\n继承形式[访问权限修饰符][修饰符]  子类名  extends  父类名&#123;子类体&#125;\n\n父类(动物类)\npublic class Animal &#123;    public void eat() &#123;        System.out.println(&quot;动物吃&quot;);    &#125;&#125;\n\n子类(猫类)\npublic class Cat extends Animal &#123;    public void play() &#123;        System.out.println(&quot;猫在玩耍&quot;);    &#125;&#125;\n\n测试\npublic class Test &#123;    public static void main(String[] args) &#123;        Cat cat=new Cat();        cat.play();//子类属性        cat.eat();//父类属性    &#125;&#125;\n\n专业术语cat类是 Animal类的子类, Animal类是cat类的父类 cat类是 Animal类的派生类, Animal类是cat类的基类\n继承传递性\n继承后子类可以调用父类的所有非私有属性和非私有方法,并别可以多层传递,,C类从B类继承,B类又从A类继承那么C类就具有B类和A类的所有非私有属性和非私有方法\n当一个类没有继承任何一个类时,jvm会默认让继承Object类…..Object是java为所有类提供的基类\n\nsuper关键字super关键字代表父类的引用,在程序中主要途径\n\n在子类构造中调用父类的构造方法,super语句只能出现子类构造方法体的第一行\n用”super.成员变量名”用来引用父类成员变量\n用”super.方法名(参数列表)”的方式访问父类的方法.\n与this的区别,this通常指代当前对象,super通常指代父类.\n\n方法的重写重写overRide 重载overload\n子类方法根据父类中继承的方法进行重写\n方法重写规则:\n\n方法名相同,参数相同\n\n返回值类型相同\n\n访问权限相同\n-即于父类方法结构完全相同\n注意:构造方法不能重写\n\n\n应用场景:当此父类的方法不能满足子类需求时,可以对方法进行重写(overRide)\npackage com.nie.day5.demo01;public class Animal1 &#123;    private String a;    private String eat;    public Animal1() &#123;        super();        System.out.println(&quot;Animal无参构造&quot;);    &#125;    public Animal1(String a) &#123;        this.a = a;        System.out.println(&quot;Animal有参构造&quot;);    &#125;    public void eat() &#123;        System.out.println(&quot;动物吃&quot;);    &#125;    public String getA() &#123;        return a;    &#125;    public void setA(String a) &#123;        this.a = a;    &#125;    public String getEat() &#123;        return eat;    &#125;    public void setEat(String eat) &#123;        this.eat = eat;    &#125;&#125;\n\n\n\npackage com.nie.day5.demo01;import com.nie.day4.demo1.demo02.Animal;public class dog extends Animal1 &#123;    /**     * 子类构造方法,先调用父类的构造方法,默认情况下调用父类的无参构造方法     * super 调用父类任意一个构造方法     */    public dog() &#123;        super();\t//- 用&quot;super.成员变量名&quot;用来引用父类成员变量\t\t\t\t\t//- 用&quot;super.方法名(参数列表)&quot;的方式访问父类的方法.        //super(&quot;d&quot;);//super语句只能出现子类构造方法体的第一行        System.out.println(&quot;dog无参构造&quot;);    &#125;      /**     * 重写override   重载 overload     * 方法名,参数列表相同     * 返回值类型相同     * 访问权限相同,   即父类的方法结构完全相同     *  注意::   构造方法不能重写     *     *  场景: 父类的方法不能满足子类的时,需要对方法进行重写     *     *     */    @Override//表示此方法有父类重写而来    public void eat()&#123;        System.out.println(&quot;狗吃&quot;);        super.eat();    &#125;    &#125;\n\n测试\npublic class Test &#123;     public static void main(String[] args) &#123;        dog a = new dog();        a.eat();    &#125;&#125;\n\nAnimal有参构造dog无参构造狗吃动物吃\n\n\n\n类之间关系–关联,依赖关联has-a\n\n对象与对象之间的连接,.在Java中,关联关系的代码表现形式为一个类做为另外一个类的属性类型存在….类与类之间的一种最常用的关系。\n即“有”的关系：”has-a”。\n\n关联关系为:关联关系的多重性\n\n单向关联,自关联  一对一关联：一个学生，只能在一个班级里学习。\n双向关联:可以调用对对方的公共属性和方法，例如知道对方的存在供货商和顾客\n\n双向关联\npublc class Customer&#123;\t//供货商对象数组作为顾客的属性成员\tprivate Supplier [] supplier;&#125;public class Supplier &#123;\tpublic Customer [] customer;&#125;\n\n单向关联\npublc class Customer&#123;\tprivate Address address;&#125;public class Address &#123;&#125;\n\n\n\n自关联\npublic class Customer&#123;private Customer customer;&#125;\n\n\n\n依赖use a 的关系为依赖关系\n\n依赖关系(使用关系), 指一个类A使用到了另一个类B\n\n依赖关系特性\n这种关系是具有偶然性的,临时性的,非常弱的,,但是类B的变化会影响到类A\n\n\n课表与课程之间:\nclass CourseTable&#123;\tpublic void addCourse(Course c)&#123;\t\tc.show();\t\tSystem.out.println(&quot;新增课程&quot;);\t&#125;\t\tpubilc void deCourse(Course c)&#123;\t\tc.show();\t\tSystem.out.println(&quot;删除课程&quot;);\t&#125;&#125;class Course&#123;\tSystem.out.println(&quot;课程为：&quot;);&#125;\n\n多态同一事物,在不同时刻表现不同的状态\n所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n\n多态存在的必要的三个条件:\n\n要有继承(前提条件)\n要有重写(前提条件)\n父类引用指向子类对象\n\n\n当编译类型是父类,运行类型是子类时,被称为父类引用指向子类对象\n多态环境下对成员方法的调用             编译看左边，运行看右边。\n多态环境下对静态成员方法的调用     简单的说：编译和运行都看左边。\n多态环境下对成员变量的调用      编译和运行都看等号左边。注意:变量不出存在被子类覆写说法,只存在覆盖\n\n方法的形参是父类类型,而传递的似乎实际参数可以是任意子类的对象\n方法参数多态性的好处:提高代码的扩展性\n父类(动物类)\npackage com.nie.day5.demo04;/** * 多态 * 同一种食物,在不同时刻表现不同的状态 * * 多态存在的三个必须的条件 * --要有继承 * --要有重写 * --父类指向子类对象 */public class Animal &#123;    int num=10;    public  void eat() &#123;        System.out.println(&quot;动物吃&quot;);    &#125;    static void show()&#123;        System.out.println(&quot;Animal&quot;);    &#125;    public  void fly()&#123;        System.out.println(&quot;动物飞了&quot;);    &#125;&#125;\n\n\n\n子类(猫)\npackage com.nie.day5.demo04;public class Cat extends Animal &#123;    int num = 5;    public void eat() &#123;        System.out.println(&quot;cat 吃&quot;);    &#125;    static void show() &#123;        System.out.println(&quot;静态成员方法&quot;);    &#125;    void  look()&#123;        System.out.println(&quot;看家&quot;);    &#125;&#125;\n\n子类(狗)\npackage com.nie.day5.demo04;/** * * --要有继承 *  * --要有重写 */public class Dog  extends  Animal&#123;    public  void eat() &#123;        System.out.println(&quot;小狗一号  吃&quot;);    &#125;&#125;\n\n子类(狗1)\npackage com.nie.day5.demo04;public class Dog1 extends Animal &#123;    public   void eat() &#123;        System.out.println(&quot;小狗二号  吃&quot;);    &#125;&#125;\n\n测试\npackage com.nie.day5.demo04;public class Test &#123;    public static void main(String[] args) &#123;        //父类指向子类对象        //父类     子类        Animal a = new Cat();        /**         * 多态环境下对成员方法的调用         * **编译看左边，运行看右边。**         */        a.eat();        /**         * 多态环境下对静态成员方法的调用         * **简单的说：编译和运行都看左边。**         */        a.show();        /**         * a.num    编译和运行都看等号左边         * 注意:变量不存在被子类覆盖写这一说法,只有方法存在覆盖         * 调用的是父类的成员变量         */        System.out.println(a.num);        Animal b = new Dog();        b.eat();        Animal c = new Dog1();        c.eat();        Test t = new Test();        t.method(a);    &#125;    //方法的形参是父类类型,而传递的是实际参数可以是任意子类的对象    //提高方法参数多态性的好处：提高代码的扩展性    public void method(Animal animal) &#123;        animal.eat();    &#125;&#125;\n\n向上转型,向下转型父类引用指向子类对象\n\n向上转型的作用是：提高程序的扩展性。\n向下转型的作用是:为了使用子类中特有的方法\n\npublic class Animal &#123;    int num=10;   void eat() &#123;        System.out.println(&quot;动物吃&quot;);    &#125;&#125;\n\npublic class Cat  extends Animal&#123;    int num = 5;   void  look()&#123;       System.out.println(&quot;看家&quot;);   &#125;&#125;\n\npackage com.nie.day5.demo05;public class Test &#123;//向下转型    public static void main(String[] args) &#123;        Animal a = new Cat();//向上转型        //多态的问题:父类类型不能访问子类特有的方法        //解决办法: 向下转型        String s = &quot;ads&quot;;        Object obj = s;        //   大类型 instanceof 小类型  判断检测大类型中是否包含的是具体的小类型        if (obj instanceof Cat) &#123;            Cat m = (Cat) a;//向下转型            m.look();        &#125; else &#123;            System.out.println(&quot;不是&quot;);        &#125;    &#125;&#125;","categories":["-javase"],"tags":["基础","java","面向对象"]},{"title":"javaSE-08-包-权限修饰符","url":"http://example.com/2020/10/23/javaSE07/","content":"包概念:文件夹,管理类\n包的作用:避免类重名,全类名=包名+类名,按照不同的功能管理类\nimport导入外部包,不能导入两个类名相同的类如果要用两个相同的类名,则用全名\n\n\nimport java.util.Date;/** * import 导入外部包, * 不能导入两个类名相同的类 * 如果要用两个相同的类名,则用全名 */public class Test &#123;    public static void main(String[] args) &#123;        Date b = new Date();        java.sql.Date c = new java.sql.Date(1000);    &#125;&#125;\n\n包（package）的命名规范：在包名中，可以使用.号来区级别；小写第一级 指该项目的类型，如com,org,gov等，第二级 指项目所开发或者运行的公司名称，如：oracle,sun,huawei等第三级 指项目的名称，如：bcms,oa,erp,cms等第四级 指项目模块的名称，如：bean,action,exception等\n访问权限修饰符权限从大到小依次为：\n1）public ：公共权限  可以被任意类访问    修饰类、属性、方法。2）protected：受保护的权限  ，如果不是同包类，必须是该类的子类才可以访问。 修饰属性、方法。可以被同包类访问3）default：同包权限 。只能被同包的类访问     修饰类、属性、方法4）private：私有权限  只能在本类中访问     修饰属性、方法。\n\n\n\n\npublic\nprotected\ndefault\nprivate\n\n\n\n同类\n可以\n可以\n可以\n可以\n\n\n同包\n可以\n可以\n可以\n\n\n\n不同包子类\n可以\n可以\n\n\n\n\n不同包的其他类\n可以\n\n\n\n\n\n\npackage com.nie.day3.Demo01.De01;public class De001 &#123;    /**     * public ：公共权限  可以被任意类访问    修饰类、属性、方法。     * protected：受保护的权限  ，如果不是同包类，必须是该类的子类才可以访问 修饰属性、方法。可以被同包类访问     * default：同包权限 。只能被同包的类访问\t 修饰类、属性、方法     * private：私有权限  只能在本类中访问 修饰属性、方法。     */    public int puName;    protected int proName;    int name;    private int prName;    public void test() &#123;        prName = 100;        proName = 100;        puName = 100;        name = 100;    &#125;&#125;\n\n\n\npackage com.nie.day3.Demo01.De01;public class De002 &#123;    De001 a=new De001();    public void test()&#123;        a.name=100;        a.puName=100;        a.proName=100;    &#125;&#125;\n\npackage com.nie.day3.Demo01.De02;import com.nie.day3.Demo01.De01.De001;public class De003 &#123;    De001 a &#x3D; new De001();    public void test() &#123;        a.puName &#x3D; 100;&#x2F;&#x2F;        a.proName 受保护,不同包的不同类不能访问    &#125;&#125;\n\n\n\npackage com.nie.day3.Demo01.De02;import com.nie.day3.Demo01.De01.De001;public class De004 extends De001 &#123;    public void test() &#123;        De004 a = new De004();        a.proName = 100;        a.puName = 100;//不同包的子类可被访问\\\\    &#125;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["-javase"],"tags":["基础","java","面向对象"]},{"title":"两个正序数组的中位数--004","url":"http://example.com/2020/10/23/LC004-1023-两个数组中位数/","content":"寻找两个正序数组的中位数难度困难3335\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？\n示例 1：\n输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2\n\n  \n\n示例 2：\n输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n\n\n\n\n解法一:思路:\n\n两个数组合并为一个有序数组\n通过判断奇数还是偶数进行返回中位数\n\n代码\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;    int[] nums; //分配一个新的数组,合并后的数组    int m = nums1.length;//长度    int n = nums2.length;    nums = new int[m + n];//新的数组的长度    /**     * 排除特殊的数据     */    if (m == 0) &#123;        if (n % 2 == 0) &#123;            return (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;        &#125; else &#123;            return nums2[n / 2];        &#125;    &#125;    if (n == 0) &#123;        if (m % 2 == 0) &#123;            return (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;        &#125; else &#123;            return nums1[m / 2];        &#125;    &#125;    int count = 0; //新数组的,下标    int i = 0, j = 0;    while (count != (m + n)) &#123; //当count=(n+m)时则表明,所有数据已经放入        if (i == m) &#123; //i表示数组一,当i=M时,则表明第一个数组已经全部放入子女数组            while (j != n) &#123;//后续继续放入第二个数组即可                nums[count++] = nums2[j++];            &#125;            break;        &#125;        if (j == n) &#123;//同上            while (i != m) &#123;                nums[count++] = nums1[i++];            &#125;            break;        &#125;        if (nums1[i] &lt; nums2[j]) &#123; //排序有小到大            nums[count++] = nums1[i++];        &#125; else &#123;            nums[count++] = nums2[j++];        &#125;    &#125;    if (count % 2 == 0) &#123; //判断奇偶数        return (nums[count / 2 - 1] + nums[count / 2]) / 2.0;    &#125; else &#123;        return nums[count / 2];    &#125;&#125;\n\n\n\n解法二:不需要将两个数组合并,只需要找的中间位置就行.\n思路\n\n用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len+1）/2 个数就可以了，如果遍历的话需要遍历 int(len/2 ) + 1 次。如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。\n返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。\n循环中该怎么写，什么时候 A 数组后移，什么时候 B 数组后移。用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart＜m&amp;&amp;A[aStart]&lt; B[bStart]。\n但如果 B 数组此刻已经没有数字了，继续取数字 B[ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以为 aStart＜m&amp;&amp;((bStart) &gt;= n||A[aStart]&lt;B[bStart]) 。\n\n代码:\npublic double findMedianSortedArrays(int[] A, int[] B) &#123;      int m = A.length;      int n = B.length;      int len = m + n;      int left = -1, right = -1; //保存循环的结构      int aStart = 0, bStart = 0;//表示在当前数组AB的位置      for (int i = 0; i &lt;= len / 2; i++) &#123;          left = right;//**每次循环前将 right 的值赋给 left          //如果 B 数组此刻已经没有数字了，继续取数字 B[ bStart ]，          // 则会越界，所以判断下 bStart 是否大于数组长度了，          // 这样 || 后边的就不会执行了，也就不会导致错误了，          // 所以增加为 aStart＜m&amp;&amp;(bStart) &gt;= n||A[aStart]&lt;B[bStart]) 。          if (aStart &lt; m &amp;&amp; (bStart &gt;= n || A[aStart] &lt; B[bStart])) &#123;              right = A[aStart++];          &#125; else &#123;              right = B[bStart++];          &#125;      &#125;      if ((len % 2) == 0)          return (left + right) / 2.0;      else          return right;  &#125;\n\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"操作系统01-4-存储器-缓存","url":"http://example.com/2020/10/23/操作系统00-5/","content":"存储器分级策略不能用一块存储器来解决所有的需求，那就必须把需求分级。\n一种可行的方案，\n\n根据数据的使用频率使用不同的存储器：\n高频使用的数据，读写越快越好，因此用最贵的材料，放到离 CPU 最近的位置；\n使用频率越低的数据，我们放到离 CPU 越远的位置，用越便宜的材料。\n\n寄存器分为6个级别\n\n寄存器；\nL1-Cache；\nL2-Cache；\nL3-Cahce；\n内存；\n硬盘/SSD。\n\n \n\n寄存器    –&gt;    l1-cache    –&gt;     l2-cache    –&gt;     l3-cache    –&gt;     内存 –&gt;  SSD/磁盘\n从左到右，距离CPU逐渐变远，读取速度逐渐减低，空间逐渐增大。\n寄存器:寄存器紧挨着CPU的控制单元和逻辑计算单元,所以使用的材料是速度最快的,因而储存的速度最快,耗能就最高,产热就最大,而且花费也是最贵的,因此数量不多.\n\n32 位 CPU 中大多数寄存器可以存储 4 个字节；\n64 位 CPU 中大多数寄存器可以存储 8 个字节。\n\n寄存器的访问速度非常快,一般在半个CPU时钟周期内完成\nL1-CacheL1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。\nL2-CacheL2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。\nL3-CacheL3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。\nL3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。\n内存内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200~300 个 CPU 周期之间。\nSSD和硬盘SSD也叫固态硬盘结构和内存类似，\n主要的优点就是在于断电后数据还在.内存,寄存器,缓存断电后数据就消失了.内存的内存的读写速度比 SSD 大概快 10~1000 倍\n当CPU需要内存中某个数据的时候,如果寄存器这个数据,直接用,如果寄存器没有这个数据,查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。\n缓存条目结构无论是缓存还是,内存,是一个线性储存器,也就是数据一个挨着一个的储存.比如:把内存想象成一个只有 1 列的表格，那么缓存就是一个多列的表格，这个表格中的每一行叫作一个缓存条目。\n方案 1缓存本质上是一个 Key-Value 的存储，它的 Key 是内存地址，值是缓存时刻内存地址中的值。\n\n内存的地址；\n缓存的值。\n\nCPU读取到一个内存地址,就增加一个条目.当查询一个内存地址的数据在不在 L1- 缓存中的时候，可以遍历每个条目，,看条目中的内存地址是否和查询的内存地址相同.如果相同,我们就取出条目中的缓存的值.\n缺点:效率低.\n方案 2想要快速的定位缓存条目可以通过取余(类似hash算法)快速定位缓存条目位置。地址 % 10\n指令的预读通过对于指令的预读，使得读取指令的速度跟的上指令的执行速度。减少指令从内存中的读取次数(更耗时)，其实就是批处理。\n缓存的命中:所谓命中就是指在缓存中找的需要的数据.和命中相反的是穿透,也叫miss.就是一次读取操作没有从缓存中找到对应的数据。\n\nl1的缓存命中率约为80%，\nl1 l2 l3缓存加在一块命中率高达95%。\nCPU 缓存的设计还是相当合理的。只有 5% 的内存读取会穿透到内存，95% 都能读取到缓存。\n\n缓存置换: 当缓存满了之后，再读取数据到缓存将置换掉之前的缓存。\n\n\nSSD、内存和 L1 Cache 相比速度差多少倍？\n因为内存比 SSD 快 101000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000100000 倍。\n这个问题告诉我们,不同的储存器之间的性能差距很大,构造储存器分级很有意义,分级的目录的是要构造缓存体系.\n","categories":["-操作系统"],"tags":["基础"]},{"title":"javaSE-07-对象与引用-static关键字","url":"http://example.com/2020/10/21/javaSE06-1/","content":"面向对象2对象与引用引用对象:Java语言中除基本数据类型之外的变量类型都称为引用类型.\njava中的对象是通过引用对其操作的\n例如:我们有一个自定义类为Car（汽车类）\nclass Car&#123;\tString color;       \tString name;\tString model;&#125;\n\nCar car= new Car();通常把这条语句的动作称之为创建一个对象，其实，它包含了三个动作。\n解释\n\n\n\n右边的” new Car()” 是以car类为模板,调用car类的构造函数,在对空间里创建一个car类对象\n左边”car car” 创建一个car类引用变量,所谓Car类的引用,就是以后可以用来指向car对象的对象引用\n= 操作使对象引用指向刚创建的那个car对象\n\nCar car;一是对象引用变量，car= new Car();一是对象本身。\n\n基本类型和引用类型的区别\n\n\n\n基本数据类型\n引用数据类型\n\n\n\n概念\n变量(单纯的值)\n对象(引用)\n\n\n储存位置\n在栈中存值\n在栈中存引用,在堆中存具体对象的属性值\n\n\n值传递与引用传递值传递：(形式参数类型是基本数据类型)实参传递给形参的是值  形参和实参在内存上是两个独立的变量 对形参做任何修改不会影响实参\npublic class Demo1 &#123;        public static void main(String[] args) &#123;                int b =20;                change(b);// 实参  实际上的参数                System.out.println(b);        &#125;        public static void change(int a)&#123;//形参  形式上的参数                a=100;        &#125;&#125;\n\n结果：20\n可以理解为:小明去餐厅吃饭，看见别人点的红烧肉挺好吃，九把服务员叫过来，说我要一份红烧肉，服务员从后厨拿来一份红烧肉，小明吃完了，但是他吃的红烧肉跟旁边那个人吃的是一份吗？当然不是。\n\n引用传递:实参传递给形参的是参数,   对于堆内存上的引用地址,  实参和形参在内存上指向了同一块区域  对形参的修改会影响实参\npublic class Demo1 &#123;        public static void main(String[] args) &#123;                int [] a&#x3D;&#123;1,2,3&#125;;                System.out.println(a[0]);                change(a);                System.out.println(a[0]);        &#125;        public static void change(int[] a )&#123;                a[0]&#x3D;100;        &#125;&#125;\n\n结果：1    100\n由于引用传递，传递的是地址，方法改变的都是同一个地址中的值，\n原来a[0]指向0x13地址，值是1，\n后来在a[0] 指向的也是0x13地址，将值变成了100\n所以，再查询a[0]的值的时候，值自然变成了100\n\n通俗点的讲法就是：\n小明回到家，他妻子说：冰箱二层有一只鸡，你去做了；\n小明做好了，叫妻子过来吃饭。\n这个时候，他妻子现在看见的鸡和她买回来的一样吗？\n当然不一样，都做熟了；\n什么意思呢？\n鸡就是数据\n冰箱二层就是存储数据的地址\n把鸡做熟了就是相当于把值改变了\n地方还是那个地方，就是鸡变了。\nstatic 关键字static被称为静态,可以用来修饰类的属性,方法,代码块,内部类.\n\n修饰的成员,被所有对象所共享\n不创建对象,直接被调用\n优先于对象存在静态优先于非静态\n类加载时执行\n\n1.可直接通过类名访问 也可以通过对象名访问\nstatic String school\n\n如过不是静态,每一个对象都要复制一份变量,浪费空间,\n当所有对象的某一个值都相同时,加一个static使其为静态,在内存中只有一份,所有对象共享\n\n静态方法只能访问 静态的变量\n成员方法可以方法可以访问 成员变量 还可以方法静态变量\n\npackage com.nie.day2.Demo1;public class StaticTest &#123;    String name;    int age;    static String school;//可直接通过类名访问 也可以通过对象名访问    //static    //修饰的成员,被所有对象所共享    //不创建对象,直接被调用    //优先于对象存在o    //随着加载而加载    public void work() &#123;        System.out.println(name + &quot;\\t&quot; + age + &quot;\\t&quot; + school);    &#125;&#125;\n\npackage com.nie.day2.Demo1;public class Test1 &#123;    public static void main(String[] args) &#123;        StaticTest.school = &quot;陕西&quot;;//可直接通过类名访问         StaticTest b = new StaticTest();        b.age = 12;        b.name = &quot;sfdsf&quot;;        b.work();        StaticTest c = new StaticTest();        c.age = 33;        c.name = &quot;花花&quot;;        c.work();    &#125;&#125;\n\n输出:\nsfdsf\t12\t陕西花花\t33\t陕西\n\n\n\n代码块代码分实例块和静态块\n\n静态变量优先于于非静态,\n类加载时自动调用，仅一次，与是否创建对象无关。\n\npackage com.nie.day2.Demo1;public class Demo &#123;    static int num &#x3D; 10;    &#123;        System.out.println(&quot;实例代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    public static void main(String[] args) &#123;        new Demo();&#x2F;&#x2F; 先加载类 然后创建对象        new Demo();        System.out.println(Demo.num);    &#125;&#125;\n\n输出:\n静态代码块实例代码块实例代码块10\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"LC283-1021-移动零","url":"http://example.com/2020/10/21/LC283-1021-移动零/","content":"移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n示例:\n输入: [0,1,0,3,12]输出: [1,3,12,0,0]\n\n\n说明:\n必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。\n  \n\n最优解法class Solution &#123;    public void moveZeroes(int[] nums) &#123;        for(int i = 0,j = 0; i &lt; nums.length; i++ )&#123;            if(nums[i] != 0)&#123;                if(nums[j] == 0)&#123;//执行替换操作                    nums[j] = nums[i];                    nums[i] = 0;                &#125;                ++j;                      &#125;        &#125;    &#125;&#125;\n\n\n\n冒泡法class Solution &#123;    public void moveZeroes(int[] nums) &#123;        for (int i = nums.length-1; i &gt;= 0; i--) &#123;            for (int j = 0; j &lt; i; j++) &#123;                if (nums[j] == 0)                    swap(nums, j, j+1);            &#125;        &#125;    &#125;    void swap(int[] nums, int i, int j) &#123;        int tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;","categories":["-算法"],"tags":["LeetCode"]},{"title":"操作系统01-4-构造复杂的程序","url":"http://example.com/2020/10/20/操作系统00-4/","content":"构造复杂的程序不支持递归的程序语言如何实现递归程序？弄清楚这道题目，对程序有一个更深层次的认识，不仅仅停留在指令的执行层面，而是要灵活使用指令，去实现更加复杂的功能。\nfor 循环如何被执行var i = 1, s = 0;for(; i &lt;= 100; i++) &#123;  s+=i;&#125;\n\n\nfor循环是通过标记,判断和跳转完成指令操作\n\n \n\n\nif-else 翻译成指令，是比较简单的，你需要用跳转指令和比较指令处理它的跳转逻辑。自上而下的执行逻辑\n\nswitch-case是一种精准的匹配算法.\n用1000个case,用 if-else 你需要一个个比较，最坏情况下需要比较 999 次；而如果用 switch-case ，就不需要一个个比较，通过算法就可以直接定位到对应的case\n\n\n函数的执行过程函数涉及到栈的数据结构\nint add(int a, int b)&#123;  return a + b;&#125;\n\n\n参数a,b本质是内存中的数据,因此需要给他们发你配内存地址\n函数的返回值也是内存中的数据,也就是返回值也需要分配内存的地址\n调用函数其实就是跳转到函数体对应的指令\n\n首先在调用方，我们将参数传递给栈；然后在函数执行过程中，我们从栈中取出参数。\n函数执行过程中，先将执行结果写入栈中，然后在返回前把之前压入的参数出栈，调用方再从栈中取出执行结果。\n将参数传递给 Stack 的过程，叫作压栈。取出结果的过程，叫作出栈。\n假设要计算 11 和 15 的和\n11 被写入内存，并且栈指针指向了 0x104 位置。\n15被写入内存\n11 和 15 都被放入了对应的内存位置，并且栈指针指向了 0x108。\n将返回值压栈\n\n完成压栈后,开始调用函数,用跳转指令直接跳转到函数的标签,加在栈中11和15,我们可以利用SP指针寻找数据,11距离当前SP指针3个位置,15距离2个位置这种寻址方式是一种复合寻址方式,是间接+偏移量寻址.\n下面的代码完成将 11 和 15 导入寄存器的过程：\nload $(SP - 12) -&gt; R0load $(SP - 8) -&gt; R1\n\n然后进行加和，将结果存入 R2。\nload R0 R1 R2\n\n再次利用数学关系将结果写入返回值所在的位置。\nstore R2 -&gt; $(SP-4)\n\n一种间接寻址的方式来进行加和运算，也就是利用 SP 中的地址做加减法操作内存。\n经过函数调用的结果如下图所示，运算结果 26 已经被写入了返回值的位置：\n\n64 位宽的 CPU，那么栈指针就需要自增 8。32位宽的 CPU，那么栈指针就需要自增 4。\n在调用函数前，还需要将返回地址压栈。这样在函数计算完成前，就能跳转回对应的返回地址。翻译成指令，就是下面这样：\n## 压栈返回值add SP, 4  -&gt; SP # 计算返回地址# 我们需要跳转到清理堆栈那行，也就是16行MOV PC+4*(参数个数*2+1) -&gt; SP# 压栈参数的程序……# 执行函数，计算返回值call function# 清理堆栈add SP, -(参数个数+1)*4， SP\n\n\n\n\n\n\n\n\n\n递归函数如何被执行int sum(int n)&#123;  if(n == 1) &#123;return 1;&#125;  return n + sum(n-1);&#125;\n\n\n每次递归的时候,都是形成一个栈的结构\n\n\nsum(100)，就会形成一个复杂的栈，\n\n\n堆在一块就会形成一个很大的栈\n\n递归消耗了更多的空间,但是也保证了中间数据的独立性.\n\n\n由此可见,栈这种结构同样适合递归的计算,计算机编程语言就是用这种结构来实现递归函数的.\n类型（class）如何实现\n变量是一个内存地址，所以只需要分配内存就好了；\n循环控制可以用跳转加判断实现；\n条件控制也可以用跳转加判断实现，只不过如果是 switch-case 还需要一定的数学计算；\n函数调用需要压栈参数、返回值和返回地址。\n\n一个 class 会分成两个部分，一部分是数据（也称作属性），另一部分是函数（也称作方法）。\nclass 有一个特殊的方法叫作构造函数，它会为 class 分配内存。构造函数执行的时候，开始扫描类型定义中所有的属性和方法。\n\n属性分配地址\n遇到方法的值,设置为方法指令所在的内存地址。\n\nthis关键字则是最先压入栈，这样任何函数都可以访问实例中的属性和函数\n个语言的能力和图灵机等价，就说这个语言是图灵完备的语言。现在市面上的绝大多数语言都是图灵完备的语言，( HTML、正则表达式和 SQL 等不是完备语言)\n","categories":["-操作系统"],"tags":["基础"]},{"title":"javaSE-06-面向对象-成员,成员变量","url":"http://example.com/2020/10/19/javaSE06/","content":"java面向对象面向过程(pop)分析出解决问题所需的步骤,然后一步一步实现\n注重解决步骤,\n例如::关冰箱问题:1.打开冰箱门  2.装大象  3.关闭冰箱门\n\n\n面向对象(oop)以分类的方式进行思考和解决问题,宏观,整体上的设计.\n例如::关冰箱问题:关冰箱需要冰箱,冰箱有门,人操作冰箱,门还分关门开门等等\n\n\n因此设计为:\n门类\n​          开门();\n​          关门();\n设计冰箱类\n​           门类\n 人类\n​         操作();\n类什么是类\n类是一个模板,他描述一类对象的属性和行为\n表示一个客观世界某类群体的一些基本特征抽象\n\n类=汽车的图纸== .java文件\n对象就是具体存在的用图示做出了的汽车\n类的结构\n成员变量:对象属性的描述(这个类有什么)\n方法: 对象的行为(这个类能干什么)\n构造方法:用于创建对象\n内部类:即在类体中的声明的类\n块:代码块\n\n类的定义类的声明\n类的声明格式为:[访问权限修饰符]  [修饰符] class 类名&#123;\t&#125;\n\n\njava类名的命名规范:类名首字母大写,见名知意,驼峰表示\n关键字class用来定义一个类\n\n写出类的共有属性\npublic class Method &#123;    /**     * 类的属性  类的成员   变量     * 导弹     */    String name;//名字    String colour;//颜色    int length;//长度&#125;\n\n\n变量的格式为：[访问权限修饰符] [修饰符]  type   attr_name [=defaultValue] \n\n类的方法\n方法声明格式为: [访问权限修饰符] [修饰符]/ void  start()&#123;\tSystem.out.println(&quot;启动&quot;);               [return   返回值;]     &#125;\n\n对象为模板在内存中创建的实实在在存在的实例。\n创建和使用\n使用new关键字创对象.\n\nMethod  testMethod  =new Method();  new 关键字+默认构造方法();在内存空间创建一个对象  实际存在的   实例化对象\n\nMethod  testMethod以Method类作为类型 声明一个变量 指向内存空间中的具体的对象使用testMetho变量访问对象中属性,方法\n\n通过类可以创建无数个对象\n\n\n使用对象  . 成员变量来引用对象的成员变量testMethod.name\n使用对象（引用） . 方法来调用对象的方法testMethod.start()\n同一类的每个对象有不同的成员变量存储空间,同一类的每个对象共享该类的方法。\n创建对象的过程也叫实例化对象.  对象==实例\n现实生活中先有对象后有类,而编程时先设计类后创建对象\npackage java.ff.javaSE.oop.day1;/** * 发现类 * 类是一个文件,记录信息 * 声明语法: * [访问权限修饰符 public/default][修饰符 final/abstract] class 类名&#123;  &#125; */public class Method &#123;    /**     * 类的属性  类的成员   变量     * 导弹     */    String name;    String colour;    int length;    /**     * 攻击     * 类的行为  类的成员 方法  被类包含     * [访问权限修饰符][修饰符] 返回值类型/void 方法名([参数类型 参数名称])&#123;     * [return 值];     * &#125;     */    public void start(String name, int length) &#123;        System.out.println(&quot;导弹名字:&quot; + name + &quot;攻击范围是:&quot; + length);    &#125;&#125;\n\n\n\npublic class Test &#123;    public static void main(String[] args) &#123;        Method   testMethod   = new Method();         testMethod.name=&quot;adsa&quot;;         testMethod.start(&quot;东方&quot;,100000);    &#125;&#125;\n\n成员变量\n定义类中,方法外\n包括java中的任意一个数据变量(基本数据类型和引用数据类型)\n变量可以不被赋值,java虚拟机会给其初始值\n成员变量在闯进对象的时候会从类中赋值一份到对象中\n成员变量可以被类中方法、构造方法和特定类的语句块访问。\n成员变量的作用范围为整个类体\n\n局部变量:\n在构造方法,方法或者语句中定义的变量称为局部变量\n包括java中的任意一个数据变量(基本数据类型和引用数据类型)\n在局部变量使用前必须赋值,\n方法结束后,会自动销毁,不占用空间\n\n一个类可以包含以下类型方法：成员方法\n成员方法是定义在类中。这种方法在创建对象的时候创建。语法格式：\n \t修饰符  返回值类型/void  方法名 ( 参数列表) &#123;  \t 方法体语句；       [return 返回值]&#125; \n\n\n\n构造方法用来创建对象的方法\n\n是定义在java类中的一个用来创建对象的方法\n构造方法可以与类名相同,且没有返回值,且不需要使用void进行修饰\n一个类中可以有多个构造方法\n使用new + 构造方法 创建一个新的对象那个,在创建对象的时候至少调用一个构造方法.\n每个类都有构造方法,java一般会默认提供一个无参构造方法,但是只有Java构造一个后就会失效.\n\n类方法（静态方法）类方法也声明在类中，但必须声明为static类型\n方法的重载\n是指一个类中有相同的名字,但是参数不同的多个方法\n\n调用时会根据不同的参数表选择对应的方法\n\n类型,数量,顺序,数据类型,同一种功能处理不同的数据类型\n\n参数不同（可以有三方面的不同）数量不同类型不同顺序不同\n注意:方法重载跟方法的返回值类型,访问权限没有任何关系\n\n\npackage com.nie.day1.Demo02;public class Construction &#123;    /**     * 成员变量     */    String name;    int age;    double heigth;    /**     * 方法的重载     * 是指一个类中有相同的名字,但是参数不同的多个方法,     * 调用时会根据不同的参数表选择对应的方法\\     * 类型,数量,顺序,数据类型,同一种功能处理不同的数据类型     */    public void eat() &#123;        System.out.println();    &#125;    public void eat(String name) &#123;        System.out.println(&quot;111&quot;);    &#125;    public void eat(int age) &#123;        System.out.println(&quot;2222&quot;);    &#125;    public void eat(double age) &#123;        System.out.println(&quot;33333&quot;);    &#125;    public void eat(float age) &#123;        System.out.println(&quot;44444&quot;);    &#125;    public void eat(String na, int a) &#123;        System.out.println(&quot;55555&quot;);    &#125;    public void eat(int a, String na) &#123;        System.out.println(&quot;66666&quot;);    &#125;&#125;\n\n\n\npackage com.nie.day1.Demo02;public class Test &#123;    public static void main(String[] args) &#123;        Construction a = new Construction();                a.eat(&quot;lllll&quot;);        a.eat(19);        a.eat(2.22);        a.eat(2.2f);        a.eat(&quot;sadad&quot;,11);        a.eat(11,&quot;sadad&quot;);    &#125;&#125;\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"十大算法--贪心算法","url":"http://example.com/2020/10/18/算法-常用10种算法005-贪心算法/","content":"贪心算法贪心算法介绍\n贪心算法(贪婪算法)是指对问题进行求解时,**在每一步种都采用最好或者最优(最有利)的选择,**而希望能够导致结果最好或者最优的算法.\n贪心算法所得到的结果不一定时最优的结果(有时候是最优解),但是都是相对近似(接近)最优的结果.\n\n贪心算法最佳应用-集合覆盖\n假设存在如下表的需要付费的广播台， 以及广播台信号可以覆盖的地区。 如何选择最少的广播台,让所有的地区都可以接收到信号  \n\n  \n\n\n\n\n广播台\n覆盖地区\n\n\n\nk1\n“北京”,”上海”,”天津”\n\n\nk2\n“广州”,”上海”,”深圳”\n\n\nk3\n“成都”,”上海”,”杭州”\n\n\nk4\n“上海”,”天津”\n\n\nk5\n“杭州”,”大连”\n\n\n思路:\n使用穷举法实现,列出每一个可能出现的广播台的集合,这被称为幂集。 假设总的有 n 个广播台， 则广播台的组合总共有  设总的有 n 个广播台， 则广播台的组合总共有  \n\n\n\n\n广播台的数量n\n子集的总数量2^n\n需要的时间\n\n\n\n5\n32\n3.2秒\n\n\n10\n1024\n102.4秒\n\n\n32\n4294967296\n13.6年\n\n\n100\n1.26*100^(30)\n4*10^23年\n\n\n使用贪心算法,效率高:\n目前没有算法可以快速计算的准备的值,使用贪婪算法,则可以得到非常接近的解,并且效率高.选择策略上,需要覆盖全部地区的最最小集合.\n遍历所有的广播电台,找的一个覆盖了最多未覆盖的地区的电台,(此电台可能包含一些已覆盖的地区,下一步处理）  \n将这个电台加入到一个集合,把该电台覆盖的地区在下次比较时去掉  \n重复第一步,直到覆盖了全部的地区\n\n分析的图解\nallAreas = { “北京”,”上海”,”天津”,”广州”,深圳”,”成都”,杭州”,”大连”}; \n// 表示需要覆盖的所有地区\nkey由K1到5,遍历所有的广播电台,找的一个覆盖了最多未覆盖的地区的电台\n\n\n建一个索引maxKey表示最大的未覆盖的地区=k1,.\n\n将这个电台加入到一个集合,ArrayList(k1)把该电台覆盖的地区在下次比较时去掉  ,所以\nallAreas = { 广州”,深圳”,”成都”,杭州”,”大连”};\n\n\n索引maxKey表示最大的未覆盖的地区=k2,.将这个电台加入到一个集合,ArrayList(k1,k2)\n\n然后把k2的元素,去掉.重复第key遍历..依次类推…..\n\n\n\n\n\n6.ArrayList(k1,k2,k3,k5),电台覆盖的地区在比较去掉,,所以为:allAreas = { };,\n\n代码分析核心代码//创建ArrayList, 存放选择的电台集合ArrayList&lt;String&gt; selects = new ArrayList&lt;String&gt;();//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key//如果maxKey 不为null , 则会加入到 selectsString maxKey = null;while (allAreas.size() != 0) &#123; // 如果allAreas 不为0, 则表示还没有覆盖到所有的地区    //每进行一次while,需要索引清零    maxKey = null;    //遍历 broadcasts, 取出对应key    for (String key : broadcasts.keySet()) &#123;        //每进行一次for        //当前这个key能够覆盖的地区        HashSet&lt;String&gt; areas = broadcasts.get(key);        //key能够遍历的的地区与allAreas所最大相同的东西        areas.retainAll(allAreas);        //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多        //就需要重置maxKey        // areas.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的        if (areas.size() &gt; 0 &amp;&amp;                (maxKey == null || areas.size() &gt; broadcasts.get(maxKey).size())) &#123;            maxKey = key;        &#125;    &#125;    //maxKey != null, 就应该将maxKey 加入selects    if (maxKey != null) &#123;        selects.add(maxKey);        //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉        allAreas.removeAll(broadcasts.get(maxKey));        //即broadcastsy也变称为        /**第一次遍历后         * k1  &quot;&quot;,&quot;&quot;,&quot;&quot;         * k2  &quot;广州&quot;,&quot;&quot;,&quot;深圳&quot;         * k3  &quot;成都&quot;,&quot;&quot;,&quot;杭州&quot;         * k4  &quot;&quot;,&quot;&quot;         * k5  &quot;杭州&quot;,&quot;大连&quot;         */    &#125;&#125;\n\n贪心算法注意事项和细节\n贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)， 但是都是相对近似(接近)最优解的结果\n比如上题的算法选出的是 K1, K2, K3, K5， 符合覆盖了全部的地区\n但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区， 如果 K2 的使用成本低于 K1,那么我们上题的 K1, K2, K3,K5 虽然是满足条件， 但是并不是最优的  \n\n完整代码import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class GreedyAlgorithm &#123;    public static void main(String[] args) &#123;        //创建广播电台,放入到Map        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String, HashSet&lt;String&gt;&gt;();        //将各个电台放入到broadcasts        HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;();        hashSet1.add(&quot;北京&quot;);        hashSet1.add(&quot;上海&quot;);        hashSet1.add(&quot;天津&quot;);        HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;();        hashSet2.add(&quot;广州&quot;);        hashSet2.add(&quot;北京&quot;);        hashSet2.add(&quot;深圳&quot;);        HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;();        hashSet3.add(&quot;成都&quot;);        hashSet3.add(&quot;上海&quot;);        hashSet3.add(&quot;杭州&quot;);        HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;();        hashSet4.add(&quot;上海&quot;);        hashSet4.add(&quot;天津&quot;);        HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;();        hashSet5.add(&quot;杭州&quot;);        hashSet5.add(&quot;大连&quot;);        //加入到map        broadcasts.put(&quot;K1&quot;, hashSet1);        broadcasts.put(&quot;K2&quot;, hashSet2);        broadcasts.put(&quot;K3&quot;, hashSet3);        broadcasts.put(&quot;K4&quot;, hashSet4);        broadcasts.put(&quot;K5&quot;, hashSet5);        //allAreas 存放所有的地区        HashSet&lt;String&gt; allAreas = new HashSet&lt;String&gt;();        allAreas.add(&quot;北京&quot;);        allAreas.add(&quot;上海&quot;);        allAreas.add(&quot;天津&quot;);        allAreas.add(&quot;广州&quot;);        allAreas.add(&quot;深圳&quot;);        allAreas.add(&quot;成都&quot;);        allAreas.add(&quot;杭州&quot;);        allAreas.add(&quot;大连&quot;);        //创建ArrayList, 存放选择的电台集合        ArrayList&lt;String&gt; selects = new ArrayList&lt;String&gt;();        //定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key        //如果maxKey 不为null , 则会加入到 selects        String maxKey = null;        while (allAreas.size() != 0) &#123; // 如果allAreas 不为0, 则表示还没有覆盖到所有的地区            //每进行一次while,需要索引清零            maxKey = null;            //遍历 broadcasts, 取出对应key            for (String key : broadcasts.keySet()) &#123;                //每进行一次for                //当前这个key能够覆盖的地区                HashSet&lt;String&gt; areas = broadcasts.get(key);                //key能够遍历的的地区与allAreas所最大相同的东西                areas.retainAll(allAreas);                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多                //就需要重置maxKey                // areas.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的                if (areas.size() &gt; 0 &amp;&amp;                        (maxKey == null || areas.size() &gt; broadcasts.get(maxKey).size())) &#123;                    maxKey = key;                &#125;            &#125;            //maxKey != null, 就应该将maxKey 加入selects            if (maxKey != null) &#123;                selects.add(maxKey);                //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉                allAreas.removeAll(broadcasts.get(maxKey));                //即broadcastsy也变称为                /**第一次遍历后                 * k1  &quot;&quot;,&quot;&quot;,&quot;&quot;                 * k2  &quot;广州&quot;,&quot;&quot;,&quot;深圳&quot;                 * k3  &quot;成都&quot;,&quot;&quot;,&quot;杭州&quot;                 * k4  &quot;&quot;,&quot;&quot;                 * k5  &quot;杭州&quot;,&quot;大连&quot;                 */            &#125;        &#125;        System.out.println(&quot;得到的选择结果是&quot; + selects);//[K1,K2,K3,K5]    &#125;&#125;\n\n","categories":["-算法"],"tags":["常用10种算法"]},{"title":"javaSE-05-输入-控制语句-循环等...","url":"http://example.com/2020/10/16/javaSE05/","content":"控制台输入Scanner a = new Scanner(System.in)\n\n\n[  System.in  ]标准输入串,得用户输入\n\nnext()方法用以 输入的字符；\n\nnextInt()将取得的输入为整数类型；\n\nnextFloat()转换成浮点型；\n\nnextBoolean()转 换成布尔型。\n\n\nScanner a=  new Scanner(System.in);System.out.println(&quot;姓名&quot;);String name1=a.next();System.out.println(name1);\n\n\n\n控制语句:\n条件语句-根据不同条件,执行不同的语句\n\nif\nif(布尔表达式)&#123;   //如果布尔表达式为true将执行的语句&#125;\n\nif .. else\nif(布尔表达式)&#123;   //如果布尔表达式的值为true,执行本代码块&#125;else&#123;   //如果布尔表达式的值为false,执行本代码块&#125;\n\nif .. else if\n\nif .. else if .. else if .. else\nif(布尔表达式 1)&#123;   //如果布尔表达式 1的值为true执行代码&#125;else if(布尔表达式 2)&#123;   //如果布尔表达式 2的值为true执行代码&#125;else if(布尔表达式 3)&#123;   //如果布尔表达式 3的值为true执行代码&#125;else &#123;   //如果以上布尔表达式都不为true执行代码&#125;\n\nswitch\nswitch (表达式)&#123;  \t\t case value1:  语句序列1;\t\t\t[break];\t\t  …………  \t\t case valueN:  语句序列N; \t\t\t[break];  \t\t[default :     缺省语句;]//可以不写 \t&#125;\n\n注:\n\nSwitch(表达式 byte short int char 枚举 jdk7后可以使用string)\ncase后只能是常量,后面值不能重复\n没有break语句,则只能进行下一个case语句,直到遇到break\n前面都不匹配时候，执行default语句\n\n\n\n\n注意:\n        if (true) //两都输出            System.out.println(&quot;+++++++&quot;);            System.out.println(&quot;=========&quot;);                if (false)//只输第一行            System.out.println(&quot;+++++++&quot;);            System.out.println(&quot;=========&quot;);等价于:等价于if (条件返回bollean值)else\n\n\n\nswitch和if语句的对比\nIf else: 是对区间得判断，灵活，任意 ,,简单的作用条件运算符，条件运算符必须返回一个结果。\nswitch  值区别比较固定，具体数值不多，而且符合byte、 short 、int、 char这四种类型,用switch 效率高\n\n循环循环的要素\n变量的初始化\n循环条件\n循环语句\n变量的更新,迭代\n\n循环语句\nwhile循环\n\n  while(条件)&#123;        循环语句        变量的迭代     &#125;\n\n  先条件判断,条件成立才能进入循环语句\n\ndo/while 循环 \n\n  do&#123;     &#125;while(条件)\n\n  do while 即使条件不成路也会执行一次\n\nfor循环\n\n  for(声明变量,条件,变量的迭代)&#123;         循环语句     &#125;\n\n  执行流程\n  声明变量**(一次)–&gt;条件(条件成立)(一次或者多次)–&gt;执行循环语句(一次或者多次)–&gt;变量的迭代(一次或者多次)**–&gt;条件–&gt;条件(条件成立)–&gt;执行循环语句–&gt;变量的迭代…………\nbreak &amp; continuebreak\n结束当前整个循环语句\n\n   for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(i);\n            if(i==2)&#123;\n                break; //终止整个循环\n            &#125;\n        &#125;\n输出:&#96;&#96;&#96;java012\n\n\n\n\n\ncontinue\n用于终止某次循环过程，跳过循环体中 continue 语句下面未执行的循环，开始下一次循环过程\n\n    for (int i = 0; i &lt; 5; i++) &#123;\n            if(i==3)&#123;\n                continue; // 跳过,之后循环正常进行\n            &#125;\n            System.out.println(i);\n        &#125;\n输出:&#96;&#96;&#96;java0124\n\n\n\n\n\n循环嵌套\n在一个循环体内在放一个循环.形成了嵌套循环.for ,while ,do…while均可以作为外层循环和内层循环。\n只有内层循环的循环条件为flase,才能完全跳出内层循环,才能结束外层的当次循环,开始下一次的循环.\n\n结束外层循环如果需要从多层循环跳出，则需要使用标签，定义一个标签,如outer，然后在需要跳出的地方，用outer就行了.\nouter:for (int i = 0; i &lt; 10; i++) &#123;           for (int j = 0; j &lt;10 ; j++) &#123;            if(j==5)&#123;                break outer; //终止指定标签的循环,外循环结束            &#125;            System.out.println(j);        &#125;        System.out.println(i);    &#125;\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"操作系统01-3-程序的执行","url":"http://example.com/2020/10/15/操作系统00-3/","content":"程序的执行过程当 CPU 执行程序的时候：\ncpu读取PC指针指向的指令,将他导入指令寄存器.PC(Program Counter)程序计数器，也是一种寄存器。\n\n\nCPU 的控制单元操作地址总线指定需要访问的内存地址\n\nCPU 通知内存设备准备数据\n\nCPU收到内存传来的数据后,将这个数据存入指令寄存器\n完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。\n  \n\n\n\n2.CPU分析指令寄存器中的内容,并分析指令的类型和参数.\n3.如果是计算机类型指令,就交给逻辑单元计算;如果是存储类型的指令,难就由控制单元执行.\n4.PC指针自增,并准备获取在一条指令\n如果是32位的机器上，指令就是32个bit(4 byte) ，需要4个内存地址，所以自增4指令的执行速度:通过石英晶体的脉冲转化成时钟信号驱动的，每次高低电平的转换就是一个周期。我们称为时钟周期。\n\n\n\n\n\n\n内存虽然是一个随机存取器，通常不会把指令和数据存在一起，这是为了安全起见。\n程序指针也是一个寄存器，64 位的 CPU 会提供 64 位的寄存器，这样就可以使用更多内存地址。特别要说明的是，64 位的寄存器可以寻址的范围非常大，但是也会受到地址总线条数的限制。比如和 64 位 CPU 配套工作的地址总线只有 40 条，那么可以寻址的范围就只有 1T，也就是 2^40。\n从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作CPU 的指令周期，\n\n\n\n\n\n\n\na=11+15的CPU执行过程:1.编译器通过分析，发现 11 和 15 是数据，因此编译好的程序启动时，会在内存中开辟出一个专门的区域存这样的常数，这个专门用来存储常数的区域，就是数据段，如下图所示：\n\n11 被存储到了地址 0x100；\n\n15 被存储到了地址 0x104；\n\n\n\n2.编译器将a=11+15转换成了 4 条指令，程序启动后，这些指令被导入了一个专门用来存储指令的区域，也就是正文段。如上图所示，这 4 条指令被存储到了 0x200-0x20c 的区域中：\n\n0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0；\n\n0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1；\n\n0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2；\n\n0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置。\n\n\n3.具体执行的时候，PC 指针先指向 0x200 位置，然后依次执行这 4 条指令。\n\n变量 a 实际上是内存中的一个地址，a 是给程序员的标识符。\n\n每次操作 4 个地址，也就是 32 位，这是因为在用 32 位宽的 CPU 举例。在 32 位宽的 CPU 中，指令也是 32 位的。但是数据可以小于 32 位，比如可以加和两个 8 位的字节。\n\n\n指令构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。由此可见 CPU 内部有一个循环：\n\n首先 CPU 通过 PC 指针读取对应内存地址的指令，叫作 Fetch，就是获取的意思。\n\nCPU 对指令进行解码，叫作 Decode。\n\nCPU 执行指令,我们将这个部分,叫作 Execution。\n\nCPU 将结果存回寄存器或者将寄存器存入内存， Store。\n\n\n\n上面 4 个步骤，我们叫作 CPU 的指令周期。CPU 的工作就是一个周期接着一个周期，周而复始。\n指令的类型不同类型（不同 OpCode）的指令、参数个数、每个参数的位宽，都不一样。而参数可以是以下这三种类型：\n\n寄存器\n内存地址\n数值(一般是整数和浮点)\n\n论是寄存器、内存地址还是数值，它们都是数字。\n指令从功能角度来划分，大概有以下 5 类：\nI/O 类型的指令,比如处理和内存间数据交换的指令 store/load 等；。\n计算机类型指令,最多处理两个寄存器,加减法,位运算,比较大小等\n跳转类型指令,用处就是修改PC指针,比如编程中大家经常遇到需要条件判断+跳转的逻辑,比如 if-else，swtich-case、函数调用等.\n**信号类型的指令,**比如发送中断的指令trap;\n闲置CPU的指令NUP,一般 CPU 都有这样一条指令，执行后 CPU 会空转一个周期。\n\n指令还有一个分法，就是寻址模式，比如同样是求和指令，可能会有 2 个版本：\n将两个寄存器的值相加的 add 指令。\n\n将一个寄存器和一个整数相加的 addi 指令。\n\n\n加载内存中的数据到寄存器的 load 指令也有不同的寻址模式：\n直接寻址:直接加载一个内存地址中的数据到寄存器的指令la.\n寄存器寻址:直接将一个数值导入寄存器的指令LI.\n**间接寻址:**将一个寄存器中的数值作为地址,然后再去加载这个地址中的数据的指令LW.\n\n因此寻址模式是从指令如何获取数据的角度，对指令的一种分类，目的是给编写指令的人更多选择。\n指令的执行速度:指令的执行速度:通过石英晶体的脉冲转化成时钟信号驱动的，每次高低电平的转换就是一个周期。我们称为时钟周期。\n通过石英晶体的脉冲转换成时钟信号驱动,每次高低电平的转换就是一个周期,我们称为时钟周期\n总结64 位和 32 位比较有哪些优势？【解析】 分类讨论：\n如果说的是 64 位宽 CPU，那么有 2 个优势：\n优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。\n\n优势 2：64 位 CPU 可以寻址更大的内存空间\n\n\n如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。\n\n32 位指令在 64 位机器上执行，困难不大，可以兼容。 \n\n如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。\n\n操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。\n\n\n","categories":["-操作系统"],"tags":["基础"]},{"title":"十大算法——KMP算法","url":"http://example.com/2020/10/13/算法-常用10种算法004-KMP算法/","content":"KMP 算法应用场景-字符串匹配问题 字符串匹配问题:\n\n有一个字符串 str1=”BBCABCDABABCDABCDABDE”，和一个子串 str2=”ABCDABD”\n现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1\n\n暴力匹配算法如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有:\n  \n\n1.如果当前字符匹配成功(即str1[i]&#x3D;&#x3D;str2[j]),则i++,j++,继续匹配下一个字符2.如果匹配失败(即str1[i]!&#x3D;str2[j]),\t令i&#x3D;i-(j-1),j&#x3D;0    相当于,每次匹配失败时,i回溯,j被重置为0.3.暴力方法解决的话会有大量的回溯,每一次只移动一位,若是不匹配,移动到下一位紧邻的判断,浪费了大量的时间.(不可行).\n\n代码:\npublic class ViolenceMatch &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\t//测试暴力匹配算法\t\tString str1=&quot;BBCABCDABABCDABCDABDE&quot;;\t\tString str2=&quot;ABCDABD&quot;;\t\tint index = violenceMatch(str1, str2);\t\tSystem.out.println(&quot;index=&quot; + index);\t&#125;\t// 暴力匹配算法实现\tpublic static int violenceMatch(String str1, String str2) &#123;\t\tchar[] s1 = str1.toCharArray();\t\tchar[] s2 = str2.toCharArray();\t\tint s1Len = s1.length;\t\tint s2Len = s2.length;\t\tint i = 0; // i索引指向s1\t\tint j = 0; // j索引指向s2\t\twhile (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;// 保证匹配时，不越界\t\t\tif(s1[i] == s2[j]) &#123;//匹配ok\t\t\t\ti++;\t\t\t\tj++;\t\t\t&#125; else &#123; //没有匹配成功\t\t\t\t//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。\t\t\t\ti = i - (j - 1);\t\t\t\tj = 0;\t\t\t&#125;\t\t&#125;\t\t\t//判断是否匹配成功\t\tif(j == s2Len) &#123;\t\t\treturn i - j;\t\t&#125; else &#123;\t\t\treturn -1;\t\t&#125;\t&#125;&#125;\n\nKMP 算法介绍KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次 回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间\n这个算法由 DonaldKnuth、Vaughan Pratt、JamesH.Morris 三人于 1977 年联合发表，故取这 3 人的 姓氏命名此算法. \nKMP 算法最佳应用-字符串匹配问题\n有一个字符串 str1=”BBCABCDABABCDABCDABDE”，和一个子str2=”ABCDABD” \n现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有则返回-1 \n要求：使用 KMP 算法完成判断，不能使用简单的暴力匹配算法.\n\n思路分析图解举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ \n1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位 \n\n\\2. 重复第一步， 还是不符合， 再后移  \n\n\\3. 一直重复， 直到 Str1 有一个字符与 Str2 的第一个字符符合为止  \n\n\\4. 接着比较字符串和搜索词的下一个字符， 还是符合。  \n\n5.遇到 Str1 有一个字符与 Str2 对应的字符不符合  \n\n6.这时候， 想到的是继续遍历 Str1 的下一个字符， 重复第 1 步。 (其实是很不明智的， 因为此时 BCD 已经比较过了，没有必要再做重复的工作， 一个基本事实是， 空格与 D 不匹配时， 你其实知道前面六个字符是” ABCDAB” 。KMP 算法的想法是， 设法利用这个已知信息， 不要把” 搜索位置” 移回已经比较过的位置， 继续把它向后移，这样就提高了效率。 )  \n\n\n8.已知空格与 D 不匹配时， 前面六个字符” ABCDAB” 是匹配的。 查表可知， 最后一个匹配字符 B 对应的” 部分匹配值” 为 2， 因此按照下面的公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值因为 6 - 2 等于 4， 所以将搜索词向后移动 4 位。\n9.因为空格与Ｃ 不匹配， 搜索词还要继续往后移。 这时， 已匹配的字符数为 2（” AB” ） ， 对应的” 部分匹配值”为 0。 所以， 移动位数 = 2 - 0， 结果为 2， 于是将搜索词向后移 2 位。  \n\n10.因为空格与 A 不匹配， 继续后移一位。  \n\n11.逐位比较， 直到发现 C 与 D 不匹配。 于是， 移动位数 = 6 - 2， 继续将搜索词向后移动 4 位。  \n\n12.逐位比较， 直到搜索词的最后一位， 发现完全匹配， 于是搜索完成。 如果还要继续搜索（即找出全部匹配） ，移动位数 = 7 - 0， 再将搜索词向后移动 7 位， 这里就不再重复了。  \n\n13.介绍《部分匹配表》 怎么产生的先介绍前缀， 后缀是什么  \n\n“部分匹配值” 就是” 前缀” 和” 后缀” 的最长的共有元素的长度。 以” ABCDABD” 为例，－” A” 的前缀和后缀都为空集， 共有元素的长度为 0；－” AB” 的前缀为[A]， 后缀为[B]， 共有元素的长度为 0；－” ABC” 的前缀为[A, AB]， 后缀为[BC, C]， 共有元素的长度 0；－” ABCD” 的前缀为[A, AB, ABC]， 后缀为[BCD, CD, D]， 共有元素的长度为 0；－” ABCDA” 的前缀为[A, AB, ABC, ABCD]， 后缀为[BCDA, CDA, DA, A]， 共有元素为” A” ， 长度为 1；－” ABCDAB” 的前缀为[A, AB, ABC, ABCD, ABCDA]， 后缀为[BCDAB, CDAB, DAB,AB, B]， 共有元素为” AB”，长度为 2；－” ABCDABD” 的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]， 后缀为[BCDABD,CDABD, DABD, ABD, BD,D]， 共有元素的长度为 0。  \n14.” 部分匹配” 的实质是， 有时候， 字符串头部和尾部会有重复。 比如， ” ABCDAB” 之中有两个” AB” ， 那么它的” 部分匹配值” 就是 2（” AB” 的长度） 。 搜索词移动的时候， 第一个” AB” 向后移动 4 位（字符串长度-部分匹配值） ， 就可以来到第二个” AB” 的位置。  \n\n到此 KMP 算法思想分析完毕!  \n代码核心部位:&#x2F;&#x2F;KMP算法核心点, 可以验证...\t\t\twhile( j &gt; 0 &amp;&amp; str1.charAt(i) !&#x3D; str2.charAt(j)) &#123;\t\t\t\tj &#x3D; next[j-1]; \t\t\t&#125; &#x2F;&#x2F;这时kmp算法的核心点    while(j &gt; 0 &amp;&amp; dest.charAt(i) !&#x3D; dest.charAt(j)) &#123;     j &#x3D; next[j-1];     &#125;\t\t\t\n\n获取到一个字符串(子串) 的部分匹配值表\npublic static  int[] kmpNext(String dest) &#123;\t//创建一个next 数组保存部分匹配值\tint[] next = new int[dest.length()];\tnext[0] = 0; //如果字符串是长度为1 部分匹配值就是0\tfor(int i = 1, j = 0; i &lt; dest.length(); i++) &#123;\t\t//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j\t\t//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出\t\t//这时kmp算法的核心点\t\twhile(j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;\t\t\tj = next[j-1];\t\t&#125;\t\t\t\t//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1\t\tif(dest.charAt(i) == dest.charAt(j)) &#123;\t\t\tj++;\t\t&#125;\t\tnext[i] = j;\t&#125;\treturn next;&#125;\n\n完整代码package com.atguigu.kmp;import java.util.Arrays;public class KMPAlgorithm &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tString str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;;\t\tString str2 = &quot;ABCDABD&quot;;\t\t//String str2 = &quot;BBC&quot;;\t\t\t\tint[] next = kmpNext(&quot;ABCDABD&quot;); //[0, 1, 2, 0]\t\tSystem.out.println(&quot;next=&quot; + Arrays.toString(next));\t\t\t\tint index = kmpSearch(str1, str2, next);\t\tSystem.out.println(&quot;index=&quot; + index); // 15了\t\t\t\t\t&#125;\t\t//写出我们的kmp搜索算法\t/**\t * \t * @param str1 源字符串\t * @param str2 子串\t * @param next 部分匹配表, 是子串对应的部分匹配表\t * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置\t */\tpublic static int kmpSearch(String str1, String str2, int[] next) &#123;\t\t\t\t//遍历 \t\tfor(int i = 0, j = 0; i &lt; str1.length(); i++) &#123;\t\t\t\t\t\t//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小\t\t\t//KMP算法核心点, 可以验证...\t\t\twhile( j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;\t\t\t\tj = next[j-1]; \t\t\t&#125;\t\t\t\t\t\tif(str1.charAt(i) == str2.charAt(j)) &#123;\t\t\t\tj++;\t\t\t&#125;\t\t\t\t\t\tif(j == str2.length()) &#123;//找到了 // j = 3 i \t\t\t\treturn i - j + 1;\t\t\t&#125;\t\t&#125;\t\t\t\treturn  -1;\t&#125;\t//获取到一个字符串(子串) 的部分匹配值表\tpublic static  int[] kmpNext(String dest) &#123;\t\t//创建一个next 数组保存部分匹配值\t\tint[] next = new int[dest.length()];\t\tnext[0] = 0; //如果字符串是长度为1 部分匹配值就是0\t\tfor(int i = 1, j = 0; i &lt; dest.length(); i++) &#123;\t\t\t//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j\t\t\t//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出\t\t\t//这时kmp算法的核心点\t\t\twhile(j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;\t\t\t\tj = next[j-1];\t\t\t&#125;\t\t\t\t\t\t//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1\t\t\tif(dest.charAt(i) == dest.charAt(j)) &#123;\t\t\t\tj++;\t\t\t&#125;\t\t\tnext[i] = j;\t\t&#125;\t\treturn next;\t&#125;&#125;\n\n","categories":["-算法"],"tags":["常用10种算法"]},{"title":"操作系统01-2-程序如何执行","url":"http://example.com/2020/10/13/操作系统00-2/","content":"操作系统–前言02程序是如何执行的？我们先来看一道常规的面试题：相比 32 位，64 位的优势是什么？\n\n如果是软件，那么我们的数据库有 32 位和 64 位版本；\n如果是操作系统，那么在阿里云上选择 Centos 和 Debian 版本的时候，也会有 32/64 版本；\n如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU。\n\n  \n\n图灵机的构造计算机科学方面有两个巨大的贡献：\n清楚的定义了计算机能力的边界,也就是可计算理论\n定义了计算机由哪些部分组成,程序又是如何让执行的\n\n图灵机的内部构造\n图灵机拥有一条无限长的纸带,纸带上是一个格子挨着一个格子,格子中可以写字符,你可以把纸带看成内存,而这些字符可以看作是内存中的数据或者程序.\n图灵机有一个读写头,读写头可以读取任意格子上的字符,也可以改写任意格子的字符.\n读写头上面的盒子里面是一些精密的零件,包括图灵机的储存,控制单元和运算单元.\n\n图灵机如何执行程序​        下面我们来举一个例子，让大家弄清楚图灵机是如何工作的，比如我们要计算 11 + 15 的值，具体的运算步骤如下：\n\n首先，我们将“11、15、+” 分别写入纸带上的 3 个格子（现在纸带上的字符串是11、15、 +)，然后将读写头先停在 11 对应的格子上。\n\n接下来，图灵机通过读写头读入 11 到它的存储设备中（这个存储设备也叫作图灵机的状态）。图灵机没有说读写头为什么可以识别纸带上的字符，而是假定读写头可以做到这点。\n\n然后读写头向右移动一个格，用同样的方法将 15 读入图灵机的状态中。现在图灵机的状态中有两个连续的数字，11 和 15。\n\n\n\n\n运算流程是:\n\n读写到一个加号\n然后将+号传输控制单元\n由于控制单元发现其为一个+号,所以没有存入状态,因为原来就一定预定了+号为一个指令,目的就是加和当前的状态,因此,控制单元识别出控制符,并通知运算单元工作.\n运算单元从状态中读入 11、15 并进行计算，将结果 26 存储到状态\n运算单元将结果回传给控制单元；\n控制单元将结果传输给读写头.\n\n\n\n读写头向右移动，将结果 26 写入纸带。\n\n图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令）\n冯诺依曼模型\n计算机结构分成以下 5 个部分：\n\n输入设备；\n输出设备；\n内存；\n中央处理器；\n总线。\n\n这个模型也被称为冯诺依曼模型，下面我们具体来看看这 5 部分的作用。\n内存\n存储的数据单位是一个二进制位，英文是 bit( 8 位，英文是 byte)\n随机存取器，读取任何一个地址数据的速度是一样的\n\nCPU\n如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；\n如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。\n\n这里的 32 和 64，称作 CPU 的位宽。\n控制单元和逻辑运算单元\n控制单元专门负责控制 CPU 工作；\n逻辑运算单元专门负责计算。\n\n寄存器寄存器在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。\n\n寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是通用寄存器。\n\n还有一部分寄存器有特殊的用途，叫作特殊寄存器。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。\n\n下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作指令寄存器。指令被执行完成之前，指令都存储在这里。\n\n\n总线CPU内存以及其他设备之间,也要通讯,因此我们用一种特殊的设备进行控制,就是总线.分为三种:\n\n地址总线:专门用来指定cpu将要操作的内存地址\n\n数据总线:用来读写内存中的数据\n当cpu需要读写的内存的时候,先要通过地址总线来指定内存地址,再通过数据总线来传输数据.\n\n控制总线:用来发送和接受信号.中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。\n\n\n输入、输出设备\n输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。\n输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线\n\n线路位宽问题通过操作电压，低电压是 0，高电压是 1。\n一条线路:只能传递 1 个信号,必须在 0,1 中选一个.只能操作两个内存地址\n10 条地址总线;一次就可以表示 2^10 种情况，也就是可以操作 1024 个内存地址\n32 条线 :2^32 是 4G。 可以操作4G 的内存地址.\n64 位和 32 位的计算32 位宽的 CPU 控制 40 位宽\n\n地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。\n\n把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，\n\n\n64 位的 CPU 就可以一次读入 64 位的数字\n\n64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算\n\n注:不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。\n注意:32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如说有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 232 个内存地址，也就是 4G 内存地址。\n","categories":["-操作系统"],"tags":["基础"]},{"title":"操作系统01-1-计算","url":"http://example.com/2020/10/12/操作系统00-1/","content":"操作系统–前言01可不可以计算一个人程序写得好不好？\n“计算”可以涉及到计算机本源的有趣的知识,比如图灵机、冯诺依曼模型；再比如说 CPU 的构成、程序如何执行、缓存的分级、总线的作用等。\n芯片：计算能源\n第一次工业革命出现了蒸汽机，能源是煤炭\n第二次工业革命出现了发电机，能源是电\n第三次科技革命，革命产物是计算机\n第四次科技革命，就发生在当下，出现了人工智能，能源是数据。\n\n  \n\n第三次科技革命的能源是一种数字能量，本质是计算\n\n\n​        电能供给给芯片，芯片中的一种电子元件晶振（也就是石英晶体）通电后产生震荡，震荡会产生频率稳定的脉冲信号。通常这是一种高频的脉冲信号，每秒可达百万次。然后，我们通过谐振效应发放这个信号，形成方波。再通过电子元件调整这种脉冲的频率，把脉冲信号转换为我们需要的频率，这就形成了驱动芯片工作的时钟信号。这种信号的频率，我们也称作芯片的时钟频率。最后，时钟信号驱动着芯片工作，就像人体的脉搏一样，每一次脉冲到来，都让芯片的状态发生一次变化，用这种方法，最终存储器中的指令被一行行执行。指令被执行，其实就是数据被计算，这就是我说的计算能量。\n芯片普及后,应用到我们生活中大大小小的物件,有了芯片，设备通电后才可以计算，有了计算，这些设备才能够实现更加复杂而精确的功能。\n摩尔定律：计算能力的发展\n第一个芯片:被称作集成电路， 1958 年由美国德州仪器公司的工程师杰克·基尔比发明\n第一台通用计算机:ENIAC 则是在 1946 年诞生于美国陆军弹道研究实验室。\n\nIntel 的创始人之一摩尔就观察到了这个现象，并提出了摩尔定律：当价格不变时，集成电路中可容纳的晶体管数目约每隔 18～24 个月就会增加一倍，性能也将提升一倍。\n这一定律揭示了信息技术发展的速度，但到今天，摩尔定律失效了。因为随着芯片越来越小，在尺寸和散热等方面已经挑战了人类的极限，芯片中无法再放入更多的电子元件了。\n展望未来，计算能力还有更多的增长点，不仅有可以无限提高计算能力的量子计算机，还有利用光学元件替代晶体元件的光电集成电路。\n可计算理论：图灵机生活在数字时代的我们，用着导航、玩着游戏，本能地知道很多问题是可以被计算的，生活在 20 世纪初的科学家们，需要在没有计算机和芯片的时代就想清楚这些问题，并不是一件容易的事情。\n公理化体系和不完备性定理因为世界上存在着大量的这种“公说公有理，婆说婆有理”的问题，才让大家认识到计算不能解决所有问题，所以：计算机能力也是有边界的。哥德尔的不完备性定理，让大家看到了世界上还有大量不可计算的问题。\n图灵机和可计算理论哪些问题可以被计算，哪些不可以被计算\n人工智能之父的阿兰·图灵提出了图灵机:它是一种不断执行指令的抽象计算机\n图灵发现如果一个问题是可计算的，那么它的解决方案就必须可以被具化成一条条的指令，也就是可以使用图灵机处理。因此，不能使用图灵机处理的问题，都是不可计算的问题。\n比如一个马达的控制程序是可计算的，因为控制过程是可以被抽象成一条条指令的（即可以写程序实现）\n不可计算问题当图灵机遇到“素数是不是有无穷多个”？\n如果素数是无穷的，那么我们的计算就是无穷无尽的，所以这样的问题不可计算。\n停机问题​        我们也无法实现用一个通用程序去判断另一个程序是否会停止。比如你用运行这段程序来检查一个程序是否会停止时，你会发现不能因为这个程序执行了 1 天，就判定它不会停止，也不能因为这个程序执行了 10 年，从而得出它不会停止的结论。这个问题放到图灵机领域，叫作停机问题，我们无法给出一个判断图灵机是否会停机的通用方法，因此停机问题是一个经典的不可计算问题\n计算能力的边界在哪里？\n解决问题往往需要消耗芯片的计算能力，这通常称作时间开销\n另外解决问题还需要消耗内存，称作空间开销。\n\n问题的分类世界上有一类问题，无论我们消耗多少时间和空间也无法解决，这类问题就包括“停机问题”，称作不可计算问题，\n可计算问题   &lt;   不可计算问题\nP 问题 vs NP 问题\n有能力解决的问题，统称为多项式时间（ Polynomial time）问题。今天能解决的问题，都是多项式时间的问题，下面记为 P 类型的问题\n问题如果不能在多项式时间内找到答案，我们记为 NP 问题。\n\n有一部分 NP 问题可以被转化为 P 问题，比如斐波那契数列求第 N 项，可以用缓存、动态规划等方式转化为 O(N) 的问题。但还有更多的 NP 问题，比如一个集合，找出和为零的子集，就没能找到一个合适的转换方法。\n今还有很多问题无法解决，它的数量远远大于我们可以解决的问题，科学家、工程师们也只能望洋兴叹了\n人工智能包括停机问题、包括 NP 问题在内的很多问题，虽然不能解决，但可以努力让计算机的解决方案超过人类的水平，这就是人工智能。\nAlphaGo 战胜李世石就是利用了基于概率的不完全解法，这种解法已经可以超过部分人类职业选手了，也就是说计算机的解法已经超过了人类。\n人类的强项在于理解和分析，人有两种思维，归纳和假设，这两种思维都是计算机无法计算的。机器用概率理解围棋，局部来说机器下得更好，但是人可以制造机器，因此，人的感悟更有意义，谈不上孰优孰劣。\n可不可以计算一个人程序写得好不好？\n这个问题可以这样来思考，如果把问题降级，变成：“可不可以计算一个人写的程序会不会停机？”\n这个问题就如同停机问题，无法计算，因此这是一个不可计算的问题。\n但是我们通过\n设立规则，比如\n\n检查缩进、\n检查函数的复用情况、\n检查类的命名情况\n\n另外，我们也可以通过 AI 技术，让机器在“程序写得好不好”这个问题的判定能力上，达到人类的水平，通过图灵测试。\n综上，从绝对的对错角度去看，这是一个不可计算问题，因为它没有办法被完全解决；但是从图灵测试层面来看，虽然目前无法解决这个问题，但是我们有理由相信，在未来，计算机对这个问题的解决方案，是可以超过人类的。\n","categories":["-操作系统"],"tags":["基础"]},{"title":"十大算法——动态规划算法","url":"http://example.com/2020/10/12/算法-常用10种算法003-动态规划算法/","content":"动态规划算法介绍\n动态规划(Dynamic Programming)算法的核心思想是： 将大问题划分为小问题进行解决， 从而一步步获取最优解的处理算法\n动态规划算法与分治算法类似， 其基本思想也是将待求解问题分解成若干个子问题， 先求解子问题， 然后从这些子问题的解得到原问题的解。\n与分治法不同的是， 适合于用动态规划求解的问题， 经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上， 进行进一步的求解 )\n动态规划可以通过填表的方式来逐步推进， 得到最优解.  \n\n应用场景-背包问题  \n\n背包问题： 有一个背包， 容量为 4 磅 ， 现有如下物品  \n\n\n\n物品\n重量\n价格\n\n\n\n吉他\n1\n1500\n\n\n音响\n4\n3000\n\n\n电脑\n3\n2000\n\n\n\n要求达到的目标为装入的背包的总价值最大， 并且重量不超出\n要求装入的物品不能重复  \n\n思路分析和图解\n\n背包问题主要是指一个给定容量的背包、 若干具有一定价值和重量的物品， 如何选择物品放入背包使物品的价值最大。 其中又分 01 背包和完全背包(完全背包指的是： 每种物品都有无限件可用)\n这里的问题属于 01 背包， 即每个物品最多放一个。 而无限背包可以转化为 01 背包。\n算法的主要思想， 利用动态规划来解决。 每次遍历到的第 i 个物品， 根据 w[i]和 v[i]来确定是否需要将该物品\n放入背包中。 即对于给定的 n 个物品， 设 v[i]、 w[i]分别为第 i 个物品的价值和重量， C 为背包的容量。 再令 v[i][j]表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。 则我们有下面的结果  .\n\n思路:\n(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0 (2) 当 w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略 (3) 当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; // 当 准备加入的新增的商品的容量小于等于当前背包的容量, // 装入的方式: v[i-1][j]： 就是上一个单元格的装入的最大值 v[i] : 表示当前商品的价值 v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值 当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; :\n\n注:v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值\n\n\n\n物品\n0 磅\n1磅\n2磅\n3磅\n4磅\n\n\n\n\n0\n0\n0\n0\n0\n\n\n吉他(G)\n0\n1500(G)\n1500(G)\n1500(G)\n1500(G)\n\n\n音响(S)\n0\n1500(G)\n1500(G)\n1500(G)\n3000(S)\n\n\n电脑(L)\n0\n1500(G)\n1500(G)\n2000(L)\n2000(L)+1500(G)\n\n\n1. 假如现在只有  吉他(G) ， 这时不管背包容量多大，只能放一个吉他1500(G) 2. 假如有吉他和音响 , 验证公式:v[1][1] =15001. i = 1, j = 1 2. w[i] = w[1] = 1w [1] = 1  j = 1   v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; : v[1][1] = max &#123;v[0][1], v[1] + v[0][1-1]&#125; = max&#123;0, 1500 + 0&#125; = 1500v[3][4] 1. i = 3；j = 4w[i] = w[3] =3 j = 4j = 4 &gt;= w[i] = 3 =&gt; 4 &gt;= 3 v[3][4] = max &#123;v[2][4], v[3] + v[2][1]&#125; = max&#123;3000, 2000+1500&#125; = 2000+1500\n\n代码:基本变量int[] w = &#123;1, 4, 3&#125;;//物品的重量\t\tint[] val = &#123;1500, 3000, 2000&#125;; //物品的价值 这里val[i] 就是前面讲的v[i]\t\tint m = 4; //背包的容量\t\tint n = val.length; //物品的个数\n\n创建二维数组，//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值\t\tint[][] v = new int[n+1][m+1];\t\t//为了记录放入商品的情况，我们定一个二维数组\t\tint[][] path = new int[n+1][m+1];\t\t\t\t//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0\t\tfor(int i = 0; i &lt; v.length; i++) &#123;\t\t\tv[i][0] = 0; //将第一列设置为0\t\t&#125;\t\tfor(int i=0; i &lt; v[0].length; i++) &#123;\t\t\tv[0][i] = 0; //将第一行设置0\t\t&#125;\n\n根据前面得到公式来动态规划处理for(int i = 1; i &lt; v.length; i++) &#123; //不处理第一行 i是从1开始的\t\t\tfor(int j=1; j &lt; v[0].length; j++) &#123;//不处理第一列, j是从1开始的\t\t\t\t//公式\t\t\t\tif(w[i-1]&gt; j) &#123; // 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]\t\t\t\t\tv[i][j]=v[i-1][j];\t\t\t\t&#125; else &#123;\t\t\t\t\t//说明:\t\t\t\t\t//因为我们的i 从1开始的， 因此公式需要调整成\t\t\t\t\t//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);\t\t\t\t\t//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);\t\t\t\t\t//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式\t\t\t\t\tif(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123;\t\t\t\t\t\tv[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];\t\t\t\t\t\t//把当前的情况记录到path\t\t\t\t\t\tpath[i][j] = 1;\t\t\t\t\t&#125; else &#123;\t\t\t\t\t\tv[i][j] = v[i - 1][j];\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\n\n输出for(int i =0; i &lt; v.length;i++) &#123;\tfor(int j = 0; j &lt; v[i].length;j++) &#123;\t\tSystem.out.print(v[i][j] + &quot; &quot;);\t&#125;\tSystem.out.println();&#125;\n\n输出最后我们是放入的哪些商品错误代码:这样会便利出重复的情况\n//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入for(int i = 0; i &lt; path.length; i++) &#123;    for(int j=0; j &lt; path[i].length; j++) &#123;        if(path[i][j] == 1) &#123;            System.out.printf(&quot;第%d个商品放入到背包\\n&quot;, i);        &#125;    &#125;&#125;\n\nj -= w[i-1]; //w[i-1]       减重调整背包容量\nint i = path.length - 1; //行的最大下标int j = path[0].length - 1;  //列的最大下标while(i &gt; 0 &amp;&amp; j &gt; 0 ) &#123; //从path的最后开始找\tif(path[i][j] == 1) &#123;\t\tSystem.out.printf(&quot;第%d个商品放入到背包\\n&quot;, i); \t\tj -= w[i-1]; //w[i-1] 减重调整背包容量\t&#125;\ti--;&#125;\n完整代码:public class KnapsackProblem &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tint[] w = &#123;1, 4, 3&#125;;//物品的重量\t\tint[] val = &#123;1500, 3000, 2000&#125;; //物品的价值 这里val[i] 就是前面讲的v[i]\t\tint m = 4; //背包的容量\t\tint n = val.length; //物品的个数\t\t\t\t\t\t\t\t//创建二维数组，\t\t//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值\t\tint[][] v = new int[n+1][m+1];\t\t//为了记录放入商品的情况，我们定一个二维数组\t\tint[][] path = new int[n+1][m+1];\t\t\t\t//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0\t\tfor(int i = 0; i &lt; v.length; i++) &#123;\t\t\tv[i][0] = 0; //将第一列设置为0\t\t&#125;\t\tfor(int i=0; i &lt; v[0].length; i++) &#123;\t\t\tv[0][i] = 0; //将第一行设置0\t\t&#125;\t\t\t\t\t\t//根据前面得到公式来动态规划处理\t\tfor(int i = 1; i &lt; v.length; i++) &#123; //不处理第一行 i是从1开始的\t\t\tfor(int j=1; j &lt; v[0].length; j++) &#123;//不处理第一列, j是从1开始的\t\t\t\t//公式\t\t\t\tif(w[i-1]&gt; j) &#123; // 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]\t\t\t\t\tv[i][j]=v[i-1][j];\t\t\t\t&#125; else &#123;\t\t\t\t\t//说明:\t\t\t\t\t//因为我们的i 从1开始的， 因此公式需要调整成\t\t\t\t\t//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);\t\t\t\t\t//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);\t\t\t\t\t//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式\t\t\t\t\tif(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123;\t\t\t\t\t\tv[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];\t\t\t\t\t\t//把当前的情况记录到path\t\t\t\t\t\tpath[i][j] = 1;\t\t\t\t\t&#125; else &#123;\t\t\t\t\t\tv[i][j] = v[i - 1][j];\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\t//输出一下v 看看目前的情况\t\tfor(int i =0; i &lt; v.length;i++) &#123;\t\t\tfor(int j = 0; j &lt; v[i].length;j++) &#123;\t\t\t\tSystem.out.print(v[i][j] + &quot; &quot;);\t\t\t&#125;\t\t\tSystem.out.println();\t\t&#125;\t\t\t\tSystem.out.println(&quot;============================&quot;);\t\t//动脑筋\t\tint i = path.length - 1; //行的最大下标\t\tint j = path[0].length - 1;  //列的最大下标\t\twhile(i &gt; 0 &amp;&amp; j &gt; 0 ) &#123; //从path的最后开始找\t\t\tif(path[i][j] == 1) &#123;\t\t\t\tSystem.out.printf(&quot;第%d个商品放入到背包\\n&quot;, i); \t\t\t\tj -= w[i-1]; //w[i-1]\t\t\t&#125;\t\t\ti--;\t\t&#125;\t\t\t&#125;&#125;\n\n","categories":["-算法"],"tags":["动态规划","常用10种算法","01背包"]},{"title":"十大算法——分治算法","url":"http://example.com/2020/10/12/算法-常用10种算法002-分治算法/","content":"分治算法介绍分治法是一种很重要的算法.由他的字面就可以得到”分而治之”,就是把一个复杂的问题,拆分为若干个子的问题.逐一进行解析.,在把若干个简单的子问题,继续拆分,直到不能拆分为止.\n技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……\n可以解决的问题有:\n二分搜索,大整数乘法,棋盘覆盖,合并排序,快速排序,线性时间选择,最近近点对问题,循环赛日程表. 汉诺塔.\n  \n\n分治算法的基本步骤分治法在每一层递归上都有三个步骤：1)分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题\n2)解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题\n3)合并：将各个子问题的解合并为原问题的解。\n分治算法最佳实践-汉诺塔汉诺塔的传说\n​        汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n​        假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。\n汉诺塔游戏的演示和思路分析:1)如果是有一个盘，A-&gt;C如果我们有n&gt;=2情况，我们总是可以看做是两个盘1.最下边的盘2.上面的盘2)先把最上面的盘A-&gt;B3)把最下边的盘A-&gt;C4)把B塔的所有盘从B-&gt;C\n汉诺塔游戏的代码实现:package com.atguigu.dac;public class Hanoitower &#123;\tpublic static void main(String[] args) &#123;\t\thanoiTower(3, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);\t&#125;\t\t//汉诺塔的移动的方法\t//使用分治算法\t\tpublic static void hanoiTower(int num, char a, char b, char c) &#123;\t\t//如果只有一个盘\t\tif(num == 1) &#123;\t\t\tSystem.out.println(&quot;第1个盘从 &quot; + a + &quot;-&gt;&quot; + c);\t\t&#125; else &#123;\t\t\t//如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘\t\t\t//1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c\t\t\thanoiTower(num - 1, a, c, b);\t\t\t//2. 把最下边的盘 A-&gt;C\t\t\tSystem.out.println(&quot;第&quot; + num + &quot;个盘从 &quot; + a + &quot;-&gt;&quot; + c);\t\t\t//3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  \t\t\thanoiTower(num - 1, b, a, c);\t\t\t\t\t&#125;\t&#125;&#125;\n\n输出\n第1个盘从 A-&gt;C第2个盘从 A-&gt;B第1个盘从 C-&gt;B第3个盘从 A-&gt;C第1个盘从 B-&gt;A第2个盘从 B-&gt;C第1个盘从 A-&gt;C\n\n","categories":["-算法"],"tags":["常用10种算法"]},{"title":"javaSE-04-运算符","url":"http://example.com/2020/10/11/javaSE04/","content":"java运算符算术运算符：  +，-，*，/，%，++，–\n字符串连接运算符：+关系(比较)运算符： &gt;，&lt;，&gt;=，&lt;=，==，!=逻辑运算符： !，&amp; ， |  ， &amp;&amp;，||赋值运算符：  =  ，+ =，- =，* =，/ =条件运算符位运算符\n算术运算符\n\n\n\n\n运算符\n运算\n范例\n结果\n\n\n\n+\n正号\n+3\n3\n\n\n-\n负号\nb=4; -b\n-4\n\n\n+\n加\n5+5\n10\n\n\n-\n减\n6-4\n2\n\n\n*****\n乘\n3*4\n12\n\n\n/\n除\n5/5\n1\n\n\n%\n取模\n7%5\n2\n\n\n++\n自增（前）：先运算后取值__自增（后）：先取值后运算\na=2;b=++a;~~a=2;b=a++;\na=3;b=3~~a=3;b=2\n\n\n- -\n自减（前）：先运算后取值__自减（后）：先取值后运算\na=2;b=- -a~~a=2;b=a- -\na=1;b=1~~a=1;b=2\n\n\n+\n字符串相加\n“He”+”llo”\n“Hello”\n\n\n+  正数  加法  字符串连接-  负数  减法*  乘法/  除法%  取余数++ 自加-- 自减\n\n1.example:\n+正数  加法  字符串连接int a=1;      int b=2;      double e=12.21;      char c=&#x27;a&#x27;;      String s=&quot;22&quot;;      System.out.println(a+b);//数值+数值=数值      System.out.println(c+b);//字符+数值=数值      System.out.println(e+s);//数值+字符串=字符串      System.out.println(b+e);/***有多种类型的数据混合运算时，                               系统首先自动的将所有数据转换成                               容量最大的那一种数据类型                               ，然后再进行计算***/\n\n结果:\n39912.212214.21\n\n有多种类型的数据混合运算时，系统首先自动的将所有数据转换成==容量最大的那一种数据类型==，然后再进行计算\n-负数  减法int d = -10;        System.out.println(a+d); //结果 -9\n\n*  % 数值与数值(char)System.out.println(b%a);//取余数  判断两个数是否整除则结果为零即余数为零\n\n++自增1  –自减1int x=5;       x++; //x=x+1 6       ++x; //x=x+1 7       --x;//x=x-1 6       x--;//x=x-1 5       System.out.println(x); //输出位5       int k=5;       int l = k++ + 1; //注意: ++在混合运算中 ++在后先运算后自增                        //++在前先自增后运算       System.out.println(l); //输出为6       System.out.println(k);//输出为6\n\n ==++在混合运算中 ++在后先运算后自增 ++在前先自增后运算==\n比较运算符==,!=,基本类型数值与数值之间的比较,引用类型与引用类型之间的比较\n&gt; &lt;  &gt;= &lt;= 数值与数值(char)\n\n\n\n运算符\n运算\n范例\n结果\n\n\n\n==\n相等于\n4==3\nfalse\n\n\n!=\n不等于\n4!=3\ntrue\n\n\n&lt;\n小于\n4&lt;3\nfalse\n\n\n&gt;\n大于\n4&gt;3\ntrue\n\n\n&lt;=\n小于等于\n4&lt;=3\nfalse\n\n\n&gt;=\n大于等于\n4&gt;=3\ntrue\n\n\ninstanceof\n检查是否是类的对象\n“Hello” instanceof String\ntrue\n\n\nint a=10;int b=5;System.out.println(a==b);//输出 false  //基本类型数值之间的比较System.out.println(a!=b);//输出 trueString s = &quot;ab&quot;;String s1 = &quot;ab&quot;;System.out.println(s==s1);//输出 true     //引用类型与引用类型比较System.out.println(s!=s1);//输出 false\n\n字符型\nchar c = &#x27;a&#x27;; //97      System.out.println(&#x27;a&#x27;&gt;&#x27;b&#x27;);      System.out.println(&#x27;a&#x27;&gt;=c);\n\n逻辑运算符&amp;—逻辑与         | —逻辑或         ！—逻辑非\n==&amp;&amp; —短路与      || —短路或==        ^ —逻辑异或\n与运算&amp;&amp; . &amp;  有0即为零int a = 10;int b = 5;int c  = 15;System.out.println(a&gt;b &amp; b&lt;c);//true &amp; true = trueSystem.out.println(a&gt;b &amp; b&gt;c);//true &amp; false = falseSystem.out.println(a&lt;b &amp; b&gt;c);//false &amp; false = falseSystem.out.println(a&gt;b &amp;&amp; b&lt;c);//true &amp; true = trueSystem.out.println(a&gt;b &amp;&amp; b&gt;c);//true &amp; false = falseSystem.out.println(a&lt;b &amp;&amp; b&gt;c);//false &amp; false = false\n\n\n\n==&amp; 遇到第一个false后面,后面继续运行==\nint a = 10;int b = 5;int c  = 15;System.out.println(a&lt;b &amp; ++b&lt;c);//false &amp; true = false         System.out.println(b); //b=6\n\nb=6\n\n\n==&amp;&amp;遇到第一个false后面,后面则不运行继续运行==\nint a = 10;int b = 5;int c  = 15; System.out.println(a&lt;b &amp;&amp; ++b&lt;c);//false &amp; true = false         System.out.println(b); //b=5\n\nb=5\n与运算|| . |  有0即为零​    ==|  遇到第一个true后,后面的表达式还会执行==​    ==|| 遇到第一个true后,就会短路后面的表达式不会执行====\nint a = 10;int b = 5;int c  = 15;System.out.println(a&gt;b | b&lt;c);//true | true = trueSystem.out.println(a&gt;b | b&gt;c);//true | false = trueSystem.out.println(a&lt;b | b&gt;c);//false | false = falseSystem.out.println(a&gt;b || b&lt;c);//true || true = trueSystem.out.println(a&gt;b || b&gt;c);//true || false = trueSystem.out.println(a&lt;b || b&gt;c);//false || false = false\n\n异或( ^ )：\n当左右都为true时，结果为false。\n==理解：异或，追求的是“异”!==\n\n赋值运算符char short char-&gt;int -&gt;long -&gt;flaot-&gt;double\n=\n注意:两边类型与值匹配~~int a=10;\n基本数据类型转换:默认转换,强制类型转换\nlong b = a;byte c = (byte)b;\n\n\n\n用法举例\n等效的表达式\n\n\n\na += b\na = a+b\n\n\na -= b\na = a-b\n\n\na *= b\na = a*b\n\n\na /= b\na = a/b\n\n\na %= b\na = a%b\n\n\n判断:\n    short s = 3;    (1) s =s+2;    (2) s += 2; System.out.println(s);\n\n对于(1)来说:S+2运算时会自动提升变表达式的类型,所以结果是int类型的,在赋值给short形的s,编译器会将报告:需要强制转换类型错误\n对于(2)由于+=是java语言规定的运算符,java编译器会对它进行特殊处理,因此可以理解为正确.\n\n\n\n\n\n 区分好==和=的区别。即===\n\n一个等号 对值的比较  Java中相当于赋值\n两个等会java中相当于 if判断\n三个等号在java中没有,但是在JavaScript\n\n\n==，两边值类型不同的时候，要先进行类型的转换，再比较。\n\n==，不做类型转换的时候，类型不同的一定不等。\n==是非严格相等运算符：只比较值是否相等\n===是严格相等运算符：既比较值是否相等还比较类型是否相等\n\n\n条件运算符(条件表达式)? 表达式1：表达式2；\n\n为true，运算后的结果是表达式1；\n\n为false，运算后的结果是表达式2；\n\n表达式1和表达式2为同种类型\n\n\nint a = 10;      int b = 5;      int c  = (a&gt;b)?a:b; //需要返回一个结果      System.out.println(c);  //输出 10\n\n位运算特点:使用位运算可以大量减少运行开销\n 是二进制位(bit位) 上的运算, 执行效率高\n\n&lt;&lt;  左移 左移1位相当于*2\n&gt;&gt; 右移\n&gt;&gt;&gt;无符号右移  不需要关心高位上的符号 (如果影响到了符号位,只需要在符号位补0)\n\nint a = 2;      System.out.println(a&lt;&lt;2);// 输出8\n\n\n\n最有效率的方法求出2乘几等于8    2&lt;&lt;3，因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘剩以8等於几的最效率的方法是2&lt;&lt;3。\n\n\n\n&amp;\n与运算   二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;\n\n\n\n|\n或运算 二进制位进行 | 运算，只有0 | 0时结果是0，否则是1;\n\n\n^\n相同二进制位进行 ^ 运算，结果是0；1^1=0 , 0^0=0不相同二进制位 ^ 运算结果是1。1^0=1 , 0^1=1\n\n\n~\n正数取反，各二进制码按补码各位取反负数取反，各二进制码按补码各位取反\n\n\n练习int a=5,b=10;  把a与b的值交换（仅使用a,b两个变量）\nint a = 10;    int b = 5;   /* a = a+b; //a=10+5 = 15    b = a-b;//b=15-5 =10    a = a-b;    System.out.println(a);    System.out.println(b);*/    /*       1010       0101       1111  a^b 15  用两个数异或后的结果 与其中一个值进行异或操作 其值等于另一个值.       0101       1010     */    a = a^b;    System.out.println(a);    b = a^b;    System.out.println(b);    a=a^b;    System.out.println(a);\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"javaSE-03-数据类型","url":"http://example.com/2020/10/11/javaSE03/","content":"Java变量\n变量:程序中最基本的储存单元,程序执行中数值可变.变量其实是内存中的一小块区域，使用变量名来访问这块区域，试用前必须先申请(声明),然后必须赋值,才能使用.\n\n变量是通过使用变量名来访问这块区域的.\n要素:变量名,变量类型.\n试用前必须声明:\n[修饰符]   type    varName [=value][,varName[=value]……]；    例如：\u000b     int i = 100; \u000b\n\n\n\n\n\nJava数据类型数据类型\n强数据语言,指导JVM分配内存空间在内存分配不同的大小的内存空间\n按数据类型\n基本数据类型\n数值型\n整数类型(byte,short,int,long)\n浮点类型(float,double)\n\n\n字符型(char)\n布尔型(boolean)\n\n\n引用数据类型\n类(class):包含字符串\n接口(interface)\n数组([])\n\n\n\n变量分类\n从数据类型角度分:\n基本数据类型\n引用数据类型\n\n\n位置角度\n成员变量/类的属性(定义在类中)\n局部变量(定义在方法中)\n\n\n\n使用变量时:在赋值时需要注意与类型一致相匹配.\n整数类型Java 各整数类型有固定的表数范围和字段长度，其不受具体操作系统的影响，以保证Java程序的可移植性\n\n\n\n类  型\n占用存储空间\n表数范围\n\n\n\nbyte\n1字节\n-128 ～ 127\n\n\nshort\n2字节\n-2^15 ～ 2^15-1\n\n\nint\n4字节\n-2^31 ～ 2^31-1\n\n\nlong\n8字节\n-2^63 ～ 2^63-1\n\n\nJava语言的整型常量默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ ，\nfloat的容量大于int long\n对于整数,有四种表示方式:\n\n二进制：0,1 ，满2进1.以0b或0B开头。\n\n十进制：0-9 ，满10进1.\n\n八进制：0-7 ，满8进1. 以数字0开头表示。\n\n十六进制：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。\n\n\n浮点类型与整数类型类似，Java浮点类型有固定的表数范围和字段长度，不受平台影响。\nJava 浮点类型有两种表示形式\n\n十进制数形式，例如: 3.14       314.0      \n\n科学记数法形式，如 3.14e2      3.14E2 \n\n\n==float 4字节  4字节的浮点的容量大于 4字节,8字节的整数==\n\n\n\n类  型\n占用存储空间\n表数范围\n\n\n\nfloat\n4字节\n-3.403E38～3.403E38\n\n\ndouble\n8字节\n-1.798E308～1.798E308\n\n\n 浮点型常量默认为 double 型，如要声明一个常量为 float 型，则需在数字后面加 f 或 F    \n 如：double d = 12345.6; //正确   float f = 12.3f; //必须加f否则会出错\n计算机的浮点数是以近似值方式存储\npublic static void main(String[] args) &#123;    float a&#x3D;10.2F;    double b&#x3D;10.3;    System.out.println(b-a);&#125;\n\n结果:0.10000019073486399\n逻辑型boolean(布尔)boolean类型适合于逻辑运算,一般用于程序流程控制\nboolean 类型数据只允许取值 true 或 false \n注意:不可以0或非 0 的整数替代false和true\n用法举例：逻辑控制语句        boolean flag;        flag = true;        if(flag) &#123;            //do something        &#125;\n\n\n\n字符型charchar 型数据用来表示通常意义上的“字符”,char占2字节,字符用单引号括起来的单个字符，例如：char  c1 = ‘a’;char c2 =’中’;可以涵盖世界上所有书面语的字符。\nchar运算\n\nchar类型在字符编码表中有对应的数值。\nchar c=‘a’+1;　　先将’a’提升为int，计算结果98,对应的字符是b。\n\ncharl类型数据可以参与算术运算\n使用字符对应的码换算成ASCII对应的数字进行运算.\nASCII 码计算机底层，所有数据都使用二进制表示,每一个二进制位（bit）有 0 和 1 两种状态,因此 8 个二进制位就可以组合出 256 种状态.被称为一个字节（byte）.\n ASCII(ASCII American Standard Code for Information Interchange，美国信息互换标准代码)上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。\n只能表示英文\n\n缺点：不能表示所有字符\n\nUnicode 编码一种编码，包含世界各个国家的文字字符，使用 Unicode 没有乱码的问题\nJava采用unicode编码规范,其中完全包含ASCII编码\n==UTF-8是针对Unicode的一种可变长度字符编码,在utf-8编码表中,一个中文占3个字节,一个英文占1个字节==.\n基本数据类型转换可以从任意基本类型转型到另外的基本类型: boolean 类型不可以转换为其他的数据类型。\n\n默认转换:\n整形，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则：\n容量小的类型默认转换为容量大的数据类型；数据类型按容量大小排序为：==byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double==\nbyte short char不会相互准换,但是可以通过int强制转化\n\n强制转换:要加上强制转换符要加上强制转换符，但可能造成精度降低或溢出；\nint a=10;double b=a;  float c=10.2F;double d=c;  int v=128;byte f=(byte) v;\n\n\n\n\n\n有多种类型的数据混合运算时，系统首先自动的将所有数据转换成==容量最大的那一种数据类型==，然后再进行计算\n\n\n\n序号\n数据类型\n占用存储空间\n封装类\n默认类型(零值)\n可表示数据范围\n\n\n\n1\nbyte(字节)\n1字节\nByte\n(byte)0\n-128~127\n\n\n2\nshort(短整数)\n2字节\nshort\n(short)0\n-32768~32767\n\n\n3\nint(整数)\n4字节\ninteger\n0\n-2^31 ～ 2^31-1\n\n\n4\nlong(长整数)\n8字节\nLong\n0L\n-2^63 ～ 2^63-1\n\n\n5\nfloat(单精度)\n4字节\nFloat\n0.0F\n-3.403E38～3.403E38\n\n\n6\ndouble(双精度)\n8字节\nDouble\n0.0D\n-1.798E308～1.798E308\n\n\n7\nchar\n2字节\nCharacter\n‘\\u0000’（对应数字0，输出为空)\n0~65535\n\n\n8\nboolean(字符)\n单个boolean型是占4字节–boolean数组中的则占1字节\nBoolean\nflase\ntrue或false\n\n\n一个字节:8-bit\n","categories":["-javase"],"tags":["基础","java"]},{"title":"javaSE-02-基础语法","url":"http://example.com/2020/10/10/javaSE02/","content":"java基础语法IDE的使用\nIDE(Integrated Development Environment )集成开发环境\n包含编辑器,编译器,调试图形界面\n\nIntelliJ IDEA  捷克的一家公司    收费的\nEclipse  IBM公司开发的  现在捐献给eclipse基金会\n\n注释对程序功能的说明,以某种特定符号作为标记,程序在运行过程中不会执行注释.\n\n\nJava语言有三种注释方式：\n//  用于单行注释,   快捷键ctrl+/    \n/*  用于多行注释,快捷键ctrl+shift+/   ctrl+shift+\\ 取消注释*/\n/**\n文档注释，用于为类,方法(函数),属性 功能进行说明,可在调用时提示*/\n\n\n\n关键字关键字的定义和特点定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）特点：关键字中所有字母都为小写\n\n\n\n用于定义数据类型的关键字\n\n\n\n\n\n\n\nclass\ninterface\nenum\nbyte\nshort\n\n\nint\nlong\nfloat\ndouble\nchar\n\n\nboolean\nvoid\n\n\n\n\n\n用于定义数据类型值的关键字\n\n\n\n\n\n\ntrue\nfalse\nnull\n\n\n\n\n用于定义流程控制的关键字\n\n\n\n\n\n\nif\nelse\nswitch\ncase\ndefault\n\n\nwhile\ndo\nfor\nbreak\ncontinue\n\n\nreturn\n\n\n\n\n\n\n\n\n\n用于定义访问权限修饰符的关键字\n\n\n\n\n\n\n\nprivate\nprotected\npublic\n\n\n\n\n用于定义类，函数，变量修饰符的关键字\n\n\n\n\n\n\nabstract\nfinal\nstatic\nsynchronized\n\n\n\n用于定义类与类之间关系的关键字\n\n\n\n\n\n\nextends\nimplements\n\n\n\n\n\n用于定义建立实例及引用实例，判断实例的关键字\n\n\n\n\n\n\nnew\nthis\nsuper\ninstanceof\n\n\n\n用于异常处理的关键字\n\n\n\n\n\n\ntry\ncatch\nfinally\nthrow\nthrows\n\n\n用于包的关键字\n\n\n\n\n\n\npackage\nimport\n\n\n\n\n\n其他修饰符关键字\n\n\n\n\n\n\nnative\nstrictfp\ntransient\nvolatile\nassert\n\n\n保留字在java语言中未被使用的关键字,预留的,命名时不能使用\n goto 、const\n标识符标识符：Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符.\n通俗讲:自己可以命名的名称\n合法标识符规则\n由26个英文字母大小写，0-9 ，_或 $ 组成  \n数字不可以开头。\n不可以使用关键字和保留字，但能包含关键字和保留字。tint\nJava中严格区分大小写，长度无限制。 A  a \n标识符不能包含空格\n\n//约定俗成   见名知意  驼峰   类名首字母大小  user_nameint age  = 10;String userName = &quot;jim&quot;;\n\nJava中的名称命名规范\n包名：多单词组成时所有字母都小写：xxxyyyzzz\n类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz\n变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz\n常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ\n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"javaSE-01-概述与第一个程序","url":"http://example.com/2020/10/09/javaSE01/","content":"java概述与第一个程序为什么是java\n市场需求高\njava语言用途广:服务器程序,Android应用,软件工具,嵌入式领域,大数据技术\n\nJava语言发展史\n1991年SUN公司詹姆斯•高斯林提出要求:语言生成代码紧凑,在不同的平台上运行**(跨平台)**\n1995年正式确立,2004年9月Java1.5发布,2009年SUN公司被Oracle公司(甲骨文)收购\n\n\n\nJava语言的特点\n开源\n\n简单,高效\n\n面向对象\n\n平台无关性\n\n交互式特性\n\n多线程机制\n\n动态的内存管理机制\n\n安全性\n\n跨平台性(图解)\nJVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的,因为有了不同的JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性,也称为Java具有良好的可移植性, 但是前提是要具有不同的jvm.\n\n\n\nJava语言的运行机制java开发者编写 .java文件(源代码)\n通过编译工具 将.java文件  编译为.class文件\n通过不同平台的JVM运行.class文件为操作系统\nJava语言体系结构\nJavaSE:java Standard Edition (Java标准版)\nJavaEE:java Enterprise Edition( Java企业版)\nJavaME:java Micro Edition (Java微缩版)\n\n核心机制之Java虚拟机\nJava虚拟机可以理解成一个翻译器。 2  10对于不同的运行平台，有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。int a =10\n\nJDK,JRE,jvm,三者之间的关系\n第一个JAVA程序开发过程\n //定义一个类，名称为Hello   public class Hello &#123;       //定义主方法                                                                   public static void main(String[] args) &#123;                                                                    \tSystem.out.println(“Hello World！”); \t//程序代码部分 \t               &#125;                                &#125;      \n\n","categories":["-javase"],"tags":["基础","java"]},{"title":"LC015-1007-三数之和","url":"http://example.com/2020/10/08/LC015-1007-三数之和/","content":"15. 三数之和难度中等2657\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n  \n\n示例：\n给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]\n\n排序 + 双指针思路:\n1特判，对于数组长度nums.length，如果数组为 0 或者数组长度小于 3，返回 [][]。2.对数组进行排序。 Arrays.sort(nums);3.遍历排序后数组：\n\n若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。对于重复元素：跳过，避免出现重复解\n\ntarget= -nums[i];令头指针 j=i+1，尾指针 k = nums.length -1;当 j&lt;k时，执行循环：\n\n当 nums[j] + nums[k] == target，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,RL,R 移到下一位置，寻找新的解若大于要判断的数 尾部向左边移动，RR 左移若小于于要判断的数 尾部向右边移动，LL 右移\n\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List &lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    if(nums.length ==0 &amp;&amp;nums.length&lt;3)&#123;        return  result;    &#125;    Arrays.sort(nums);    for(int i =0; i&lt;nums.length; i++)&#123;        if( i&gt;0 &amp;&amp; nums[i]==nums[i-1]) //对于重复元素：跳过，避免出现重复解        continue;        int  target= -nums[i];        int j = i+1 ;  //头指针        int k = nums.length -1;  //尾指针        while(j&lt;k)&#123;            if(nums[j] + nums[k] == target)&#123;                List&lt;Integer&gt; curr =new ArrayList&lt;&gt;();                curr.add(nums[i]);                curr.add(nums[j]);                curr.add(nums[k]);                result.add(curr);                j++;k--;                while(j&lt;nums.length&amp;&amp; nums[j]==nums[j-1]) j++;//判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,RL,R 移到下一位置，寻找新的解                while(k&gt;j &amp;&amp; nums[k]==nums[k+1]) k--;            &#125;else if(nums[j] + nums[k] &gt;target)&#123;  //大于要判断的数  尾部向左边移动                k--;            &#125;else&#123;                j++;  //小于于要判断的数  尾部向右边移动            &#125;        &#125;    &#125;    return result;    &#125;&#125;\n\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"CSS-06-浮动,相对,绝对定位","url":"http://example.com/2020/10/07/CSS-06-浮动-相对-绝对定位/","content":"css-06-浮动浮动所谓浮动指的是使标签脱离原来的文档流，在父标签中浮动起来。浮动使用float属性。可选值：        none ：不浮动         left ：向左浮动         right ：向右浮动块级标签和行级标签都可以浮动，当一个行级标签浮动以后将会自动变为一 个块级标签。当一个块级标签浮动以后，宽度会默认是内容的宽度，所以当漂浮一个块级标签时我们   都会为其指定一个宽度。\n  \n\n\n当一个标签浮动以后，其下方的标签会上移。标签中的内容将会围绕 在标签的周围。 \n浮动会使标签完全脱离文档流，也就是不再在文档中在占用位置标签浮动以后即完全脱离文档流，这时不会再影响父标签的高度。也就是浮动标签不会撑开父标签。 \n清除浮动clear属性可以用于清除标签周围的浮动对标签的影响,其他标签的位置不发生变化。           可选值：left ：   忽略左侧浮动 \n&lt;div style=&quot;clear: left;&quot;&gt;&lt;/div&gt;\n\nright ：忽略右侧浮动both ：忽略全部浮动\n相对定位(relative)相对定位相对定位是一个非常容易掌握的概念. 相对于它的起点进行移动，移动后原来的位置还被占用。可以通过position:relative; 开启相对定位， left right top bottom四个属性来设置标签的偏移量。\n\n相对定位的特点当标签的position属性设置为relative时，则开启了标签的相对定位\n1.当开启了标签的相对定位以后，而不设置偏移量时，标签不会发生任何变化2.相对定位是相对于标签在文档流中原来的位置进行定位    left top  right bootom设置偏移量 相对定位是以其原来的位置为参照物移动3.相对定位的标签不会脱离文档流4.相对定位会使标签提升一个层级5.相对定位不会改变标签的性质，\n绝对定位(absolute)绝对定位 绝对定位是不占空间的，运用了绝对定位的标签会脱离原来的文档流，浮动起来，因此视觉上会其他的标签重叠.可以通过position: absolute; 开启绝对定位，left right top bottom四个属性来设置标签的偏移量.\n\n绝对定位的特点1.开启绝对定位，会使标签脱离文档流2.开启绝对定位以后，如果不设置偏移量，则标签的位置不会发生变化3.绝对定位是相对于离他最近的开启了定位的祖先标签进行定位（一般情况，开启了子标签的绝对定位都会同时开启父标签的相对定位） 如果所有的祖先标签都没有开启定位，则会相对于浏览器窗口进行定位 4.绝对定位会使标签提升一个层级 5.绝对定位会改变标签的性质，行级标签变成块标签\nz-index 设置标签的堆叠顺序 。 如果定位标签的层级是一样，则下边的标签会盖住上边的通过z-index属性可以用来设置标签的层级可以为z-index指定一个正整数作为值，该值将会作为当前标签的层级 层级越高，越优先显示 对于没有开启定位的标签不能使用z-index\nz-index: 10; /设置定位标签的层级  z轴/\n#div2&#123;\t\t\twidth: 300px;\t\t\theight: 300px;\t\t\tbackground-color: red;\t\t\tposition: absolute;\t\t\tz-index: 10; /*设置定位标签的层级  z轴*/\t\t&#125;\t\t\t\t#div3&#123;\t\t\twidth: 200px;\t\t\theight: 200px;\t\t\tbackground-color: yellow;\t\t\tposition: absolute;\t\t\tz-index: 2;\t\t&#125;\n\n\n\n\n\n练习&lt;1&gt;​            顶部导航栏​             浮动带来的问题: 高度塌陷   浮动元素没有将父级标签撑开​             解决方案:\n​                      1.设置高度撑开父标签​                      2.清除浮动影响  会自动将父标签撑开为 浮动标签的高度\n\n/* 顶部导航栏 */\n#nav_box&gt;.nav&#123;\t\t\t\tfloat: left;\t\t\t\twidth: 100px;\t\t\t\tbackground-color: red;\t\t\t\theight: 40px;\t\t\t\ttext-align: center; /* 文本水平居中*/\t\t\t\tcolor: white;\t\t\t\tfont-size: 14px;\t\t\t\tfont-weight: bold;\t\t\t\tline-height: 40px;  /* 文本距离顶部高度*/\t\t\t&#125;\n\n\n\n#nav_box&gt;.nav:hover&#123;\t\t\t\tbackground-color: #D3051A;\t\t\t&#125;\t\t\t\t\t\t#nav_box&#123;\t\t\t\tmargin:auto;\t\t\t\twidth:600px;\t\t\t&#125;\t\t\t\t\t\t#middle_box&#123;\t\t\t\twidth: 600px;\t\t\t\tbackground-color: #00FFFF;\t\t\t\tmargin:10px auto;\t\t\t&#125;\t\t\t\t\t\t.middle_box_left,.middle_box_center,.middle_box_right&#123;\t\t\t\twidth: 200px;\t\t\t\theight: 200px;\t\t\t\tfloat: left;\t\t\t&#125;\t\t\t\t\t\t.middle_box_left&#123;\t\t\t\tbackground-color: red;\t\t\t&#125;\t\t\t.middle_box_center&#123;\t\t\t\tbackground-color: green;\t\t\t&#125;\t\t\t.middle_box_right&#123;\t\t\t\tbackground-color: blue;\t\t\t&#125;\t\t\t.middle_box_bottom&#123;\t\t\t\tbackground-color: chartreuse;\t\t\t\theight: 100px;\t\t\t&#125;\n\n\n\n&lt;div id=&quot;nav_box&quot;&gt;\t\t\t&lt;div class=&quot;nav&quot;&gt;首页&lt;/div&gt;\t\t\t&lt;div class=&quot;nav&quot;&gt;公司信息&lt;/div&gt;\t\t\t&lt;div class=&quot;nav&quot;&gt;产品介绍&lt;/div&gt;\t\t\t&lt;div class=&quot;nav&quot;&gt;客户信息&lt;/div&gt;\t\t\t&lt;div class=&quot;nav&quot;&gt;联系我们&lt;/div&gt;\t\t\t&lt;div class=&quot;nav&quot;&gt;关于我们&lt;/div&gt;\t\t\t&lt;div style=&quot;clear: left;&quot;&gt;&lt;/div&gt;\t\t&lt;/div&gt;\t\t\t\t&lt;!-- \t\t 中间区域\t\t --&gt;\t\t &lt;div id=&quot;middle_box&quot;&gt;\t\t\t &lt;div class=&quot;middle_box_left&quot;&gt;左&lt;/div&gt;\t\t\t &lt;div class=&quot;middle_box_center&quot;&gt;中&lt;/div&gt;\t\t\t &lt;div class=&quot;middle_box_right&quot;&gt;右&lt;/div&gt;\t\t\t &lt;div style=&quot;clear: left;&quot;&gt;&lt;/div&gt;\t\t\t &lt;div class=&quot;middle_box_bottom&quot;&gt;底部&lt;/div&gt;\t\t &lt;/div&gt;\t \n\n\n\n图片切换\nposition: relative;/**绝对定位是相对于离他最近的开启了定位的祖先标签进行定位（一般情况，开启了子标签的绝对定位都会同时开启父标签的相对定位）*/**\n&lt;style type=&quot;text/css&quot;&gt;\t\t\timg&#123;\t\t\t\tdisplay: block;\t\t\t&#125;\t\t\t\t\t\t#img_box&#123;\t\t\t\twidth: 520px;\t\t\t\tmargin: 200px auto;\t\t\t\tposition: relative;/**绝对定位是相对于离他最近的开启了定位的祖先标签进行定位**（一般情况，开启了子标签的绝对定位都会同时开启父标签的相对定位）*/\t\t\t&#125;\t\t\t\t\t\t.left_btn,.right_btn&#123;\t\t\t\twidth: 30px;\t\t\t\theight: 30px;\t\t\t\tbackground-color: grey;\t\t\t\tcolor: white;\t\t\t\ttext-align: center;\t\t\t\tline-height: 30px;\t\t\t\tfont-size: 20px;\t\t\t\topacity: 0.5;\t\t\t\tborder-radius: 15px;\t\t\t\tposition: absolute;\t\t\t\ttop: 140px;\t\t\t&#125;\t\t\t.right_btn&#123;\t\t\t\tright: 0px;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;img_box&quot;&gt;\t\t\t&lt;img  src=&quot;img/4.jpg&quot;/&gt;\t\t\t&lt;div class=&quot;left_btn&quot;&gt; &amp;lt; &lt;/div&gt;\t\t\t&lt;div class=&quot;right_btn&quot;&gt; &amp;gt; &lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;\n\n","categories":["-前端"],"tags":["CSS"]},{"title":"无重复字符的最长子串-0003","url":"http://example.com/2020/10/06/LC03-1006- 无重复字符的最长子串/","content":"无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:\n输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n\n示例 2:\n \n\n输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n\n\n示例 3:\n输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串\n\n\n\n思路:\n\n设置两个指针,左边指针start和尾指针end \n\n右指针不断向前,直到字符串尾部\n\n当遇到重复值,说明左指针需要跳转,跳转的位置是重复值的下表+1\n比如字符串abcdecf，到遇到第二个c，即便从bcde任意一个开始，长度都无法超过a，只有从decf开始计算才是新一轮查找\n\n值得注意的是，如果碰到了重复值的下标比左指针还小的情况，不应该跳转，因为左指针左边的元素不再窗口内，比如abba\n\n\nclass Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        if(  s==null||s.length()==0  )//异常排查        &#123;            return 0;        &#125;        int start=0;        int end=0;        int len=s.length();        int ans=0;        HashMap&lt;Character,Integer&gt; map= new HashMap&lt;&gt;();        //指针不断向前,一直到尾部        while(end&lt;len)&#123;            ans=Math.max(ans,end-start);            //比如字符串abcdecf，到遇到第二个c，即便从bcde任意一个开始，长度都无法超过a，只有从decf开始计算才是新一轮查找            if(map.containsKey(s.charAt(end)) &amp;&amp;map.get(s.charAt(end))&gt;=start)            &#123;                start=map.get(s.charAt(end))+1;            &#125;            map.put(s.charAt(end),end);// 无论重不重复都需要更新，该元素最近的下标            end++;        &#125;        ans = Math.max(ans,end-start);        return ans;    &#125;&#125;\n\n时间复杂度：O(n);\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"CSS-05-盒子模型","url":"http://example.com/2020/10/06/CSS-05-盒子模型/","content":"盒子 模型(box-model)CSS处理网页时，它认为每个标签都包含在一 个不可见的盒子里。 如果把所有的标签都想象成盒子，那么我们对网页的布局就相 当于是摆放盒子。我们只需要将相应的盒子摆放到网页中相应的 位置即可完成网页的布局。 \n一个盒子(标签)我们会分成几个部分： \n\n–内容区(content) \n–内边距(padding) \n–边框(border) \n–外边距(margin)\n\n  \n\n\n模型-内容区\n内容区指的是盒子中放置内容的区域，也就是标签 中的文本内容，子标签都是存在于内容区中的。\n如果没有为标签设置内边距和边框，则内容区大小 默认和盒子大小是一致的\n通过width和height两个属性可以设置内容区的大小而不是整个盒子的大小。 \nwidth和height属性只适用于块标签(包含行级块)。\n\n模型- 内边距顾名思义，内边距指的就是标签内容区与边框以内的空间。 \n内边距会影响整个盒子的大小。使用padding属性来设置标签的内边距。例如：     padding-left:10px;\n​    padding-right:10px;\n​     padding:10px 20px 30px 40px​     这样会设置标签的上、右、下、左四个方向的内边距。\n模型-边框可以在标签周围创建边框，边框是标签可见框的最外部。可以使用border属性来设置盒子的边框：     border:1px red solid;    上边的样式分别指定了边框的宽度、颜色和样式。        也可以使用border-top/left/right/bottom分别指定上右下左 四个方向的边框。边框可以设置样式：dotted （点线） dashed （虚线）      solid （实线） double （双线）      groove （槽线） \nborder-radius设置四个角为圆角边框border-top-left-radius设置左上为圆角边框\n模型- 外边距外边距是标签边框与周围标签相距的空间。 使用margin属性可以设置外边距。用法和padding类似，同样也提供了四个方向的 。   margin-top/right/bottom/left。   margin的值可以为负值。   margin的值还可以auto，设置外边距为最大值，当将左右外边距设置为auto时，浏览器会将左右外边距设置为相等.垂直设置为auto时值为0，所以水平居中也可以简写为margin:0 auto。外边距不会影响盒子的整体大小，但是会影响盒子的位置，会影响盒子的实际控制范围。\n清除浏览器的默认样式浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多的标签都设置了一些默认的margin和padding，而它的这些默认样式，正常情况下我们是不需要使用的。\n 所以我们往往在编写样式之前需要将浏览器中的默认的margin和padding统统的去掉。\n*&#123;margin: 0;padding: 0;&#125;\n\n\n\n\n\n练习 width 和 height 只是设置内容的大小  不是标签整体大小 如果标签的内边距,边框都没有,那么内容区的大小就是标签的大小width 和 height只适用于块级和行级块标签\nwidth: 170px;height: 170px;background-color: #00FFFF;\n\n\n\n 内边距:                  就是内容区到边框之间的距离                  会影响标签的大小                  padding-left/right/bottom/top\n/* padding-top: 5px;padding-left: 5px;padding-bottom: 5px;padding-right: 5px; */padding: 10px; /*设置 上下左右内边距 *//* padding: 10px 5px;  上下内边距   左右内边距*//* padding: 5px 10px 15px 20px; 上 右 下  左 *//* 标签实际大小 =  内容区 + 内边距 + 边框*//* 边框:就是标签的最外层的框  也是计算在标签大小内的*//* border-bottom-color: red;border-bottom-width: 1px;border-bottom-style: solid; *//* border-bottom: 5px red solid; */border: 5px red solid;border-radius: 10px;/*设置圆角边框*/\n\n\n\n\n&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t\t.div1&#123;\t\t\t\twidth: 150px;\t\t\t\theight: 50px;\t\t\t\tbackground-color: #008000;\t\t\t\tpadding: 75px 25px;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;!-- \t\t   需要最终200*200大小的标签\t\t   有一张150*50图片\t\t   让图片在标签中水平垂直居中\t\t --&gt;\t\t &lt;div class=&quot;div1&quot;&gt;\t\t\t &lt;img src=&quot;img/3.jpg&quot;  style=&quot;display: block;&quot;/&gt;\t\t &lt;/div&gt;\t&lt;/body&gt;\n\n\n\n\t&lt;style type=&quot;text/css&quot;&gt;\t\t/* 去掉标签的一些默认样式  内边距 外边距 */\t\t *&#123;\t\t\t margin: 0px;\t\t\t padding: 0px;\t\t &#125;\t\t\t\t\t\t.div1&#123;\t\t\twidth: 200px;\t\t\theight: 200px;\t\t\tbackground-color: #008000;\t\t\tmargin-bottom: 50px;\t\t&#125;\t\t.div2&#123;\t\t\twidth: 200px;\t\t\theight: 200px;\t\t\tbackground-color: red;\t\t\t/* margin-top: 10px;  上下的外边距需要给具体的值*/\t\t\t\t\t\t/*margin-left: auto;\t\t\tmargin-right: auto; 左右外边距设置为auto时 外边距最大化*/\t\t\t\t\t\tmargin: 10px auto;\t\t\t\t\t\t/* \t\t\t  外边距就是标签与另一个标签之间的距离\t\t\t  不会影响标签的大小\t\t\t  但会影响标签的位置,影响标签的控制范围\t\t\t */\t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t \t&lt;div class=&quot;div1&quot;&gt;\t&lt;/div&gt;\t&lt;div class=&quot;div2&quot;&gt;\t &lt;/div&gt;\t \t &lt;p&gt;ssss&lt;/p&gt;&lt;/body&gt;\n\n","categories":["-前端"],"tags":["CSS"]},{"title":"两数之和-0001","url":"http://example.com/2020/10/05/LC-1005-TwoSum/","content":"两数之和-0001给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]\n \n\n方法一:暴力枚举\n选择两个数,又两个循环,第一个for循环确定一个数nums[i],里面在嵌套一个for循环选出一个数num[j],第二个数只需要在第一个确定数的后面进行选择.就不会选择从重复的数.\nclass Solution &#123;  public int[] twoSum(int[] nums, int target) &#123;    for( int i=0; i&lt;nums.length ; i++)    &#123;      for(int j =i+1;j&lt;nums.length;i++)          if(target==nums[i]+nums[j])          &#123;            return new int[] &#123;i ,j&#125;;          &#125;    &#125;   \treturn null;  &#125;&#125;\n\n复杂度分析:\n\n时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n空间复杂度：O(1)。\n\n方法二:\n方法一的时间复杂度较高的原因是寻找数的时间复杂度过高。使用哈希表，可以将寻找 的时间复杂度降低到从 O(N)降低到 O(1).hashmap的key值不能重复\nclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        for(int i=0;i&lt;nums.length;i++)          &#123;            int num=target-nums[i];            if(map.containsKey(num))&#123;                return new int[] &#123;map.get(num),i&#125;;                &#125;                map.put(nums[i], i);        &#125;        return null;    &#125;&#125;\n\n复杂度分析\n\n时间复杂度：O(N)其中 NN 是数组中的元素数量。\n\n\n空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。\n\n","categories":["-算法"],"tags":["LeetCode"]},{"title":"CSS-04-伪类,透明,块级,行级,行级块标签","url":"http://example.com/2020/10/05/CSS-04/","content":"CSS–伪类,透明,块级,行级,行级块标签CSS伪类专门用来表示标签的一种的特殊的状态，当我们需要为处在这些特殊状态的标签设置样式时，就可以使用伪类 。\n伪类的语法：:link表示普通的链接（没访问过的链接）:visited表示访问过的链接        浏览器是通过历史记录来判断一个链接是否访问过        使用visited伪类只能设置字体的颜色  \n:hover伪类表示鼠标移入的状态:active表示的是被点击的状态\n \n\n注意：\n:visited放在:hover之前 :active 必须被置于 :hover 之后，才是有效的 :hover和:active也可以为其他标签设置**:focus向拥有键盘输入焦点的标签添加样式。**\n定义透明效果的属性是 opacity。opacity 属性设置标签的不透明级别 值为1。规定不透明度：从 0.0 （完全透明）到 1.0（完全不透明）。\n\n\n块级,行级,行级块标签\n什么是块级标签？            \n块级标签：无论内容多少 都会独自占据一行的。\n例如&lt;p&gt;、&lt;h1&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;hr/&gt;等。\n\n什么是行级标签？\n行级标签：只占自身大小的标签，不会占一行。\n例如&lt;font&gt;、&lt;b&gt;、&lt;i&gt;、&lt;a&gt;等。\n\n什么是行级块标签？\n例如 &lt;input/&gt; &lt;img&gt;等\n\n\n注意： \n一般情况下使用块级标签包含行级标签，不使用行级标签包含块标签。 a可以包含任何标签，除去a本身； p标签不可以包含任何的块标签。\n块级标签\t\t     无论内容有多少,都会占据一行\t\t\t 默认宽:与父级标签一致\t\t\t 默认高:0  或者与内容高度一致\t\t\t \t\t\t 还可以通过 width和height设置标签的宽 高\t\t\t 行级标签:\t\t         只占自身大小,不会占一行\t\t\t\t 即使设置宽 高也是无效的.\t\t\t\t a\t\t\t\t  行级块标签\t\t可以设置大小,不会占一行\t\timg &lt;input/&gt; 一般使用块级标签 包含 行级标签\t\ta可以包含任何标签，除去a本身；\t\tp标签不能包含任何块级标签\n\n\n\n通过display样式可以修改标签的类型。可选值：    block ：设置标签为块标签    inline ：设置标签为行级标签    inline-block ：设置标签为行级块标签    none ：隐藏标签（标签将在页面中完全消失） \n&lt;body&gt;\t\t&lt;!-- \t\t display可以改变标签的类型\t\t display: inline; 设置标签为行级标签\t\t --&gt;\t\t&lt;h4 style=&quot;display: inline; width: 500px;&quot;&gt;4级标题标签&lt;/h4&gt;aaaaaaaaaaaaa\t\t&lt;hr/&gt;\t\t\t\t&lt;!-- \t\tdisplay: block; 设置标签为块级标签 \t\t --&gt;\t\t&lt;a href=&quot;&quot; style=&quot;display: block; width: 500px;&quot;&gt;百度&lt;/a&gt;bbbbbbbbbbbbbbbbb\t\t\t\t&lt;hr/&gt;\t\t&lt;!-- \t\t display:inline-block 设置标签为行级块标签\t\t --&gt;\t\t&lt;a href=&quot;&quot; style=&quot;display:inline-block; width: 500px;&quot;&gt;百度&lt;/a&gt;bbbbbbbbbbbbbbbbb\t\t\t\t&lt;hr/&gt;\t\t&lt;!-- display: none; 让标签在网页上消失  不占用网页空间 --&gt;\t\t&lt;img src=&quot;img/bg.jpg&quot; style=&quot;display: none;&quot; &gt;CCCCCCCCCCCCCC\t&lt;/body&gt;\n\n\n\n\n\ndiv和spandiv标签  div是块级标签，可以放置任何标签。  div没有任何附加功能，给了什么属性就能变成什么样。  div主要的作用是被用来布局网页。\nspan标签   span是行级标签   span 没有任何附加功能，给了什么属性就能变成什么样。   span标签被用来选中文档中的文字。\n&lt;body&gt;\t\t&lt;!-- \t\t   因为h1 p ....这些标签都有默认的样式,在网页布局时使用比较麻烦\t\t   \t\t   div是一个纯净版的块级标签.(没有任何附加样式)\t\t   可以包含任何标签,\t\t   主要用来网页布局\t\t --&gt;\t\t &lt;div style=&quot;width: 500px; height: 300px; background-color: #008000;&quot;&gt;\t\t\t div是一个纯净版的块级标签\t\t &lt;/div&gt;\t\t aaaaaa\t\t \t\t &lt;hr/&gt;\t\t \t\t &lt;!-- \t\t     span是行级标签\t\t\t span是一个纯净版的行级标签\t\t --&gt;\t\t &lt;span style=&quot;color: #FF0000;&quot;&gt;span是一个纯净版的行级标签&lt;/span&gt;\t\t &lt;span&gt;span是一个纯净版的行级标签&lt;/span&gt;\t&lt;/body&gt;\n\n","categories":["-前端"],"tags":["HTML"]},{"title":"CSS-03-文本,背景,表格","url":"http://example.com/2020/10/05/CSS-03/","content":"CSS-文本,背景,表格color：字体颜色font-size：字体大小font-family：字体text-align：文本对齐text-decoration:line-through：定义穿过文本下的一条线text-decoration:underline：定义文本下的一条线text-decoration:none：定义标准的文本font-style: italic;斜体文本font-weight:字体粗细\n  \n\nline-height:设置行高letter-spacing可以指定字符间距text-indent用来设置首行缩进\ncolor: #008000; \t\t\tfont-size: 18px; \t\t\tfont-family: 楷体;\t\t\t/* text-align: right;  水平对齐方式*/\t\t\t/* text-decoration: line-through; 删除线效果 */\t\t\ttext-decoration: underline;\t\t\t/* font-style: italic; */\t\t\tfont-weight: bold;\t\t\t/* letter-spacing: 10px;  字符之间的间距 (适用于中文)*/\t\t\t/*line-height: 50px;行高*/\t\t\ttext-indent:2em;/*段落首行缩进    em ==*/word-spacing: 20px; 单词之间的间隔\n\n\nbackground-color背景颜色background-image: url(img/bg.jpg);背景图片的优先级 高于 背景颜色,背景图片不占标签空间background-repeat: no-repeat; /设置背景重复 repeat-x, repeat-y/ background-size: 800px 600px;background-size: 400px;背景大小\nbackground-position:center;背景位置\n列表:/*list-style-type:none;\t\t\t\tlist-style-image: url(img/img.jpg);  自定义符号图标\t\t\t    list-style-position: inside;控制列表项图标位置*/\t\t\t\t/* 简写方式  值的顺序 无序的 */\t\t\t\tlist-style: outside none url(img/img.jpg) ;\t\t\t\ttext-align: center;\n\n​                \n​        \n表格:width: 300px; height: 200px; border-collapse: collapse;/*边框收缩 使用单一边框*/\n\n\n\n\n\n","categories":["-前端"],"tags":["CSS"]},{"title":"CSS-02-选择器","url":"http://example.com/2020/10/05/CSS-02/","content":"CSS-02选择器要使用CSS对HTML页面中的标签实现一对一，一对多的控制，这就需要用到CSS选择器。\n常用的选择器：\n标签选择器：通过标签选择器可以选择页面中的所有指定标签\n语法：标签名 &#123;&#125;\n\n类选择器：通过标签的class属性值选中一组标签\n语法：.class属性值&#123;&#125; \n2.id 选择器：通过标签的id属性值选中唯一的一个标签语法： #id属性值 {} \n3.选择器组合：通过选择器分组可以同时选中多个选择器对应的标签   语法：选择器1,选择器2,选择器N{}4.通配选择器:可以用来选中页面中的所有的标签语法：*{} \n\n\n\n\n  \n\n注: 选择器的优先级 由高到低 :id–&gt;   类选择器 –&gt;  标签选择类选择器 使用最为广泛的选择器*/\t\t\t.p1&#123;\t\t\t\tcolor: #008000;\t\t\t&#125;\t\t\t\t\t\t/* 选择器组合  用于将公共样式抽取 */\t\t\t.p1,.p2,#p0,h1&#123;\t\t\t\tfont-size: 18px;\t\t\t&#125;\t/*   *匹配网页上所有的标签  通配选择器  */\t\t\t*&#123;\t\t\t\tcolor: orange;\t\t\t\tfont-family: 隶书;/*高优先级选择器 不会 覆盖掉 低优先中特有的样式*/\t\t\t&#125;\n\n常用的选择器：后代选择器：选中指定标签的指定后代标签      语法： 祖先标签   后代标签{}子标签选择器：选中指定父标签的指定子标签    语法： 父标签 &gt; 子标签选中指定标签的相邻标签       语法：选择相邻选择器：器  +  相邻{}兄弟选择器：选中指定标签的兄弟标签       语法：选择器  ~  兄弟{}\n标签之间的关系父标签：直接包含子标签的标签子标签：直接被父标签包含的标签color: #FF0000;后代标签：直接或间接被祖先标签包含的标签，子标签也是后代标签 兄弟标签：拥有相同父标签的标签叫做兄弟标签 \n/*    后代选择器  找 指定祖先下 指定的后代标签  p b&#123;   color: #FF0000;  &#125; */    /*子标签选择器  找指定父级下  指定的儿子级别标签*/  p &gt; b&#123;   color: #FF0000;  &#125;    /* 相邻兄弟选择器  指定相邻标签*/ /* p+b&#123;   color: aqua;  &#125; */    /* 指定的兄弟标签*/  p~b&#123;   color: #FFA500;  &#125;\n\n样式的继承在CSS中，祖先标签上的样式，也会被他的后代标签所继承, 利用继承，可以将一些基本的样式设置给祖先标签，这样所有的后代标签将会自动继承这些样式。\n","categories":["-前端"],"tags":["CSS"]},{"title":"CSS-01-概论","url":"http://example.com/2020/10/05/CSS-01/","content":"css概述\nCSS是Cascading Style Sheets（级联样式表）。\n\n\nCSS是一种样式表语言，用于为HTML文档控制外观，定义布局。例如，CSS涉及字体、颜色、边距、高度、宽度、背景图像、高级定位等方面 。\n\n\n可将页面的内容与表现形式分离，页面内容存放在HTML文档中，而用于定义表现形式的CSS在一个.css文件中或HTML文档的某一部分。\n\nCSS与HTML的关系:HTML是网页的内容,CSS定义页面的样式\n  \n\n基本语法\n行内样式表\n行内样式表,又有人称内联样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下：\n &lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;\n\n\n&lt;p style = &quot;color:red;font-size:30px;font-family:隶书;&quot;&gt; 这个段落应用了样式&lt;p&gt;本段&lt;p&gt;标签采用了行级样式   为标签p指定样式\n\n\n\n\n内嵌式\n将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义\n\n\n&lt;head&gt;&lt;title&gt;样式规则&lt;/title&gt;&lt;style  type=&quot;text/css&quot;&gt; p &#123; color:red; font-family:&quot;隶书&quot;; font-size:24px;&#125;&lt;/style&gt;&lt;/head&gt;\n\n\n\n\n外部样式\n外部样式表是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中.\n使用link（链接）标签 :&lt;head&gt;&lt;link href=&quot;newstyle.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;\n\nrel = relationship   关系；关联\n\n\n\n\n","categories":["-前端"],"tags":["CSS"]},{"title":"HTML -03-概论","url":"http://example.com/2020/09/29/HTML-03/","content":"HTML -03概论内联框架\n内联框架可以在一个窗口内嵌入一个子窗口,从而在子窗口中引入一个外部的页面**                                           \n&lt;iframe  src=# 初始页面的url  name=# 框架名字   width=#  宽度   height=#  高度  frameborder=# 是否存在边&gt; ... &lt;/iframe&gt;\n\n​         target=”_self” 在当前窗口打开新页面​         target=”_blank” 在新窗口打开新面​         target=”aa” 在指定名称的窗口打开新页面\n  \n\n​         target=”_parent” 在父级窗口打开新页面​         target=”_top” 在顶级窗口打开新页面\n\n\n\n相关代码如下:\nindex    \n&lt;body&gt;\tindex\t\t&lt;a href=&quot;baidu.html&quot; target=&quot;&quot;&gt;百度&lt;/a&gt;\t&lt;iframe src=&quot;child1.html&quot; name=&quot;aa&quot; width=&quot;300&quot; height=&quot;200&quot; frameborder=&quot;1&quot;&gt;&lt;/iframe&gt;\t&lt;!-- &lt;iframe src=&quot;child1.html&quot;&gt;&lt;/iframe&gt; --&gt;&lt;/body&gt;\n\nbaidu\n&lt;body&gt;\t百度&lt;/body&gt;\n\nlogin\n&lt;body&gt;\t登录&lt;/body&gt;\n\nchild1\n&lt;body&gt;\tchild1\t&lt;a href=&quot;login.html&quot; target=&quot;_parent&quot;&gt;退出_parent&lt;/a&gt;\t&lt;a href=&quot;login.html&quot; target=&quot;_top&quot;&gt;退出_top&lt;/a&gt;&lt;/body&gt;\n\nchild2\n&lt;body&gt;\tchild1\t&lt;a href=&quot;login.html&quot; target=&quot;_parent&quot;&gt;退出_parent&lt;/a&gt;\t&lt;a href=&quot;login.html&quot; target=&quot;_top&quot;&gt;退出_top&lt;/a&gt;&lt;/body&gt;\n\n\n注意:两链接的写法:\n&lt;a href=&quot;baidu.html&quot; target=&quot;&quot;&gt;百度&lt;/a&gt;&lt;iframe src=&quot;child1.html&quot; name=&quot;aa&quot; width=&quot;300&quot; height=&quot;200&quot; frameborder=&quot;1&quot;&gt;&lt;/iframe&gt;\n\n\n\n\n\n表单-下拉框\n\n    无业   默认选中selected = ” selected ”\n    教师\n    医生\n    工人             \n\n\n\n&lt;select name=&quot;bmon&quot;&gt;    &lt;option  &gt;无业&lt;/option&gt;   默认选中selected = ” selected ”    &lt;option selected = ” selected ”&gt;教师&lt;/option&gt;    &lt;option&gt;医生&lt;/option&gt;    &lt;option&gt;工人&lt;/option&gt; \t\t\t&lt;/select&gt;\n\n注:下拉框的name,id,事件等需要在select中定义，而value需要在option中定义\n多文本域:\n&lt;textarea name=&quot;textarea&quot;    cols=&quot;40&quot;    rows=&quot;6&quot;&gt;  文本域中的内容     &lt;/ textarea &gt; \n\n按钮基本语法\n&lt;input  type=“reset”  value=“ 重填 ”&gt;     重置表单内容&lt;input type=&quot;submit&quot;  value=&quot;提交&quot;&gt;      提交表单内容到服务器&lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;         普通按钮没有功能，只能被点击触发事件用\n\n\ntype=”resert” 重置按钮,让表单还原到原始状态\ntype=”submit’’ 向服务器提交表单,触发action\ntype=”button” 普通按钮,主要用于触发事件.\n\n\n\n\n\n作业总结:[不熟悉的]表的合并\n\ncolspan属性 跨列合并单元格   colspan=”数字”\nrowspan属性 跨行合并单元格 rowspan=”数字”\n\n","categories":["-前端"],"tags":["HTML"]},{"title":"HTML-02-概论","url":"http://example.com/2020/09/28/HTML-02/","content":"HTML -02概论表格:\ntableb标签:表格标签\ntr标签:表格中的行\nth标签:表格的表头\ntd标签:表格单元格\n\n表格的基本概念\n  \n\n&lt;table&gt;定义表格    &lt;tr&gt;定义表行        &lt;th&gt;定义表头&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;    &lt;td&gt;定义单元格&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n表格的属性\n\nborder[表格]  属性: border=”number”\nbackground[背景图像]\nbgcolor[背景颜色]\nwidth height 属性\ncellpadding[填充]\ncellspacing[间距]\nalign[表格对应的位置]  left center right\nvalign[表格内文字对应的位置]  top middle bottom\n\n表的合并\n\ncolspan属性 跨列合并单元格   colspan=”数字”\nrowspan属性 跨行合并单元格 rowspan=”数字”\n\n注:\n表格标签构成\ntable:表格区域  border边框  width  height  bgcolor  background  cellpadding:内容到边框的距离  cellspacing:单元格与单元格之间的距离  align&#x3D;&quot;center&quot;:控制表格在本行中的水平位置tr:定义表格行  height  bgcolor  background  align&#x3D;&quot;center&quot; 让本行所有单元格内容居中  valign 设置内容的垂直位置  top  middle bottomtd:表格的单元格  width  bgcolor  background  align&#x3D;&quot;center&quot;  valign 设置内容的垂直位置  top  middle bottomth:表头,也是单元格,内容加粗居中显示&lt;caption&gt;学生信息表&lt;&#x2F;caption&gt; 表格标题注意:表格中的内容都必须写在单元格中\n\n\n\n\n\nfrom标签:表单网页表单中有许多可以输入或者选择的组件,用户可以在表单中填写信息,最终提交表单,把客户端数据提交至服务器\n&lt;form action=“http://www.sohu.com”  method=“post”&gt;\t……&lt;/form&gt;action: 由服务器上那个处理程序method: 提交方法:一般为post(安全) get 方法    \n\n表单—文本\n&lt;lable for=&quot;userid&quot;&gt;用户名&lt;lable&gt; &lt;input  type=“text ”id=“userid”  name=“username” value=“张三”  size=“20“   readonly=“readonly”placeholder=“请输入” disabled=“disabled”&gt;\n\n注: \n\ntype —-&gt;文本输入框   ;    value=“张三”—-&gt;输入标签的默认值 ;   size=“20”—&gt; 文本区的宽  eadonly=“readonly —&gt; 内容只读     placeholder=“请输入—&gt;提示信息    disabled=“disabled”—&gt;内容置灰不可使用                           \n在html中还专门提供一个标签，专门用来选中表单中的提示文字的lable标签,lable有一个for属性，该属性需要指定一个表单项的id值。\n\n&lt;input type=“password ”  value=“ 123456 ”  size=“22”/&gt;\n\n\ntype=“password ” —&gt; 密码框       value=“ 初始值 ” \ntype=”radio”     —&gt;单选按钮    \n\n\n注意：\n单选框通过name属性来分组，name相同是一组才可实现单选。\n单选和复选不能输入内容，所以必须指定value的值\n\n\ntype=“checkbox” —&gt;  复选框       checked=”checked“  —&gt;默认选中    name=”cb2“  —&gt;复选框名\ntype=“file”    —&gt;文件选择框      name=“img” –&gt;文件选择框名    accept=“.文件后缀名,.文件后缀名… “   —&gt;限制文件类型\n\n **默认选中    checked=”checked“  **  表单-选择\n**默认选中    selected = ” selected ” **  表单-下拉框\n表单-下拉框\n&lt;select name=&quot;bmon&quot;&gt;    &lt;option selected = ” selected ” &gt;无业&lt;/option&gt;   默认选中selected = ” selected ”    &lt;option&gt;教师&lt;/option&gt;    &lt;option&gt;医生&lt;/option&gt;    &lt;option&gt;工人&lt;/option&gt; \t\t\t&lt;/select&gt;\n\n注:下拉框的name,id,事件等需要在select中定义，而value需要在option中定义\n多文本域:\n&lt;textarea name=&quot;textarea&quot;    cols=&quot;40&quot;    rows=&quot;6&quot;&gt;  文本域中的内容     &lt;/ textarea &gt; \n\n按钮基本语法\n&lt;input  type=“reset”  value=“ 重填 ”&gt;     重置表单内容&lt;input type=&quot;submit&quot;  value=&quot;提交&quot;&gt;      提交表单内容到服务器&lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;         普通按钮没有功能，只能被点击触发事件用\n\n内联框架可以在一个窗口内嵌入一个子窗口,从而在子窗口中引入一个外部的页面\n​                            初始页面的url          框架名字                宽度                         高度\n&lt;iframe      src=#          name=#        width=#          height=#  frameborder=#&gt; ... &lt;/iframe&gt;\n\n练习:表格练习一:\n\n&lt;table border=&quot;1&quot; width=&quot;300&quot;\tcellspacing=&quot;0&quot;  cellpadding=&quot;20&quot;\talign=&quot;center&quot;&gt;    &lt;caption&gt;表格练习&lt;/caption&gt;    &lt;tr&gt;        &lt;th colspan=&quot;5&quot;&gt;姓名&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;班级&lt;/th&gt;        &lt;th&gt;学号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;张三&lt;/td&gt;        &lt;td&gt;你猜&lt;/td&gt;        &lt;td&gt;你猜&lt;/td&gt;        &lt;td&gt;你猜&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;&lt;/tr&gt;&lt;/table&gt;\n\n\n\n\n\n表格练习-财务一\n\n&lt;table align&#x3D;&quot;center&quot; border&#x3D;&quot;1&quot; cellspacing&#x3D;&quot;0&quot; width&#x3D;&quot;600&quot;&gt;\t\t\t&lt;caption&gt;财务报表&lt;&#x2F;caption&gt;\t\t\t&lt;tr style&#x3D;&quot;color: aquamarine; background-color: azure;&quot;&gt;\t\t\t\t&lt;th colspan&#x3D;&quot;4&quot;&gt;品 牌&lt;&#x2F;th&gt;\t\t\t\t&lt;th colspan&#x3D;&quot;6&quot;&gt;童 装&lt;&#x2F;th&gt;\t\t\t\t&lt;th colspan&#x3D;&quot;6&quot;&gt;春 装&lt;&#x2F;th&gt;\t\t\t\t\t\t\t&lt;&#x2F;tr&gt;\t\t\t&lt;tr&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;4&quot; align&#x3D;&quot;center&quot; style&#x3D;&quot;color: aquamarine; background-color: azure;&quot;&gt;&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;男装&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;女装&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;童装&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;男装&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;女装&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;童装&lt;&#x2F;td&gt;\t\t\t&lt;&#x2F;tr&gt;\t\t\t\t\t\t\t\t\t\t\t&lt;tr&gt;\t\t\t\t&lt;td rowspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot; style&#x3D;&quot;color: aquamarine; background-color: azure;&quot;&gt;JC&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;3&quot; align&#x3D;&quot;center&quot; style&#x3D;&quot;color: aquamarine; background-color: azure;&quot;&gt;牛仔系列&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;116&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;98&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;68&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;88&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;86&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;46&lt;&#x2F;td&gt;\t\t\t&lt;&#x2F;tr&gt;\t\t\t&lt;tr&gt;\t\t\t\t\t\t\t\t&lt;td colspan&#x3D;&quot;3&quot; align&#x3D;&quot;center&quot; style&#x3D;&quot;color: aquamarine; background-color: azure;&quot;&gt;牛仔系列&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;120&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;100&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;80&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;98&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;88&lt;&#x2F;td&gt;\t\t\t\t&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;50&lt;&#x2F;td&gt;\t\t\t&lt;&#x2F;tr&gt;\t\t&lt;&#x2F;table&gt;\n\n\n\n\n\n表格练习-财务报表二\n\n&lt;table  align=&quot;center&quot; border=&quot;1&quot; width=&quot;500&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10&quot; &gt;\t\t&lt;caption&gt;财务报表&lt;/caption&gt;\t\t&lt;tr height=&quot;35&quot;&gt;\t\t\t&lt;th&gt; 季度&lt;/th&gt;\t\t\t&lt;th colspan=&quot;2&quot;&gt;收入(元)&lt;/th&gt;\t\t\t&lt;th colspan=&quot;2&quot;&gt;支出(元)&lt;/th&gt;\t\t&lt;/tr height=&quot;35&quot;&gt;\t\t&lt;tr height=&quot;35&quot; valign=&quot;center&quot; align=&quot;center&quot; &gt;\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t&lt;td&gt;建筑&lt;/td&gt;\t\t\t&lt;td&gt;房地产&lt;/td&gt;\t\t\t&lt;td&gt;销售服务&lt;/td&gt;\t\t\t&lt;td&gt;办公&lt;/td&gt;\t\t\t\t\t&lt;/tr&gt;\t\t&lt;tr height=&quot;35&quot;  align=&quot;center&quot; &gt;\t\t\t&lt;td&gt;第一季度&lt;/td&gt;\t\t\t&lt;td&gt;306000&lt;/td&gt;\t\t\t&lt;td&gt;234234&lt;/td&gt;\t\t\t&lt;td&gt;234234&lt;/td&gt;\t\t\t&lt;td&gt;234234&lt;/td&gt;\t\t\t\t\t&lt;/tr&gt;\t\t&lt;tr height=&quot;35&quot;  align=&quot;center&quot; &gt;\t\t\t&lt;td&gt;第二季度&lt;/td&gt;\t\t\t&lt;td&gt;234234&lt;/td&gt;\t\t\t&lt;td&gt;23423234&lt;/td&gt;\t\t\t&lt;td&gt;234234&lt;/td&gt;\t\t\t&lt;td&gt;2342342&lt;/td&gt;\t\t\t\t\t&lt;/tr&gt;\t&lt;/table&gt;\n\n\n\n","categories":["-前端"],"tags":["HTML"]},{"title":"HTML-01-概述","url":"http://example.com/2020/09/26/HTML-01/","content":"HTML概述HTML指的是超文本标记语言\n\n超文本：指的是页面内可以包含图片，连接，声音，视频等内容\n标记：标签（告诉网页该显示什么内容） 如下所示\n\n&lt;meta name=“keywords” content=“手机,家电&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;&lt;meta name=&quot;author&quot; content=“jim&quot;&gt;\n\n  \n\n标题处添加图标\n&lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;ico地址&quot;&gt;\n\n\n\n\nrel:声明是什么类型    herf：地址\n\n 注释后的内容不会显示在网页上\nhtml5的文档声明 \n   \n   如果不声明解析网页时会产生一些不可预期的行为，所以我们应该避免出现。   &lt;/!doctype&gt;\nHTML基本语法标签：\n\nHTML中的标记指的就是标签，HTML使用标记标签来描述页面\n\n结构\n\n&lt;标签名&gt;标签内容&lt;/标签名&gt;   闭合标签(有标签内容)\n&lt;标签名/&gt;   自闭合标签 (无标签内容)\n\n标签属性：标签可以拥有属性。属性进一步说明了该标签的显示或使用\n特性。如： \n\n属性的格式 ：属性名 = “属性值“ \n\n属性的位置：    &lt;标签名  属性名 = “属性值“ &gt;xxx&lt;/标签名&gt;\n\n\n添加多个属性： &lt;标签名  属性名 = “属性值“  属性名 = “属性值“ &gt;xxx &lt;/标签名&gt;\n\n\n\n\n\n\n基本常用标签\n标题标签\n&lt;h1&gt;&lt;&#x2F;h1&gt;…..&lt;h6&gt;&lt;&#x2F;h6&gt;\n\n\n\n\n\n\n段落标签\n&lt;p&gt;&lt;&#x2F;p&gt; \n\n\n\n\n\n\n换行标签\n&lt;br&#x2F;&gt;\n\n\n\n\n\n\n列表   \n有序列&lt;ol&gt;&lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt;    无序列表&lt;ul&gt;&lt;li&gt;&lt;&#x2F;li&gt;&lt;ul&gt;  \n\n\n\n\n\n\n超链接\n&lt;a&gt;&lt;&#x2F;a&gt;\n\n\n\n\n\n\n图像标签\n&lt;img&#x2F;&gt;\n\n\n\n\n\n标题标签\nH1 到 H6 标签用于指定不同级别的标题，&lt;H#&gt; … &lt;/H#&gt;#=1, 2, 3, 4, 5, 6 ，说明：到字体大小依次递减\n\np标签定义段落\np 标签中的文字默认会独占一行，并且段与段之间会有一个间距。\n\n\n\nbr标签呈现换行效果\n可插入一个简单的换行符。\n标签是自闭合标签。\n\n超链接\na标签:HTML 使用超级链接与网络上的另一个文档相连，通俗的说就是通过连接来访问其他网页资源。\n\n&lt;a href=&quot;标签练习.html&quot; target=&quot;_blank&quot;&gt;标签联系&lt;/a&gt;&lt;!--加载新窗口 --&gt;&lt;a href=&quot;超链接.html&quot; target=&quot;_self&quot;&gt;超链接&lt;/a&gt;&lt;!-- 正常打开 --&gt;\n\nP标签定义段落\np 标签中的文字默认会独占一行，并且段与段之间会有一个间距。\n\nbr标签呈现换行符效果&lt;br&#x2F;&gt;\n\n 可插入一个简单的换行符。 标签是自闭合标签。请注意， 标签只是简单地开始新的一行,不会像段落一样有上下间距.\nol标签：有序列表\nli标签:列表项type属性：1,A,a,i,I\n\n\nul无序列表\nli列表选项type属性： circle,disc,square\n\n  \n\n在HTML中预留了一些字符。 这些预留字符是不能在网页中直接使用的。 比如&lt; 和 &gt;,我们不能直接在页面中使用&lt; 和 &gt;号，因为浏览器会将它解析为html签。 例如： 会被解析为b标签，空格,再多的空格都会当一个空格处理。为了可以使用这些预留字符，我们必须在html中使用字符转义。 \n小于号&lt;    : &amp;lt      * 版权(C) : &amp;  copy;     大于号&gt;:    &gt;     商标(TM)    &amp;trade;          * 空格  &amp;nbsp;      注册商标(R) \t&amp;reg;\n\n\n\n超链接\na标签:HTML 使用超级链接与网络上的另一个文档相连，通俗的说就是通过连接来访问其他网页资源。\n\n&lt;a  href=&quot;http://www.baiduc.om&quot;   target=&quot;_blank&quot;&gt;百度&lt;/a&gt;&lt;a  href=&quot;login.html&quot; target =“_blank&quot;&gt;登录&lt;/a&gt; \n\n注    :  \n&lt;a href=&quot;标签练习.html&quot; target=&quot;_blank&quot;&gt;标签联系&lt;/a&gt;&lt;!--加载新窗口 --&gt;&lt;a href=&quot;超链接.html&quot; target=&quot;_self&quot;&gt;超链接&lt;/a&gt;&lt;!-- 正常打开 --&gt;\n\n\n\n\n练习：图片标签练习:&lt;a href=&#x27;超链接.html&#x27;&gt;   &lt;img align=&quot;center&quot; src=&quot;../img/1.jpg&quot; width=&quot;360&quot; height=&quot;180&quot; border=&quot;2&quot;  alt=&quot;图片&quot;\t\t title=&quot;美丽的壁纸&quot;/&gt;打开超链接\n\n注: title=”美丽的壁纸”   表示鼠标放在图上会出现汉字”美丽壁纸”\n\n\n图片练习:&lt;img align=&quot;center&quot; src=&quot;../img/1.jpg&quot; width=&quot;360&quot; height=&quot;180&quot; border=&quot;2&quot;  alt=&quot;图片&quot; \t\t title=&quot;美丽的壁纸&quot;/&gt;\n\n\n\n超链接定位,标点:&lt;body&gt;\t&lt;a name&#x3D;&quot;top&quot;&gt;&lt;&#x2F;a&gt;\n\n\t&lt;a href=&quot;#p1&quot;&gt;一号&lt;/a&gt;\t&lt;a href=&quot;#p2&quot;&gt;二号&lt;/a&gt;\t&lt;a href=&quot;#p3&quot;&gt;三号&lt;/a&gt;\t&lt;a href=&quot;#p4&quot;&gt;四号&lt;/a&gt;\t&lt;a href=&quot;#p5&quot;&gt;五号&lt;/a&gt;\t&lt;a href=&quot;#p6&quot;&gt;六号&lt;/a&gt;\t&lt;a href=&quot;#p7&quot;&gt;七号&lt;/a&gt;\t&lt;h2&gt;一号\t\t&lt;a name=&quot;p1&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;h2&gt;二号\t\t&lt;a name=&quot;p2&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;h2&gt;三号\t\t&lt;a name=&quot;p3&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;h2&gt;四号\t\t&lt;a name=&quot;p4&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;h2&gt;五号\t\t&lt;a name=&quot;p5&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;h2&gt;六号\t\t&lt;a name=&quot;p6&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;h2&gt;七号\t\t&lt;a name=&quot;p7&quot;&gt;&lt;/a&gt;\t&lt;/h2&gt;\t&lt;img src=&quot;../img/1.jpg&quot; /&gt;\t&lt;p align=&quot;right&quot; &gt;\t\t&lt;a href=&quot;#top&quot;&gt;返回顶部&lt;/a&gt;\t&lt;/p&gt;&lt;/body&gt;\n\n\n\n在线考试\nHtml换行使用标签\n\nnnn\nnnn\nnnn\nnnn\n\n\n页面插入标签\n\nnnn\nnnn\nnnn\nnnn\n\n\n\n对应代码：\n&lt;h1&gt;在线考试&lt;/h1&gt;\t\t&lt;ol type=&quot;1&quot;&gt;\t\t&lt;li&gt;Html换行使用标签 &lt;/li&gt;\t\t&lt;ol type=&quot;A&quot;&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t&lt;/ol&gt;\t\t&lt;li&gt;页面插入标签&lt;/li&gt;\t\t&lt;ol type=&quot;A&quot;&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t\t&lt;li&gt;nnn&lt;/li&gt;\t\t&lt;/ol&gt;\t\t&lt;/l&gt;\n\n\n\n\n\n标签练习\t&lt;h1 align=&quot;center&quot; style=&quot;color: red;&quot;&gt; 古诗词鉴赏&lt;/h1&gt;\t&lt;hr /&gt;\t&lt;h3 align=&quot;center&quot;&gt;静夜思&lt;/h3&gt;\t&lt;h5 align=&quot;center&quot;&gt;李白&lt;/h5&gt;\t&lt;p align=&quot;center&quot; style=&quot;color: chartreuse;&quot;&gt;床前明月光，&lt;br /&gt;\t\t疑是地上霜。&lt;br /&gt;\t\t举头望明月，&lt;br /&gt;\t\t低头思故乡。&lt;br /&gt;\t&lt;/p&gt;\t&lt;p style=&quot;color: cornflowerblue;&quot; align=&quot;center&quot;&gt;\t\t《静夜思》是唐代诗人李白所作的一首五言古诗。&lt;br /&gt;\t\t此诗描写了秋日夜晚，诗人于屋内抬头望月的所感。&lt;br /&gt;\t\t诗中运用比喻、衬托等手法，表达客居思乡之情，&lt;br /&gt;\t\t语言清新朴素而韵味含蓄无穷，历来广为传诵。&lt;br /&gt;\t\t&lt;img src=&quot;../img/libai.jpg&quot; align=&quot;center&quot; /&gt;\t\t&lt;hr /&gt;\t&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;\t友情连接 :&lt;a href=&quot;超链接.html&quot; target=&quot;_self&quot;&gt;A网站&lt;/a&gt;&amp;nbsp;|&amp;nbsp;&lt;a href=&quot;图片练习.html&quot; target=&quot;_self&quot;&gt;B网站&lt;/a&gt;\t&amp;nbsp;|&amp;nbsp;&lt;a href=&quot;图片练习.html&quot; target=&quot;_self&quot;&gt;C网站&lt;/a&gt;\n\n\n\n","categories":["-前端"],"tags":["HTML"]},{"title":"十大算法——二分查找算法","url":"http://example.com/2020/09/24/算法-常用10种算法001-二分/","content":"二分查找算法二分查找算法(非递归)介绍二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找\n二分查找法的运行时间为对数时间 O(㏒₂n)  ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 ,  即最多需要查找 7 次( 2^6 &lt; 100 &lt; 2^7)14.1.2  二分查找算法(非递归)代码实现数组 {1,3, 8, 10, 11, 67, 100},  编程实现二分查找， 要求使用非递归的方式完成.\n  \n\n 代码实现：\npackage com.atguigu.binarysearchnorecursion;public class BinarySearchNoRecur &#123;public static void main(String[] args) &#123;        //测试        int[] arr = &#123;1,3, 8, 10, 11, 67, 100&#125;;        int index = binarySearch(arr, 100);        System.out.println(&quot;index=&quot; + index);//            /**            *            *            @param arr  待查找的数组, arr 是升序排序            - @param target 需要查找的数            - @return  返回对应下标，-1 表示没有找到              */          public static int binarySearch(int[] arr, int target)           &#123;                   int left = 0;                   int right = arr.length - 1;                  while(left &lt;= right) &#123; //说明继续查找                      int mid = (left + right) / 2;                      if(arr[mid] == target) &#123;                          return mid;                          &#125; else if ( arr[mid] &gt; target) &#123;                          right = mid - 1;//需要向左边查找                          &#125; else &#123;                          left = mid + 1; //需要向右边查找                      &#125;                  &#125;                    return -1;&#125;\n\n二分查找算法(递归)：​     代码实现：\n\tpublic static int binarySearch(int[] arr, int left, int right, int findVal) &#123;\t// 当 left &gt; right 时，说明递归整个数组，但是没有找到\tif (left &gt; right) &#123;\t\treturn -1;\t&#125;\tint mid = (left + right) / 2;\tint midVal = arr[mid];\tif (findVal &gt; midVal) &#123; // 向 右递归\t\treturn binarySearch(arr, mid + 1, right, findVal);\t&#125; else if (findVal &lt; midVal) &#123; // 向左递归\t\treturn binarySearch(arr, left, mid - 1, findVal);\t&#125; else &#123;\t\t\t\treturn mid;\t&#125;&#125;","categories":["-算法"],"tags":["常用10种算法"]},{"title":"java中的时间和日期","url":"http://example.com/2020/09/24/javase20-0924基础-时间和日期[草稿]/","content":"如何取得年月日、小时分钟秒？  \n\n\n\n\n1. public class DateTimeTest &#123;\n2. public static void main(String[] args) &#123;\n3. Calendar cal = Calendar.getInstance();\n4. System.out.println(cal.get(Calendar.YEAR));\n5. System.out.println(cal.get(Calendar.MONTH)); // 0 - 11\n6. System.out.println(cal.get(Calendar.DATE));\n7. System.out.println(cal.get(Calendar.HOUR_OF_DAY));\n8. System.out.println(cal.get(Calendar.MINUTE));\n9. System.out.println(cal.get(Calendar.SECOND));\n10. // Java 8\n11. LocalDateTime dt = LocalDateTime.now();\n12. System.out.println(dt.getYear());\n13. System.out.println(dt.getMonthValue()); // 1 - 12\n14. System.out.println(dt.getDayOfMonth());\n15. System.out.println(dt.getHour());\n16. System.out.println(dt.getMinute());\n17. System.out.println(dt.getSecond());\n18. &#125;\n#### 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？ &#96;&#96;&#96;java1. Calendar.getInstance().getTimeInMillis(); &#x2F;&#x2F;第一种方式2. System.currentTimeMillis(); &#x2F;&#x2F;第二种方式3. &#x2F;&#x2F; Java 84. Clock.systemDefaultZone().millis()\n\n\n\n如何取得某月的最后一天？获取当前月第一天： \n1. Calendar c = Calendar.getInstance();2. c.add(Calendar.MONTH, 0);3. c.set(Calendar.DAY_OF_MONTH,1);//设置为 1 号,当前日期既为本月第一天4. String first = format.format(c.getTime());5. System.out.println(&quot;===============first:&quot;+first);\n\n获取当前月最后一天 \n1. Calendar ca = Calendar.getInstance();2. ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));3. String last = format.format(ca.getTime());4. System.out.println(&quot;===============last:&quot;+last); \n\n15. LocalDate today = LocalDate.now();16. //本月的第一天17. LocalDate firstday = LocalDate.of(today.getYear(),today.getMonth(),1);18. //本月的最后一天19. LocalDate lastDay =today.with(TemporalAdjusters.lastDayOfMonth());20. System.out.println(&quot;本月的第一天&quot;+firstday);21. System.out.println(&quot;本月的最后一天&quot;+lastDay); \n\n\n\n如何格式化日期？\nJava.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date)方法可将日期格式化。\n\nJava 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示： \n1. import java.text.SimpleDateFormat;2. import java.time.LocalDate;3. import java.time.format.DateTimeFormatter;4. import java.util.Date;5. class DateFormatTest   &#123; 6.6. public static void main(String[] args) &#123;7. SimpleDateFormat oldFormatter = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);8. Date date1 = new Date();9. System.out.println(oldFormatter.format(date1));   11.10. // Java 811. DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;);12. LocalDate date2 = LocalDate.now();13. System.out.println(date2.format(newFormatter));14. &#125;15. &#125;\n​         补充： Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题， Java 8 中引入了新的时间日期 API，其中包括 LocalDate、 LocalTime、 LocalDateTime、 Clock、 Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。 \n\n\n","categories":["-javase"],"tags":["面试"]},{"title":"javase-intern（）","url":"http://example.com/2020/09/24/javase20-0924基础-intern/","content":"Java intern() 方法intern() 方法返回字符串对象的规范化表示形式。\n它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。\n语法public String intern()\n\n  \n\n参数\n无\n\n返回值一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池。\n实例public class Test &#123;    public static void main(String args[]) &#123;        String Str1 = new String(&quot;www.runoob.com&quot;);        String Str2 = new String(&quot;WWW.RUNOOB.COM&quot;);        System.out.print(&quot;规范表示:&quot; );        System.out.println(Str1.intern());        System.out.print(&quot;规范表示:&quot; );        System.out.println(Str2.intern());    &#125;&#125;\n\n以上程序执行结果为：\n规范表示:www.runoob.com规范表示:WWW.RUNOOB.COM\n\n补充：尽管在输出中调用intern方法并没有什么效果，但是实际上后台这个方法会做一系列的动作和操作。在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。\n可以看下面一个范例：\nString str1 = &quot;a&quot;;String str2 = &quot;b&quot;;String str3 = &quot;ab&quot;;String str4 = str1 + str2;String str5 = new String(&quot;ab&quot;); System.out.println(str5.equals(str3));System.out.println(str5 == str3);System.out.println(str5.intern() == str3);System.out.println(str5.intern() == str4);\n\n得到的结果：\ntruefalsetruefalse\n\n为什么会得到这样的一个结果呢？我们一步一步的分析。\n\n第一、str5.equals(str3)这个结果为true，不用太多的解释，因为字符串的值的内容相同。\n第二、str5 == str3对比的是引用的地址是否相同，由于str5采用new String方式定义的，所以地址引用一定不相等。所以结果为false。\n第三、当str5调用intern的时候，会检查字符串池中是否含有该字符串。由于之前定义的str3已经进入字符串池中，所以会得到相同的引用。\n第四，当str4 = str1 + str2后，str4的值也为”ab”，但是为什么这个结果会是false呢？先看下面代码：\n\nString a = new String(&quot;ab&quot;);String b = new String(&quot;ab&quot;);String c = &quot;ab&quot;;String d = &quot;a&quot; + &quot;b&quot;;String e = &quot;b&quot;;String f = &quot;a&quot; + e;System.out.println(b.intern() == a);System.out.println(b.intern() == c);System.out.println(b.intern() == d);System.out.println(b.intern() == f);System.out.println(b.intern() == a.intern());\n\n运行结果：\nfalsetruetruefalsetrue\n\n由运行结果可以看出来，b.intern() == a和b.intern() == c可知，采用new 创建的字符串对象不进入字符串池，并且通过b.intern() == d和b.intern() == f可知，字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如f中的e）则不会进入字符串池中。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。\n当研究到这个地方的时候，突然想起来经常遇到的一个比较经典的Java问题，就是对比equal和==的区别，当时记得老师只是说“==”判断的是“地址”，但是并没说清楚什么时候会有地址相等的情况。现在看来，在定义变量的时候赋值，如果赋值的是静态的字符串，就会执行进入字符串池的操作，如果池中含有该字符串，则返回引用。\n执行下面的代码：\nString a = &quot;abc&quot;;String b = &quot;abc&quot;;String c = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;String d = &quot;a&quot; + &quot;bc&quot;;String e = &quot;ab&quot; + &quot;c&quot;;        System.out.println(a == b);System.out.println(a == c);System.out.println(a == d);System.out.println(a == e);System.out.println(c == d);System.out.println(c == e);\n\n运行的结果：\ntruetruetruetruetruetrue\n\n\n\n相关面试题：请说出下面程序的输\n1. class StringEqualTest &#123;2. public static void main(String[] args) &#123;3. String s1 = &quot;Programming&quot;;4. String s2 = new String(&quot;Programming&quot;);5. String s3 = &quot;Program&quot;;6. String s4 = &quot;ming&quot;;7. String s5 = &quot;Program&quot; + &quot;ming&quot;;8. String s6 = s3 + s4;9. System.out.println(s1 == s2);            //false10. System.out.println(s1 == s5);            //true11. System.out.println(s1 == s6);           //false12. System.out.println(s1 == s6.intern());  //true13. System.out.println(s2 == s2.intern());   //false14. &#125;15. &#125;\n\n补充：解答上面的面试题需要知道如下两个知识点：\nString 对象的 intern（） 方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String 对象的 equals 结果是 true） ，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；\n字符串的+操作其本质是创建了 StringBuilder 对象进行 append 操作， 然后将拼接后的 StringBuilder 对 象 用 toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class 命令获得 class 文件对应的 JVM 字节码指令就可以看出来。\n\n","categories":["-javase"],"tags":["面试","基础"]},{"title":"计算机网络——Tcp三次握手详解","url":"http://example.com/2020/09/24/计算机网络——Tcp三次握手详解/","content":"计算机网络——TCP 三次握手详解重点内容：\n\nTCP 报文段结构\n\n三次握手\n\nSYN 洪泛攻击\n\n为什么是“三次”\n TCP 是面向连接的(connection-oriented)，即收发双方在发送数据之前，必须首先建立一个连接，这样在连接断开之前，就一直使用这个连接传输数据。建立连接包括参数的设置、内存空间的分配，收发双方参数的协商等，这一过程需要经过三次成功的沟通，一般叫做“三次握手” (a three-way handshake)。用通俗的话来讲，这三次沟通就是：\n  \n\n​           发起方： “你好，请问我可以跟你建立一个连接吗？ ”（发送请求，等待回复）​           接收方： “好啊，我准备好了，来吧。 ”​            发起方： “好的，谢谢，我现在开始向你发送数据了。 ”当然，在具体的实现过程中，还包含许多细节，以下一一阐述。\n\nTCP 报文段结构\n要了解三次握手的过程中发送了什么报文，首先得知道 TCP 报文段由哪些字段构成，其中哪些字段在这个过程中起了关键作用。我们重点关注以下几个字段：\n\nSequence number：序列号，用来标记一个报文段的序号，报文段首字节的字节流编号\nAcknowledgment number：确认号，只有 ACK 标志位为 1 时，确认序号字段才有效\nACK：用于指示确认号是有效的\nSYN：同步序列编号（Synchronize Sequence Numbers）\n\n\n\n\n2.三次握手接下来更为仔细地观察一条 TCP 连接是如何建立的。假设运行在一台主机（客户）上的进程想与另一台主机（服务器）上的进程建立一条连接。客户中的 TCP 会以如下的方式与服务器中的 TCP 建立一条 TCP 连接：\n\n\n第一步：客户端的 TCP 向服务器端的 TCP 发送一个特殊的 TCP 报文段，这个报文段不包含应用层数据，且其首部的 SYN 被置为 1，这个特殊的报文段称为 SYN 报文段。并且，客户机随机选择一个初始序号(client_isn, initial sequence number)，并将该值放在序列号字段下。客户端发送 SYN 报文段，并进入 SYN_SENT 状态，等待服务器确认。\n\n\n第二步：一旦服务端收到该 TCP SYN 报文段（从 SYN 标记位为 1 可以判断），会为该连接分配 TCP 缓存(buffers)和变量，并发送一个允许连接的报文段(connection-granted segment)给客户 TCP。这个报文段也不包含应用层数据，并且SYN 同样被置为 1，此外 ACK 标记位也为 1，确认号为 client_isn+1，并且选择一个初始序号 server_isn 作为序列号字段的值。这个报文段被称为 SYNACK 报文段。此时服务器进入 SYN_RECV 状态。\n\n\n第三步：客户端收到 SYNACK 报文段（通过其中的 SYN， ACK，确认号可以判断）之后，也为该连接分配缓存和变量。然后客户机会再次向服务端发送一个确认报文， ACK 标记位为 1，确认号为 server_isn+1，（这次 SYN 为 0， SYN 只在前两次握手中置为 1），这次的报文段可以携带来自应用层的数据。此时客户端进入ESTABLISHED 状态。 服务端收到这个报文段后，也进入 ESTABLISHED 状态，此时连接就算完全建立好了，双方可以相互发送数据。\n\n\nSYN 洪泛攻击在上面的讨论中我们知道，服务器收到一个 SYN 报文段时，分配并初始化连接变量和缓存，然后发送一个 SYNACK 进行响应。在收到来自客户端的 ACK 报文段之前，连接并没有完全建立，我们称它为半开连接 (half-open connection)。如果客户不发送 ACK 以完成三次握手的第三步，那么服务器会在一定时间内终止该半开连接，并回收分配的资源。\n\n\n   在这样的协议下，很容易被一种叫做 SYN 洪泛攻击 (SYN flood attack) 的拒绝服务攻击 (Denial of Service (DoS) attack) 侵袭。攻击者向服务器发送大量的 TCP SYN报文段，而不完成三次握手的第三步，这样服务器不断为这些半开连接分配资源，导致服务器的连接资源消耗殆尽。\n   目前有一种防御机制可以抵御这种攻击，称为 SYN cookie。\n   这种机制的思想在于，在收到 SYN 之后不马上进行分配资源（因为怕了），而是在第三步时判断连接的发起者是否为一个合法用户，如果是，再分配资源并建立连接。\n   首先，当服务器收到一个 SYN 时，不马上分配资源，而是按如下方式生成一个初始的序列号：该序列号是 “SYN 报文段中的源和目的 IP 地址与端口号以及一个只有服务器自己知道的秘密数 (secret number) ” 的 hash 值，也就是说，只有知道这个秘密数，才可能算出这个序列号（这个初始序列号就称为“cookie”）。然后服务器就发送包含这个初始序列号的 SYNACK。需要注意的是，服务器此时不维护任何关于该 SYN的状态信息，甚至不用记住这个 cookie 值。所以如果客户没有返回一个 ACK，那么对服务器来说就当什么时都没发生，现在 SYN 洪泛攻击就做不成了。\n   那么合法用户是怎样完成第三个步骤的呢？其实并没有什么改变，任然按照原来的方式进行，发送一个 ACK 给服务器。此时需要动点手脚的是服务端，服务端怎么判断这个 ACK 报文是对之前的 SYNACK 的确认呢？很简单，因为之前的 SYNACK 的序列号是根据“SYN 报文段中的源和目的 IP 地址与端口号以及一个只有服务器自己知道的秘密数”算出来的，那么这次如果还是那个用户的话，那么源和目的 IP 地址与端口号是不会变的，然后秘密数服务端也知道，用原来的 hash 函数一算，就得出来了该序列号，然后加 1，看是不是跟这个 ACK 报文的确认号相等，如果相等，那说明这个 ACK对应之前的 SYNACK，是合法的，于是创建一个连接。\n4. 为什么是“三次”首先，为什么是三次握手而不是四次或者更多？这个问题是比较简单的，因为既然三次能够解决的问题，为什么非要用四次来浪费资源？\n但其实问题的重点在于，为什么不能只用两次？第三次握手去掉不行吗？对于应对 SYN 洪泛攻击的改进版的“三次握手”来说（见上文），第三次握手肯定是必须的，这个显而易见。\n那如果不考虑攻击呢？两次握手就能搞定吗？\n总的来说，三次握手是为了防止当已失效的连接请求报文段突然又传到服务端，造成双方的不一致，导致资源的浪费。\n“已失效的连接请求报文段”指的是这样的情况，客户端发出一个 SYN 报文段，由于阻塞或者其他原因在网络中滞留，以至于客户端认为丢包了（其实并没有丢），于是重新发出一个 SYN 报文段，假设这一次顺利完成了，那么双方建立连接。这看起来似乎没什么问题，但网络中有一个隐患，就是那个还在网络中传输的 SYN 报文段，如果这个 SYN 在连接期间被服务端收到了，那服务端只会无视它，这样就万事大吉了，但如果是在连接释放之后被收到呢？此时服务端认为有人向他发出连接请求，于是响应一个 SYNACK 回去，如果采用两次握手的话，那么服务器认为此时连接已经建立好了。但是当客户端收到这个 SYNACK 时， 如果他并没有发起连接，那么他不会理睬这个 SYNACK，就当没事发生过（如果客户端此时正好发起连接，那其实他也不会理睬这个 SYNACK，因为确认号不对啊。）。那问题就大了，这时候服务器以为连接好了，向客户端发送数据，而客户端处于 CLOSED 状态，会丢弃这些包，这样就很浪费了。并且还有一个尴尬的问题，就是这个时候当客户端打算发起连接时，服务端又不理睬了，在这里尬这，他们就别想互发数据了。当然这些问题似乎不是不可解决的，当客户端发现服务端老是向自己发数据，而自己总是丢弃，可能会向服务端发一个RST（报文段的 RST 标记号为 1），强制服务端关闭连接。但资源总归是浪费了一会了。而用三次握手就不会出现这样的问题。 \n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"计算机网络——TCP 四次挥手过程详解","url":"http://example.com/2020/09/24/网络概念tcp-四次挥手/","content":"计算机网络——TCP 四次挥手过程详解​       TCP 是面向连接的，连接的建立过程被称为“三次握手”，天下没有不散的宴席，有了连接的建立，就会有连接的断开， TCP 断开的过程通常被称为“四次挥手”。​       首先要明确一点，断开 TCP 请求既可以由客户端发起也可以由服务端发起。这里讨论客户端发起断开连接请求的情况。\n  \n\n过程如下：（可以先看文末的通俗对话模拟）\n\n(1) 客户端 A 发出一个关闭连接的命令，这会使得客户端的 TCP 发送一个特殊的 TCP 报文段给服务器 B，这个报文段的 FIN 标记位（finish 的缩写，表示结束）被置为 1。此时 A 由 ESTABLISHED 状态转为 FIN_WAIT_1 状态，等待来自 B 的 ACK 报文。(2) B 收到这个报文段，检测到这是请求关闭连接的报文，发送一个确认报文段（ACK 字段为 1）给 A，表示收到，通知 A 可以释放连接了。 A 收到这个ACK 报文时，单方面释放了与 B 的连接，此时他不能再向 B 发送应用层数据了，但由于 B 可能还有数据没有发送完，所以此时 A 还可以接收来自 B 的报文段。此时 A 进入 FIN_WAIT_2 状态，等待来自 B 的 FIN 报文。 B 由ESTABLISHED 状态进入 CLOSE_WAIT 状态。(3) 当 B 向 A 发送完所有数据之后，也向 A 发送一个关闭连接的报文段，FIN 和 ACK 都为 1 的报文段（还没有搞清楚为什么 ACK 也是 1，但估计是为了与第一次的请求关闭报文段区分开），并等待来自 A 的确认报文段。此时 B进入 LAST_ACK 状态。(4) A 接收到 B 的关闭连接请求后，给 B 发一个确认报文段，通知 B 可以释放连接了。 B 收到之后，释放所有连接资源，进入 CLOSED 状态。而 A 并没有马上释放资源，而是进入 TIME_WAIT 状态，等待一段时间（自定义，通常为 30sec、 1min 或 2min），使得可以在 ACK 报文段丢失的情况下进行重传。在等待时间结束之后，连接正式关闭，客户端的所有资源也被释放，进入CLOSED 状态。以下分别为客户端和服务端的 TCP 连接状态转换（结合 TCP 的三次握手）：\n\n\n由上述的讨论可知，之所以需要进行四次挥手，在于某一方发起关闭连接的请求时，可以保证自己不再需要发送数据，但并不能猜测到对方是否已经发送完数据了，所以只是先通知对方我要断开连接了，你也差不多可以断开了，对方可以断开的时候则又会发一个断开连接的报文段。而额外的两个的 ACK 报文是确保两个 FIN 报文都被接收到。\n模拟成一段对话就是：◆ A： “我发完数据了，不发了，要断开连接啦！ ”（FIN 报文）◆ B： “好啊，你不发就不发，但先收完我发给你的数据好吗，很快就发完了。 ”（ACK 报文）◆ （A 继续接收来自 B 的数据）◆ B（发完数据）： “好了，我也发完数据了，可以断开连接了！ ”（FIN/ACK报文）◆ A： “好，断开吧！ ”（ACK 报文）◆ （B 收到后马上断开并释放资源，而 A 还要再等一会，万一这条消息丢失了， B 还会再催促。等够一段时间， A 就默认 B 已经收到确认消息了，于是也断开连接，释放资源） \n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"自顶向下-第六章复习知识点","url":"http://example.com/2020/09/24/网络概念05/","content":"计算机网络自顶向下-第六章复习知识点\n1.数据链路层提供的服务。\n\n成帧。 （网络层数据报经链路传送前，链路层协议将其用链路层帧封装起来）\n\n链路接入。 （MAC协议规定了帧在链路传输的规则。链路的一段仅有一个发送方，另一端只有一个接收方的点对点链路）\n\n可靠交付。 （保证无差错地经链路层移动每个网络数据报）\n\n差错检验和纠正。\n  \n\n\n\n2.多路访问协议作用及分类；理想的多路访问协议；纯ALOHA和时隙ALOHA效率如何？\n多路访问协议：\n作用：节点通过这些协议来规范它们在共享的广播信道上的传输行为。\n分类：信道划分协议、随机接入协议和轮流协议。\n理想的多路访问协议：\n（1）当仅有一个节点发送数据时，该节点具有R bps的吞吐量；\n（2）当有M个节点发送数据时，每个节点吞吐量为R/M bps；（每个节点在一定时间间隔内应有R/M的平均速率）\n（3）协议是分散的；（不会因某个主节点故障而使整个系统崩溃）\n（4）协议是简单的，实现不昂贵。\n纯ALOHA（非时隙、高度分散）：\n最大效率为 1/(2e)=0.185。\n时隙ALOHA（高度分散的）：\n当只有一个节点时可以全速R连续传输；\n一个给定节点传输的概率为p，节点成功传送的概率为 p(1-p)^(N-1)，N个节点任意一个发送成功的概率 Np(1-p)^(N-1)。（这个协议最大效率为 1/e=0.37，是纯ALOHA两倍）\n3.CSMA协议原理；局域网及拓扑结构；以太网；以太网的MAC协议CSMA/CD、CSMA/CA。\n载波侦听多路访问（CSMA）：\n说话之前先听。（这被称为 载波侦听 ，即一个节点在传输前先听信道）\n如果与他人同事开始说话，停止说话。（这称为 碰撞检测 ，即当一个传输节点在传输时一直在侦听此信道）\n具有碰撞检测的载波侦听多路访问（CSMA/CD）：（CSMA/CA为无线的协议）\n（1）适配器从网络层一条活的数据报，准备链路层帧，并将其放入帧适配器缓存中。\n（2）如果适配器真听到信道空闲，它开始传输帧。如果听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。\n（3）在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。\n（4）如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧；若检测到其他适配器的信号能量，将终止传输。\n（5）终止传输后，适配器等待一个随机量，然后返回步骤2。\n当传输一个特定帧时，在该帧经历n次碰撞后，节点随机地从｛0，1，2，…，2^(n-1)｝中选择一个K值。（经历的碰撞越多，K选择的间隔越大）对于以太网，一个节点等待的实际时间量是 K*512 比特时间（即发送512比特进入以太网所需时间量的K倍），n的最大值在10以内。\n4.链路层编址；MAC地址；ARP的工作原理与作用。\n链路层地址有三种称呼：LAN地址、物理地址、MAC地址。\nMAC地址：\n不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。\nMAC地址长度为6字节，共有2^48可能的MAC地址。\nMAC地址通常被设计为永久。\nMAC广播地址为 FF-FF-FF-FF-FF-FF。\nARP（地址解析协议）：\n作用：将一个IP地址解析为一个MAC地址。\n工作方式：每台主机和路由器在其内存中具有一个ARP表，这张表包含IP地址到MAC地址的映射关系。\nARP分组有四个字段：源IP、MAC，目的IP、MAC。\n查询ARP报文在广播帧中发送，而响应ARP报文在一个标准帧中发送。\nARP表是自动建立的，不需要管理员配置。\n5.集线器、交换机、路由器的功能和特点。\n集线器：是一种物理层设备，它作用于各个比特而不是作用于帧。当一个比特到达一个接口时，重新生成该比特，将其 能量强度 放大后向其他所有接口传输出去。（若同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的节点必须重新传输该帧）\n交换机：是第二层的分组交换机，使用MAC地址转发分组的存储转发分组交换机。是即插即用的；交换机对于广播风暴不提供任何保护措施，即如果某主机出了故障并传输出没完没了的以太网广播帧，该交换机将转发所有这些帧，是以太网崩溃。\n路由器：第三层的分组交换机，使用网络层IP地址转发分组的存储转发分组交换机。不是即插即用的；对第二层的广播风暴提供防火墙保护。\n补充知识：\n单工，半双工和全双工有何区别：\n \n单工数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，举例：电视，广播。\n半双工数据传输允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输,它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通信。举例：对讲机。\n全双工数据通信允许数据同时在两个方向上传输,因此,全双工通信是两个单工通信方式的结合,它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信，举例：电话通信。\n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"自顶向下-第五章复习知识点","url":"http://example.com/2020/09/24/网络概念06/","content":"计算机网络自顶向下-第五章复习知识点\n一、比较集中式与分散式选路算法；了解链路状态算法和距离向量算法的特点。\n集中式路由选择算法：用完整的、全局性的网络制式计算出从源到目的地之间的最低开销路径。该算法必须知道网络中每条链路的开销。（链路状态算法）\n分散式路由选择算法：路由器以迭代、分布式的计算方式计算出最低开销路径。每个节点仅有与其直接相连链路的开销，然后通过迭代计算过程以及与相邻节点的信息交换。（距离向量算法）\n   \n\n链路状态算法：网络拓扑和所有的链路开销都是已知的，是一种使用全局信息的、集中式的算法。实践中通过让每个节点向网络中所有其他节点广播链路状态分组来完成，其中每个链路状态分组包含它所连接的链路的标识和开销。\n距离向量算法：一种迭代的、异步的和分布式的算法。当遇到路由选择环路的时候可能会产生无穷计数的问题。\n二、了解AS，了解RIP、OSPF、BGP的作用。\n**AS:**每个AS由一组通常处在相同管理控制下的路由器组成(autonomous system)。通常在一个ISP中的路由器以及互联它们的链路构成一个AS。\nAS可能有复杂结构，该独立机构要负责保证其内部的路由信息的一致性和可用性在AS内的路由器，可以自由地选择寻找路由、广播路由、确认路由以及检测路由的一致性的机制。\n每个AS使用相同的AS内部路由选择算法是必要的。\nRIP（选路信息协议）：距离矢量算法，每30秒在邻居之间经响应报文交换，每个通道在AS中包括多达24个目的网络的列表。\nOSPF（开放最短路优先）：作为一种AS内部路由选择协议，运行于IP协议上，是一种链路状态协议，使用洪泛链路状态信息和Dijkstra最低开销路径算法。\n使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。\n每当链路状态改变时，路由器就会广播链路状态信息；即使链路状态未变化也会周期性地（至少每隔30min一次）广播链路状态。\nBGP（边界网关协议）：作为一种AS间路由选择协议，运行于TCP上。为每个AS提供一种手段：\n从邻居AS获得前缀地可达性信息。BGP允许每个子网向因特网地其余部分通告他的存在。\n确定到该前缀地“最好的”路由。一台路由器可能知道两条或更多条特定前缀地不同路由，通过BGP路由选择过程来确定最好的路由。\n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"自顶向下-第四章复习知识点","url":"http://example.com/2020/09/23/网络概念04/","content":"计算机网络自顶向下-第四章复习知识点\n一、转发与选路，建立连接；网络层的服务与功能，因特网网络服务模型。 路由器的基本功能与组成。\n转发：将分组从路由器的输入移动到适当的路由器输出\n选路：决定分组从源到目的地所采取的路由\n连接建立：要求从源到目的地沿着所选择的路径彼此握手，以便在给定源到目的地连接中的网络层数据分组能够开始流动之前建立起状态。\n网络层连接和无连接服务：数据报网络提供网络层无连接服务，虚电路网络提供网络层连接服务\n  \n\n网络服务模型：定义了分组在发送与接收端系统之间的端到端运输特性。\n能由网络层提供的服务：1.确保交付 2.具有时延上界的确保交付 3.有序分组交付 4.确保最小带宽 5.确保最大时延抖动 6.安全性服务\n因特网的网络层提供了单一的服务，称为尽力而为的服务。\n路由器的基本功能和组成：\n1.输入端口:\n1）执行一条输入的物理链路与路由器相连接的物理层功能\n2）执行需要与位于入链路远端的数据链路层交互的数据链路层功能.\n3）完成查找功能\n2.交换结构：交换结构将路由器的输入端口和输出端口相连接\n3.输出端口：储存从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输入链路上传输这些分组。\n4.路由选择处理器：\n1）执行路由选择协议\n2）维护路由选择表以及连接的链路状态信息，并为路由器计算转发表\n3）执行网络管理功能。\n二、虚电路网络和数据报网络\n其他网络体系结构：ATM、帧中继等为虚电路网络，在网络层中使用连接。\n虚电路的组成如下：\n1）源和目的主机之间的路径（即一系列链路和路由器）\n2）VC号，沿着该路径的每段链路的一个号码\n3）沿着该路径的每台路由器中的转发表表项。\n网路的路由器必须为进行中的连接维持连接状态信息，特别是每当跨越一台路由器创建一个新连接，必须在该路由器的转发表中增加一个新的连接项，每当释放一个连接，必须从该表中删除此项。\n数据报网络：\n在数据报网络中，每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将分组推进网络中。无需建立任何虚电路，路由器不维护任何虚电路的状态信息。\n最长前缀匹配原则：在转发表中寻找最长的匹配项，并向最长前缀匹配相关联的链路接口转发分组。\n三、IP网际协议\n网络层有三个主要组件：\n\\1. IP协议\n\\2. 路由选择部分 决定数据报到源目的地所流经的路径\n\\3. 报告数据报中的差错和对某些网路层信息请求进行响应的设施。（ICMP）\n互联网服务被定义成不可靠的、尽力而为、无连接分组交付系统。\n1.服务是不可靠的，因为分组可能丢失、重复、延迟或不按序交付等，但服务不检测这些情况，也不提醒发送方和接收方。\n2.服务是尽力而为的，互联网并不随意地丢弃分组；只有当资源用完或底层网络出现故障时才可能出现不可靠性。\n3.服务是无连接的，因为每个分组都是独立对待的。分组序列可能经过不同的传输路径或者有的丢失有的到达。\nIP编址\n1.IP地址\n主机接口的32-bit 标识符\n点分十进制数\n\n接口:\n\n在主机/路由器和物理链路之间的连接\n路由器通常具有多个接口\n主机可能具有多个接口\nIP编址与每个接口相联系\nClassfull IP Addressing\n(分类IP编址)\nA类地址：\n⑴ A类地址第1字节为网络地址，其它3个字节为主机地址。\n⑵ A类地址范围：1.0.0.0—127.255.255.255\n⑶ A类地址中的私有地址和保留地址：\n① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。\n范围（10.0.0.0.0-10.255.255.255）\n② 127.X.X.X是保留地址，用做循环测试用的。\nB类地址：\n⑴ B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。\n⑵ B类地址范围：128.0.0.0—191.255.255.255。\n⑶ B类地址的私有地址和保留地址\n 172.16.0.0—172.31.255.255是私有地址\n② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。\nC类地址：\n⑴ C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。\n⑵ C类地址范围：192.0.0.0—223.255.255.255。\n⑶ C类地址中的私有地址：\n192.168.X.X是私有地址。(192.168.0.0-192.168.255.255)\nD类地址：\n D类地址不分网络地址和主机地址，它的第1个字节的前四位固定为1110。\n⑵ D类地址范围：224.0.0.0—239.255.255.255\nE类地址：\n E类地址也不分网络地址和主机地址，它的第1个字节的前五位固定为11110。\n⑵ E类地址范围：240.0.0.0—247.255.255.255\n\n子网：\n定义：\n1.无需通过路由器就能够物理上互相到达，在路由器同一侧（接入路由器同一接口），一般处于同一局域网\n2.设备接口被配置的IP地址具有相同的网络地址（即共同的IP地址前缀）\n子网的表示方法：\n1、子网掩码：用从最高位开始的连续1表示IP地址中的子网号部分  255.255.255.0\n2、前缀/长度：223.1.1.0/24，表示前24位为子网号部分\nCIDR（无类别域间选路，Classless Inter-Domain Routing）\n“无类别”指不考虑IP地址所属的类别\n不严格区分A类、B类和C类地址，CIDR用前缀取代了过去地址类型对地址网络部分的限制（3类地址的网络部分分别被限制为8位、16位和24位）。\n比如，4个C类网段192.168.0.0/24， 192.168.1.0/24, 192.168.2.0/24, 192.168.3.0/24汇聚成一条路由192.168.0.0/22.这样ISP路由器只向Internet通告192.168.0.0/22这一条路由,大大减少了路由表的数目.从而为网络路由器节省出了存储空间。\n选路策略，基于整个32bit IP地址的掩码来操作，即基于子网号选路。\n怎样主机指定**IP地址?**\n1.由系统管理员在文件中的硬编码\nWintel: 控制面板-&gt;网络-&gt;配置-&gt;TCP/IP-&gt;性质\nUNIX: /etc/rc.config\n2.动态主机配置协议(Dynamic Host Configuration Protocol DHCP): 动态地从服务器得到地址。亦被称为即插即用协议。\nNAT(Network Address Translation): 网络地址转换\nNAT路由器上有一张NAT转换表，并且在表项中包含端口号及其IP地址\n \n \nICMP: 互联网控制报文协议\n用于主机和路由器彼此交互网络信息，功能为：差错报告、回声请求。\nIPv4与IPv6\n32比特的IP地址空间即将耗尽，应对大IP地址空间的要求，开发新的IP协议即IPv6\n区别：\n1.扩大地址容量 从32比特到128比特。\n2.除单播和多播外加入任播地址。这种地址可以使数据报交付给一组主机中的任意一个\n3.简单高效的40字节首部\n4.留标签和优先级\n5.IPV6不允许在中间路由器上进行分片组装，只能在源和目的地上进行\n6.去除首部检验和\n7.选项不再是标准IP首部一部分。\n选路的角度来说，处于一个管理机构控制之下的网络和路由器群组称为一个自治系统(autonomous system，AS)\nAS可能有复杂结构，该独立机构要负责保证其内部的路由信息的一致性和可用性\n在AS内的路由器，可以自由地选择寻找路由、广播路由、确认路由以及检测路由的一致性的机制\n可安排R3通告网络2、3和4(R1知道网络1)\n核心路由器自己也构成一个自治系统\nRIP（选路信息协议）：距离矢量算法，每30秒在邻居之间经响应报文交换，每个通道在AS中包括多达24个目的网络的列表\nOS-PF（开放最短路优先）：使用链路状态算法，公共可用，OSPF携带每个邻居路由器的一个项，通告散步到整个AS\nBGP（边界网关协议）：为每个AS提供一种手段，从相邻AS获得子网可达性信息，向AS内部的所有路由器传播可达性信息，基于可达信息和策略决定到子网的好路由。\n四、作业补充\n1.数据报网络中网络层两个最重要的功能是:转发,选路.虚电路网络层最重要的三个功能是:转发,选路,和呼叫建立。\n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"自顶向下-第二章复习知识点","url":"http://example.com/2020/09/22/网络概念02/","content":"一、 网络应用程序体系结构（客户机/服务器和P2P）及其特点；套接字；进程标示与寻址；因特网运输协议提供的服务。\n客户机/服务器：\n有一个总是打开的主机称为服务器，他总是服务于来自许多其他称为客户的主机的请求。\n\n客户相互之间不能直接通信\n\n服务器具有固定的、周知的地址、该地址称为IP地址。客户总能通过向该服务器的IP地址发送分组来与其联系。\n  \n\n\n\nP2P：\n 1.无总是打开的服务器\n2.任意的端系统直接通信\n3.对等方间歇地连接，改变IP地址\n4.适用于流量密集型应用程序 IPTV、迅雷、迅雷看看\n5.自扩展性：高度地可扩展，但是难以管理。\n进程与计算机网络之间的接口—套接字(报文交换的实现)\n进程寻址：\n在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。\n1.对于接收报文的进程，必须具有一个标识\n\n一台主机具有一个独特的32比特的IP地址\n\n标示符包括IP地址和与主机上该进程相关的端口号.\n\n\n可供应用程序使用的运输服务1.可靠的数据传输  2.定时 3.吞吐量 4.安全\n因特网提供的运输服务：\n1.TCP服务(可靠,弹性带宽,时延不敏感):\n面向连接: 客户机和服务器之间所需的建立\n可靠传输：在发送和接收进程之间\n流控制: 发送方不会淹没接收方\n拥塞控制: 当网络过载时抑制发送方，有利于整个网络运行，但对有带宽要求的应用非常不利。\n并不提供: 定时，最小带宽保证\n\\2. UDP服务(不可靠,带宽固定,时延敏感): :\n在发送进程及接收进程之间的不可靠数据传输\n不提供：建立连接，可靠性，流控，拥塞控制，定时或带宽保证\n不抑制发送速率，实时应用通常选择UDP\n许多防火墙阻塞UDP流量，使得一些设计者考虑TCP\n二、Web应用和HTTP协议\nWeb的应用层协议是超文本传输协议（HTTP）是Web的核心\n由客户程序和服务器两个程序组成\nHTTP使用TCP作为它的支撑运输协议\n由于HTTP服务器并不保存关于客户的任何信息，所以HTTP称为无状态协议。\n（通过cookies实现用户和服务器的交互）\n三、FTP；因特网中的电子邮件系统；SMTP；POP；IMAP；DNS的作用与功能；带外消息控制，推、拉协议。\nFTP：文件传输协议:\n传输文件到/来自远程主机其使用使用客户机/服务器模型\n（客户机: 发起传输的一侧(到/来自远程之一)  服务器: 远程主机）\n用户首先提供远程主机的主机名，使本地主机客户FTP进程与远程主机FTP服务器进程建立一个TCP连接，同时提供用户标识和口令。\n（ftp: RFC 959  ftp 服务器: 端口 21）\nHTTP和FTP都是文件传输协议，两者最显著的差别为FTP使用了两个并行的TCP连接来传输文件，一个为控制连接，一个为数据连接。控制连接用于两台主机之间传输控制信息，数据连接用于实际传输文件。\n因为FTP使用一个独立的控制连接，所以称FTP控制信息是带外传送的\n因为HTTP协议是在传输文件的同一个TCP连接中发送请求和响应首部行的，所以HTTP可以说是带内发送控制信息的。\n因特网中的电子邮件系统：\n三个主要组成部分：用户代理、邮件服务器、简单邮件传输协议（SMTP）。\nSMTP:简单邮件传送协议\nSMTP是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器。\nSMTP与HTTP的对比：\nHTTP主要是一个拉协议，TCP连接由想要接收文件的机器发起。即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器上拉取这些信息。\nSMTP基本上是一个推协议，TCP连接由想要发送该文件的机器发起。即发送邮件服务器到接收邮件服务器\nSMTP要求每个报文使用7比特ASCLL码形式。HTTP不受限制\n处理一个既包含文本又包含图形的文档，HTTP把每个对象封装到自己的HTTP响应报文中，SMTP则把所有的报文对象放在一个报文之中。\n邮件访问协议：取报文是一个拉操作，而SMTP为一个推协议，通过一个特殊的协议实现邮件服务器到用户代理。\n第三版的邮局协议：POP3  授权 (代理 &lt;–&gt;服务器) 并下载\n因特网邮件访问协议：IMAP 更多特色 (更复杂) 操作存储在服务器上的报文\nDNS:域名系统（因特网的目录服务）\nDNS是：1.一个由分层的DNS服务器实现的分布式数据库。\n2.一个使得主机能够查询分布式数据库的应用层协议。（DNS协议运行在UDP之上，使用53号端口）\nDNS能够进行主机名到IP地址转换的目录服务。 \n四、常用的因特网的应用及所使用的应用层协议；常用的周知端口号。\nWeb:HTTP\n电子邮件：SMTP、IMAP、POP\nDNS    UDP  53\nPOP3 TCP 110\nIMAP TCP 143\nSMTP TCP 25\nHTTP TCP 80\nFTP 控制 TCP 21 FTP 默认数据 TCP 20\nDHCP 服务器 UDP 67\n五、作业补充\n\n为什么HTTP,FTP,STMP,POP3都运行在TCP而不是UDP之上？\n\n因为与这些协议相联系的应用都要求应用数据能够被无差错的有序的接收。TCP提供这种服务，而UDP不提供。TCP提供可靠的数据传输服务，而UDP提供的是不可靠数据传输。\n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"自顶向下-第三章复习知识点","url":"http://example.com/2020/09/22/网络概念03/","content":"一、 传输层的目的与提供的服务\n1.在运行不同主机上应用进程之间提供逻辑通信\n2.运输协议运行在端系统中\n\n应用程序可供使用的运输协议不止一个\n\n提供的服务：可靠的、按序的交付 (TCP) 不可靠、无序的交付: UDP \n二、多路复用与多路分解；端口号；标识UDP套接字的二元组、标识TCP套接字的四元组。\n  \n\n多路分解：将运输层报文段中的数据交付到正确的套接字的工作\n多路复用：在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层。\n端口号是一个16比特的数\n标识TCP的四元组：源IP，源端口，目标IP，目标端口\n标识UDP的二元组：目的IP地址、目的端口号 \n三、**TCP与UDP比较**\n1.TCP面向连接，即客户端需要通过三次握手才能和服务端建立起连接，在这个连接的基础上才可以进行数据传输；而UDP是无连接的，发送数据之前不需要建立连接。因此，TCP需要在端系统中维护连接状态，而UDP则不需要维护连接状态\n2.TCP提供可靠的服务，即通过TCP连接传输的数据能确保无差错、不丢失、无重复且按序到达；UDP不提供可靠的传输服务，传输过程有可能出现丢包，同时也不保证数据报的到达顺序\n3.TCP面向字节流，实际上TCP把数据看作是一连串无结构的字节流；UDP则是面向报文传输\n4.TCP有拥塞控制机制，当源主机和目的主机间的一条或者多条链路变得极度拥塞时来遏制运输层TCP发送方，而UDP没有拥塞控制机制，相比之下，在出现拥塞的情况下，UDP不会降低源主机发送数据的速率，更适合用于支撑部分实时应用如IP电话、实时视频会议等\n5.TCP连接是点对点的，而UDP支持一对一、一对多、多对一和多对多的交互通信\n6.从报文段结构上考虑，每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销 \n四、不同信道特点下的可靠数据传输原理，各种可靠数据传输机制及作用；rdt1.0、rdt2.0、rdt3.0有限状态机；停等协议及效率。\nRdt1.0:经完全可靠信道的可靠数据传输（底层信号非常可靠，无比特差错，无分组丢失）\n \nRdt2.0:经具有比特差错信道的可靠数据传输（肯定确认、否定确认）\n这种基于重传机制的可靠数据传输协议被称为自动重传请求（ARQ）协议\n在ARQ协议中有三种协议功能来处理比特差错的情况：1.差错检测 2.接收方反馈 3.重传\n发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。因此Rdt2.0这样的协议被称为停等协议。\n\nRdt2.1：如果ACK\\NAK受损 可能导致冗余 为了处理冗余发送方对每个分组增加序列号 如果ACK\\NAK受损，发送方重传当前分组，接收方丢弃冗余分组。\n\nRdt2.2 无NAK协议，代替NAK，接收方对最后正确接收的分组发送ACK。\n\nRat3.0:具有比特差错和丢包信道的可靠数据传输 为解决丢包问题，发送方等待ACK一段合理的时间，需要倒数计时器来解决这个问题。\n\n接收方同Rdt2.2相同。\n流水线协议：发送方允许发送多个、“传输中的”、还没有应答的报文段（序号范围必须增加，发送方和接收方没有缓冲）有两种形式：回退N步GBN 选择重传SR\n回退N步：对失序的分组丢弃，不缓存，没有接收缓存区，；重新确认具有按序的分组\n选择重传：通过让发送方仅重传那些他怀疑在接收方出错的分组而避免了不必要的重传。\n其中窗口长度必须小于或者等于序号空间的一半。\n利用率/效率：发送方实际忙于将发送比特送进通道的那部分时间与发送时间之比。\nU = （L/R）/（RTT+L/R） RTT：往返时间可用流水线的方式提高效率。 \n五、流量控制和拥塞控制；TCP连接的建立(三次握手)原理； TCP的序号与确认号的使用方法。TCP的可靠数据传输机制\n流量控制：发送方不能发送太多、太快的数据让接收方缓存溢出。\n拥塞控制：拥塞（太多的源发送太多太多的数据，使网络来不及处理），表现为丢包和长延时。拥塞控制的两种方法：端到端的拥塞控制和网络辅助的拥塞控制。\n端到端拥塞控制：\n1.不能从网络得到明确的反馈\n2.从端系统根据观察到的时延和丢失现象推断出拥塞\n3这是TCP所采用的方法\n网络辅助的拥塞控制:\n1.路由器为端系统提供反馈\n2.一个bit指示一条链路出现拥塞(SNA,DECnet,TCP/IP ECN, ATM)\n3.指示发送方按照一定速率发送\nTCP拥塞控制：端到端控制。三个机制（AIMD加增倍减算法、慢启动和超时事件后的保守机制）。慢启动：当连接开始时，速率呈指数上升，直到第一次报文丢失事件发生为止或到达阙值。\nTCP可靠数据传输机制：TCP在IP不可靠服务的基础上创建可靠数据传输服务\n可靠传输的措施：1.错包：流水线发送报文段、累积确认。2.丢包：TCP使用单个重传计时器，重传超时事件和重复ACK事件。\nTCP连接管理-三次握手\n\n客户机向服务器发送TCP SYN报文段，指定初始序号//随意选择，没有数据\n\n服务器收到SYN报文段，用SYN ACK报文段回复。服务器为该连接分配缓冲区和变量，同时指定服务器初始序号\n\n客户机收到SYNACK，用ACK报文段回复，可能包含数据\n\n\n\nTCP连接管理-关闭连接\n步骤 1: 客户机向服务器发送TCP FIN控制报文段\n步骤 2: 服务器收到FIN，用ACK回答。关闭连接，发送FIN\n步骤 3: 客户机收到FIN, 用ACK回答\n进入 “超时等待” – 将对接收到的FIN进行确认\n步骤 4: 服务器接收ACK，连接关闭\n\n六、作业补充\n1.UDP应用\n.应用程序开发者可能不想其应用程序使用TCP的拥塞控制，因为这会在出现拥塞时降低应用程序的传输速率。通常，IP电话和IP视频会议应用程序的设计者选择让他们的应用程序运行在UDP上，因为他们想要避免TCP的拥塞控制。还有，一些应用不需要TCP提供的可靠数据传输。 (特定服务需要UDP的理由：a应用层能更好的控制要发送的数据和发送时间b无需连接建立c无连接状态d分组首部开销小)\n2.处理多个客户机请求\n对于每个持久连接，Web服务器创建一个单独的“连接套接字”，每个连接套接字由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）识别。当作为Web服务器的主机C接收到IP数据报时，检查数据报里相应的四元组字段决定导向到哪个套接字。虽然目的IP和目的端口号一样，但主机A和主机B的源IP地址不一样，所以主机C不能用相同的套接字与A、B两台不同主机进行通信。两个套接字都可以是80，区分它们的元组可以是不同的源IP地址。\n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"自顶向下-第一章复习知识点","url":"http://example.com/2020/09/22/网络概念01/","content":"一、什么是因特网？\n因特网是一个世界范围内的计算机网络，即它是一个互联了遍及全世界的数以亿计的计算设备的系统。\n可通过基本硬件和软件设备组件（端系统、通信链路、运行网络应用）以及分布式应用提供服务的联网基础设施(通信基础设施使能分布式应用，提供给应用通信服务)来描述。\n    \n\n二、因特网的部件有哪些（软件方面、硬件方面）？   \n硬件方面：\n主机或端系统：数以百万计互联的计算设备。\n端系统的连接部件：通信链路（双绞铜线，光纤，无线电频谱等），分组交换机（路由器，链路层交换机），通信链路和分组交换机组成的路径。\n软件方面：\n硬件是载体，软件是灵魂：软件：数据+算法\n协议：描述通信双方交互信息的方式，控制报文发送接受，以字节流的形式体现。\n因特网标准：因特网工程任务组（IETF）：RFC请求评论、因特网TCP\\IP协议。\n因特网是网络的网络。\n三、什么是端系统、主机、ISP（因特网服务提供商）、ICP(因特网内容提供商)？什么是协议？\n端系统（主机）：与因特网相连的计算机和其他设备。\nISP：因特网服务提供商，每个ISP是一个由多个分组交换机和多端通信链路组成的网络。\nICP：因特网内容提供商，向广大用户综合提供互联网信息业务和增值业务的电信运营商。\n协议：一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送或接收一条报文或其他事件所采取的动作。\n四、网络边缘、网络核心；客户机和服务器。端系统包括？\n网络边缘：1.应用程序和主机 2.接入网络、物理媒体\n网络核心：1.互联的路由器 2.网络的网络\n客户机和服务器：客户机非正式等同于桌面PC、智能手机等，服务器非正式等同于更为强大的机器。\n端系统包括：桌面计算机（桌面PC、Mac和linux盒）、服务器（web和电子邮件服务器）和移动计算机（便携机、智能手机和平板电脑）\n五、 电路交换和分组交换的特点\n电路交换：非共享、性能有保障、效率低，需要建立连接\n分组交换：共享，效率高，有时延\n分组交换和电路交换各有优缺点。\n分组交换的优缺点：\n1、它提供了比电路交换更好的带宽共享；同样的网络资源可以容纳更多的用户，比电路交换的资源利用率高；\n2、与电路交换相比，分组交换技术要简单、有效、容易实现，成本低无需建立连接，分组交换无需维护连接状态等\n3、缺点:\n分组交换因它的端到端时延是变动的和不可预测的(主要是因为排队时延的变动和不可预测所致)，故而不适合实时服务(例如，电话和视频会议)。\n六、接入网的类型，接入网的多种技术；物理媒体分类与常见的物理媒体及其特点。\n接入网：将端系统连接到其边缘路由器（端系统到任何其他远程端系统的路径上的第一台路由器）的物理链路\n接入网的多种技术：\n家庭接入：DSL、电缆、FTTH、拨号和卫星\n企业接入：以太网和WiFi\n广域无限接入：3G和LTE\n物理媒体分类：\n导引型媒体：电波沿固体媒体前行，如光缆、双绞铜线、电缆。\n非导引型媒体：电波在空气或外层空气中传播，如在无线局域网，或者数字卫星频道中。\n常见的物理媒体及其特点\n1.双绞铜线：最便宜且使用最为简便；常用在建筑物内的计算机网络中，即在局域网中。\n2.同轴电缆：由两个同心而不并行的铜导体组成，。具有较高的数据传输速率；在电缆电视系统中相当普遍。\n3.光纤：光纤是一种细而柔软的、能够导引光脉冲的媒体，每个脉冲表示一个比特，支持极高的比特速率，不受电磁干扰，且光缆信号衰减极低，并且很难窃听。用于长途引导型传输媒体，特别是跨海链路。\n4.陆地无线电通道：无线电信道承载电磁频谱中的信号。它不需要安装物理线路，并具有穿透墙壁，提供与移动用户的连接以及长距离承载信号的能力。\n5.卫星无线电信道：同步卫星和近地轨道卫星\n七、分组交换网络中的4种类型的时延及其特点；吞吐量。\n1.结点处理时延：检查比特差错，决定输出链路，高速路由器的处理时延通常为微秒或更低数量级。\n2.排队时延：等待链路的可用时间，取决于前面的正在排队等待链路传输的分组数量\n3.传输时延：R= 链路带宽 (bps)；L= 分组长度 (比特)；发送比特进入链路的时间= L/R\n实际时间为毫秒到微秒级。（传输时延是路由器将分组推出所需要的时间）\n4.传播时延：d = 物理链路的长度取决于链路的物理材质；s = 在媒体中传播的速度 (2x108 ~3x108 m/sec)；传播时延 = d/s；广域网中为毫秒级\n5.端到端的时延包括节点处理时延、传输时延、传播时延和排队时延。节点处理时延、传输时延、传播时延是固定的，排队时延是变化的。\n吞吐量：接受比特/用去的时间\n八、因特网协议栈自顶向下的5个层次及各层的主要功能。各层数据单元的名称是？相关层的协议分析。\n应用层：\n完成一个端系统与另一个端系统之间的信息交换。包含大量应用普遍需要的协议，支持网络应用\n数据单元：报文\n相关协议分析：FTP、SMTP、HTTP \n运输层：\n在应用程序端点之间传送应用报文。主机到主机数据传输，负责从应用层接收报文段（ segment ），并传输应用层的报文，到达目的后将消息上交给应用。\n数据单元：报文段\n相关协议分析：TCP、UDP\n网络层：\n在完成网络中一台主机与另一台主机之间的通信。从源到目的地数据报（datagram）的选路\n数据单元：数据报\n相关协议分析：IP、选路协议\n链路层：为网络层将分组从一个节点移动到下一个节点。在邻近网元之间传输数据\n数据单元：帧\n相关协议分析：PPP、以太网\n物理层：将链路层一帧中一个一个比特从一个节点移动到下一个节点。物理层负责将链路层帧中的每一位(bit)从链路的一端传输到另一端。\n数据单元：比特。\n相关协议分析：无。\n九、OSI参考模型的七层结构及各层的主要功能。TCP/IP四层模型的结构及各层的主要功能。\n应用层、表示层、会话层、传输层、网络层、链路层、物理层\n表示层：使通信的应用程序能够解释交换数据的含义（如数据加密、压缩、描述）\n会话层：数据交换的定界、同步，包括建立检查点和恢复方案的方法\n（因特网协议栈中没有这两层，如果需要这些服务，必须在应用层中实现）\nTCP/IP四层模型：应用层、传输层、互联层、主机-网络层。\n十、作业补充\n1.各种处理因特网协议栈中层次：\n路由器处理第一层到第三层（也就是物理层、数据链路层和网络层）；链路交换机处理第一层和第二层（也就是物理层和数据链路层）；主机处理所有的5层（也就是物理层、数据链路层、网络层、传输层和应用层）。\n2.与分组交换网络相比，电路交换优点，TDM比FDM的优点。\n电路交换网络具有带宽的保证、时延的保证，而分组交换网络一般不能保证带宽和时延。分组交换更简单，通信效率更高。\nFDM（频分复用Frequency Division Multiplexing)\n是将整个传输频带划分为若干个频率通道，每个用 户占用一个通道。频率通道之间留有防护频带；\nTDM（时分复用Time Division Multiplexing）是将时间分割成小的时间片，每个时间片又分为若干个通道(时隙），每个用户占用一个通道传输数据。\nTDM与FDM对比分析时，由于TDM适用于数字信号传输，FDM适用于模拟信号传输，而目前的通信技术中绝倒多数情况下都使用数字通信，因此就体现出了TDM的优势。\n3.\n应用层报文：应用程序要发出的在传输层上传递的数据；\n传输层报文段：将应用层报文加上传输层包头，由传输层管理和封装的信息；\n网络层数据报：将传输层报文段加上网络层包头之后封装；\n链路层帧：将网络层数据报加上链路层包头之后封装。\n","categories":["-计算机网络"],"tags":["面试","网络"]},{"title":"javase","url":"http://example.com/2020/09/22/index - 副本 (2)/","content":"士大夫山豆根萨格11\n1fsdfsdgsdgsdds\n","categories":["-javase"],"tags":[]},{"title":"javase","url":"http://example.com/2020/09/22/index - 副本/","content":"士大夫山豆根萨格11\n1fsdfsdgsdgsdds\n","categories":["-算法"],"tags":["jQuery","表格","表单验证"]},{"title":"javase","url":"http://example.com/2020/09/22/index/","content":"士大夫山豆根萨格11\n1fsdfsdgsdgsdds\n","categories":["-前端"],"tags":[]},{"title":"11","url":"http://example.com/2020/09/22/index - 副本 (3)/","content":"士大夫山豆根萨格11\n1fsdfsdgsdgsdds\n","categories":["-javase"],"tags":["jQuery","表格","面试"]},{"title":"","url":"http://example.com/2020/09/21/hhhhh你骄傲/","content":"title: 常用工具date: 2017-12-14 13:05:38type: “resources”\nLesson_2MySql-22.校对集在某种字符集下，字符和字符的关系称为校对集。比如(ASCII)a和B的大小关系，如果区分大小写a&gt;B，如果不区分大小写a&lt;B\n不同的校对集的比较规则不一样。\n在定义表的时候可以指定校对集\n&lt;!--more--&gt;\n\n#utf8_general_ci  使用_ci这种校对集不区分大小写create table t1(name char(1))charset&#x3D;utf8 collate&#x3D;utf8_general_ci;create table t2(name char(1))charset&#x3D;utf8 collate&#x3D;utf8_bin;insert into t1 values (&#39;a&#39;),(&#39;B&#39;);insert into t2 values (&#39;a&#39;),(&#39;B&#39;);\n\nmysql&gt; select * from t1 order by name;+------+| name |+------+| a    || B    |+------+2 rows in set (0.00 sec)#排序查询以后没有区分大小写说明a和b不区分大小写;\n\nmysql&gt; select * from t2 order by name;+------+| name |+------+| B    || a    |+------+2 rows in set (0.00 sec)#按照正序排列,对照ASCLL编码,B&lt;a,B在a前面那么这种二进制校对集区分大小写;\n\n牢记:_bin：按二进制编码比较_ci：不区分大小写比较\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(2)unsigned  (无符号)一个数是无符号数，那么这个数肯定是非负数\n数据库mysql第一条记录一定是1(起码是),绝对不能是0\ntinyint unsigned   2^8-1\n无符号数的范围相当于是有符号数的两倍。\nmysql&gt; create table test1(    -&gt; age tinyint unsigned    -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (128);Query OK, 1 row affected (0.00 sec)\n\n\n\n\n\n\n\n\n\n\n\n","categories":[],"tags":[]},{"title":"常用工具","url":"http://example.com/2017/12/14/hhhhh你骄傲 - 副本/","content":"Lesson_2MySql-22.校对集在某种字符集下，字符和字符的关系称为校对集。比如(ASCII)a和B的大小关系，如果区分大小写a&gt;B，如果不区分大小写a&lt;B\n不同的校对集的比较规则不一样。\n在定义表的时候可以指定校对集\n&lt;!--more--&gt;\n\n#utf8_general_ci  使用_ci这种校对集不区分大小写create table t1(name char(1))charset&#x3D;utf8 collate&#x3D;utf8_general_ci;create table t2(name char(1))charset&#x3D;utf8 collate&#x3D;utf8_bin;insert into t1 values (&#39;a&#39;),(&#39;B&#39;);insert into t2 values (&#39;a&#39;),(&#39;B&#39;);\n\nmysql&gt; select * from t1 order by name;+------+| name |+------+| a    || B    |+------+2 rows in set (0.00 sec)#排序查询以后没有区分大小写说明a和b不区分大小写;\n\nmysql&gt; select * from t2 order by name;+------+| name |+------+| B    || a    |+------+2 rows in set (0.00 sec)#按照正序排列,对照ASCLL编码,B&lt;a,B在a前面那么这种二进制校对集区分大小写;\n\n牢记:_bin：按二进制编码比较_ci：不区分大小写比较\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(2)unsigned  (无符号)一个数是无符号数，那么这个数肯定是非负数\n数据库mysql第一条记录一定是1(起码是),绝对不能是0\ntinyint unsigned   2^8-1\n无符号数的范围相当于是有符号数的两倍。\nmysql&gt; create table test1(    -&gt; age tinyint unsigned    -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (128);Query OK, 1 row affected (0.00 sec)\n\n\n\n\n\n\n\n\n\n\n\n","categories":[],"tags":[]}]