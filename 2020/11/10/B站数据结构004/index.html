<!DOCTYPE html>
<html  lang="en" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="当咸鱼,不存在!!!">
  <link rel="icon" href="/img/Kaze.png">
  <title>数据结构和算法--004--链表</title>
  
  
  <meta property="og:title" content="数据结构和算法--004--链表">
  
  
  <meta property="og:url" content="http://example.com/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/index.html">
  
  
  <meta property="og:img" content="/img/Kaze.png">
  
  
  <meta property="og:img" content="&lt;h2 id=&#34;链表&#34;&gt;&lt;a href=&#34;#链表&#34; class=&#34;headerlink&#34; title=&#34;链表&#34;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;链表是有序的列表， 但是它在内存中是存储如下  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链表是以节点的方式来储存.链式储存&lt;/li&gt;
&lt;li&gt;每个节点包含data 域， next 域： 指向下一个节点  &lt;/li&gt;
&lt;li&gt;如图： 发现链表的各个节点不一定是连续存储.  &lt;/li&gt;
&lt;li&gt;链表分带头节点的链表和没有头节点的链表， 根据实际的需求来确定  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;单链表(带头结点) 逻辑结构示意图如下&lt;/strong&gt;  &lt;/p&gt;">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2020-11-10">
  <meta property="og:article:modified_time" content="2020-11-10">
  <meta property="og:article:author" content="theme-kaze">
  
  
  <meta property="og:article:tag" content="数据结构">
  
  <meta property="og:article:tag" content="队列">
  
  <meta property="og:article:tag" content="链表">
  
  
  
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/Kaze.png" alt="logo">
      
      <span class="navbar-logo-dsc">theme-kaze demo</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    Home
    
    </a>
    
    <a href="/archives" class="navbar-menu-item">
    
    Archive
    
    </a>
    
    <a href="/tags" class="navbar-menu-item">
    
    Tags
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    Categories
    
    </a>
    
    <a href="/about" class="navbar-menu-item">
    
    About
    
    </a>
    
    <a href="/links" class="navbar-menu-item">
    
    Friends
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      数据结构和算法--004--链表
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2020-11-10T15:10:58.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2020-11-10</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/数据结构和算法-体系/" class="post-meta-link">-数据结构和算法-体系</a>
    
    
    
    <span class="dot"></span>
    <span>3.8k words</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/数据结构/" class="post-meta-link">数据结构</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/队列/" class="post-meta-link">队列</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/链表/" class="post-meta-link">链表</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是有序的列表， 但是它在内存中是存储如下  </p>
<ol>
<li>链表是以节点的方式来储存.链式储存</li>
<li>每个节点包含data 域， next 域： 指向下一个节点  </li>
<li>如图： 发现链表的各个节点不一定是连续存储.  </li>
<li>链表分带头节点的链表和没有头节点的链表， 根据实际的需求来确定  </li>
</ol>
<p><strong>单链表(带头结点) 逻辑结构示意图如下</strong>  </p>
 <a id="more"></a> 





<p><img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/11.png" alt="11" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/11.png" class="lozad post-image"></p>
<p><img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/22.png" alt="22" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/22.png" class="lozad post-image"></p>
<h2 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h2><h3 id="第一种方法在添加英雄时，-直接添加到链表的尾部"><a href="#第一种方法在添加英雄时，-直接添加到链表的尾部" class="headerlink" title="第一种方法在添加英雄时， 直接添加到链表的尾部"></a><strong>第一种方法在添加英雄时， 直接添加到链表的尾部</strong></h3><p><strong>不考虑顺序编号</strong></p>
<ol>
<li>找的当前链表的最后节点</li>
<li>将最后这个节点的next指向新的节点</li>
<li><strong>将最后这个节点的next指向新的节点      temp.next = heroNode;</strong></li>
</ol>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//头节点不能动,需要一个辅助遍历temp</span></span><br><span class="line">      HeroNode temp = head;</span><br><span class="line">      <span class="comment">//遍历链表到最后</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果没有找的,将temp后移</span></span><br><span class="line">          temp = temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//当退出while循环,temp就指向链表的最后</span></span><br><span class="line">      <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">      temp.next = heroNode;</span><br><span class="line">  &#125;</span><br></pre>

<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/33.png" alt="33" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/33.png" class="lozad post-image">

<h3 id="第二种方式在添加英雄时，根据排名将英雄插入到指定位置"><a href="#第二种方式在添加英雄时，根据排名将英雄插入到指定位置" class="headerlink" title="第二种方式在添加英雄时，根据排名将英雄插入到指定位置"></a><strong>第二种方式在添加英雄时，根据排名将英雄插入到指定位置</strong></h3><ol>
<li>因为头节点不能动，因此我们仍然通过一个辅助指针(变量)</li>
<li>因为单链表,我们找的temp是位于添加位置的前一个节点,否则插入失败</li>
<li>temp = temp.next;</li>
<li>插入到链表中, temp的后面</li>
<li>heroNode.next = temp.next;</li>
<li>temp.next = heroNode;</li>
</ol>
<pre class="highlight"><span class="line">   HeroNode temp = head;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//说明已经在链表最后了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////位置找到，就在temp的后面插入</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>; <span class="comment">//说明编号存在</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        System.out.println(heroNode.no + <span class="string">&quot;该编号存在&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//插入到链表中, temp的后面</span></span><br><span class="line">        heroNode.next = temp.next;</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/44.png" alt="44" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/44.png" class="lozad post-image">



<h3 id="修改节点的信息"><a href="#修改节点的信息" class="headerlink" title="修改节点的信息"></a>修改节点的信息</h3><ul>
<li>根据 newHeroNode 的 no 来修改即可</li>
<li>找到需要修改的节点, 根据no编号定义一个辅助变量</li>
<li>找到该节点</li>
<li>根据flag 判断是否找到要修改的节点</li>
<li>temp.name = newHeroNode.name;</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment">//修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;此节点为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要修改的节点,根据no修改</span></span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//遍历完毕</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否是要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = heroNode.name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到要修改的编号&quot;</span> + heroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>

<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/55.png" alt="55" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/55.png" class="lozad post-image">



<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</li>
<li>说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</li>
<li>遍历链表,找到对应的链表</li>
<li>temp.next = temp.next.next;</li>
</ul>
<pre class="highlight"><span class="line"><span class="number">1.</span>head不能动,需要一个辅助变量temp 辅助节点找到要删除的节点</span><br><span class="line">   <span class="number">1.</span>我们在比较的时候只需要找到temp.next.no 和要需要的no作比较</span><br><span class="line">    */</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//找到要修改的节点,根据no修改</span></span><br><span class="line">       <span class="comment">//定义一个辅助变量</span></span><br><span class="line">       HeroNode temp = head;</span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123; <span class="comment">//已经到链表的最后</span></span><br><span class="line">               <span class="keyword">break</span>;<span class="comment">//遍历完毕</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">               <span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">           temp.next = temp.next.next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;要删除的节点不在&quot;</span> + no);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre>



<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/66.png" alt="66" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/66.png" class="lozad post-image">



<h3 id="获取到单链表的节点个数-不统计头节点"><a href="#获取到单链表的节点个数-不统计头节点" class="headerlink" title="获取到单链表的节点个数(不统计头节点)"></a>获取到单链表的节点个数(不统计头节点)</h3><ul>
<li>定义一个辅助变量</li>
<li>cur = cur.next;//遍历</li>
</ul>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义一个辅助变量</span></span><br><span class="line">    HeroNode cur = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur = cur.next;<span class="comment">//遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre>

<h3 id="查找单链表中的倒数第k个结点"><a href="#查找单链表中的倒数第k个结点" class="headerlink" title="查找单链表中的倒数第k个结点"></a>查找单链表中的倒数第k个结点</h3><ol>
<li>编写一个方法接受head节点,同时接收一个index</li>
<li>index 表示说倒数index个系欸但</li>
<li>得到链表的总的长度 getLength</li>
<li>得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</li>
<li>如果找到了，则返回该节点，否则返回nulll</li>
</ol>
<pre class="highlight"><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment">   思路:</span></span><br><span class="line"><span class="comment">   1.编写一个方法接受head节点,同时接收一个index</span></span><br><span class="line"><span class="comment">   2.index 表示说倒数index个系欸但</span></span><br><span class="line"><span class="comment">   3.得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">   4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">   5.如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空 返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历得到其长度</span></span><br><span class="line">        <span class="keyword">int</span> size = getLength(head);</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助遍历 cur, 通过 size-index 确定其位置</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取到单链表的节点个数(不统计头节点)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;<span class="comment">//遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>

<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/77.png" alt="77" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/77.png" class="lozad post-image">

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><ol>
<li><p>//设置一个辅助遍历 cur 用来遍历    HeroNode cur = head.next;</p>
</li>
<li><p>//用来存放cur的下一个结点,辅助遍历   HeroNode next = null; 特别注意</p>
</li>
<li><p>设置一个新链表每取出一个链表的头结点,每次放到新链表reverseHead的头部</p>
</li>
<li><p>暂时保存cur下一个节点</p>
<pre class="highlight"><span class="line"><span class="comment">//必须保存 保存的是被反转的下一个的节点</span></span><br><span class="line"><span class="comment">/** 这种必然失败</span></span><br><span class="line"><span class="comment">cur.next=reverseHead.next;</span></span><br><span class="line"><span class="comment">reverseHead.next=cur;</span></span><br><span class="line"><span class="comment">cur= cur.next;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre>
</li>
<li><p>暂时保存cur下一个节点next=cur.next;//</p>
</li>
<li><p>将cur的下一个节点指向新的链表的最前端cur.next=reverseHead.next;//</p>
</li>
<li><p>将cur 连接到新的链表上reverseHead.next=cur;//</p>
</li>
<li><p>将暂时保存cur下一个的节点归还给curcur= next; //</p>
</li>
<li><p>将head.next 指向 reverseHead.next , 实现单链表的反转  head.next = reverseHead.next;             </p>
</li>
</ol>
<pre class="highlight"><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//当前链表为空</span></span><br><span class="line">     <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//设置一个辅助遍历 cur 用来遍历</span></span><br><span class="line">     HeroNode cur = head.next;</span><br><span class="line">     <span class="comment">//用来存放cur的下一个结点,辅助遍历</span></span><br><span class="line">     HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//设置一个新链表</span></span><br><span class="line">     HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">     <span class="comment">//每取出一个链表的头结点,每次放到新链表reverseHead的头部</span></span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">//必须保存 保存的是被反转的下一个的节点</span></span><br><span class="line">         <span class="comment">/** 这种必然失败</span></span><br><span class="line"><span class="comment">          cur.next=reverseHead.next;</span></span><br><span class="line"><span class="comment">          reverseHead.next=cur;</span></span><br><span class="line"><span class="comment">          cur= cur.next;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         next=cur.next;<span class="comment">//暂时保存cur下一个节点</span></span><br><span class="line">         cur.next=reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">         reverseHead.next=cur;<span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">         cur= next; <span class="comment">//将暂时保存cur下一个的节点归还给cur</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">     head.next = reverseHead.next;</span><br><span class="line"> &#125;</span><br></pre>

<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/88.png" alt="88" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/88.png" class="lozad post-image">

<h3 id="逆序打印"><a href="#逆序打印" class="headerlink" title="逆序打印"></a>逆序打印</h3><ul>
<li>思路一: 将其反转,然后打印,这样会破环链表的本身结构,不利后续的操作</li>
<li>思路二: 利用栈的这个数据结构的特殊性,先进后出,将各个节点的数据压入到栈中,然后将其输出就可以</li>
</ul>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">reversePrint</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建一个栈,将各各节点的数据压入栈中</span></span><br><span class="line">       Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="comment">//辅助遍历进行操作</span></span><br><span class="line">       HeroNode cur =head.next;</span><br><span class="line">       <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(cur);</span><br><span class="line">           cur=cur.next;<span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将栈中的节点进行打印,pop 出栈</span></span><br><span class="line">       <span class="keyword">while</span> ((stack.size()&gt;<span class="number">0</span>))&#123;</span><br><span class="line">           System.out.println(stack.pop());<span class="comment">//stack的特点是先进后出</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre>

<img src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/99.png" alt="99" style="zoom:80%;" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/99.png" class="lozad post-image">

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="highlight"><span class="line"><span class="keyword">package</span> com.nie.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;黎明&quot;</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">&quot;张学友&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkList singleLinkList = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">        <span class="comment">//增加结点</span></span><br><span class="line">        <span class="comment">//根据插入的顺序进行插入</span></span><br><span class="line">        singleLinkList.add(hero1);</span><br><span class="line">        singleLinkList.add(hero2);</span><br><span class="line">        singleLinkList.add(hero3);</span><br><span class="line">        singleLinkList.add(hero4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加结点</span></span><br><span class="line">        <span class="comment">//根据节点的编号进行插入</span></span><br><span class="line"><span class="comment">//        singleLinkList.addByOrder(hero1);</span></span><br><span class="line"><span class="comment">//        singleLinkList.addByOrder(hero2);</span></span><br><span class="line"><span class="comment">//        singleLinkList.addByOrder(hero4);</span></span><br><span class="line"><span class="comment">//        singleLinkList.addByOrder(hero3);</span></span><br><span class="line">        singleLinkList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------逆序----------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;逆序打印单链表, 没有改变链表的结构~~&quot;</span>);</span><br><span class="line">        reversePrint(singleLinkList.getHead());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------反转----------&quot;</span>);</span><br><span class="line">        reverList(singleLinkList.getHead());</span><br><span class="line">        singleLinkList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------修改-----------&quot;</span>);</span><br><span class="line">        HeroNode newHeroNode = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;舞王郭富城&quot;</span>);</span><br><span class="line">        singleLinkList.update(newHeroNode);</span><br><span class="line">        singleLinkList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------删除-----------&quot;</span>);</span><br><span class="line">        singleLinkList.del(<span class="number">1</span>);</span><br><span class="line">        singleLinkList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;有效结点的个数&quot;</span> + getLength(singleLinkList.getHead()));</span><br><span class="line">        <span class="comment">//测试第倒数几的结点的</span></span><br><span class="line">        <span class="keyword">int</span> indexLast = <span class="number">1</span>;</span><br><span class="line">        HeroNode res = findLastIndexNode(singleLinkList.getHead(), indexLast);</span><br><span class="line">        System.out.println(<span class="string">&quot;倒数第&quot;</span> + indexLast + <span class="string">&quot;的结点为&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆序打印</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路一: 将其反转,然后打印,这样会破环链表的本身结构,不利后续的操作</span></span><br><span class="line"><span class="comment">    思路二: 利用栈的这个数据结构,将各个节点的数据压入到栈中,然后将其输出就可以</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个栈,将各各节点的数据压入栈中</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//辅助遍历进行操作</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;<span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈中的节点进行打印,pop 出栈</span></span><br><span class="line">        <span class="keyword">while</span> ((stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(stack.pop());<span class="comment">//stack的特点是先进后出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前链表为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置一个辅助遍历 cur 用来遍历</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="comment">//用来存放cur的下一个结点,辅助遍历</span></span><br><span class="line">        HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//设置一个新链表</span></span><br><span class="line">        HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//每取出一个链表的头结点,每次放到新链表reverseHead的头部</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//必须保存 保存的是被反转的下一个的节点</span></span><br><span class="line">            <span class="comment">/** 这种必然失败</span></span><br><span class="line"><span class="comment">             cur.next=reverseHead.next;</span></span><br><span class="line"><span class="comment">             reverseHead.next=cur;</span></span><br><span class="line"><span class="comment">             cur= cur.next;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            next = cur.next;<span class="comment">//暂时保存cur下一个节点</span></span><br><span class="line">            cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            reverseHead.next = cur;<span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">            cur = next; <span class="comment">//将暂时保存cur下一个的节点归还给cur</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment">   思路:</span></span><br><span class="line"><span class="comment">   1.编写一个方法接受head节点,同时接收一个index</span></span><br><span class="line"><span class="comment">   2.index 表示说倒数index个系欸但</span></span><br><span class="line"><span class="comment">   3.得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">   4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">   5.如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空 返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历得到其长度</span></span><br><span class="line">        <span class="keyword">int</span> size = getLength(head);</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助遍历 cur, 通过 size-index 确定其位置</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取到单链表的节点个数(不统计头节点)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;<span class="comment">//遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化一个头节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">////添加节点到单向链表</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不考虑顺序编号</span></span><br><span class="line"><span class="comment">    1.找的当前链表的最后节点</span></span><br><span class="line"><span class="comment">    2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头节点不能动,需要一个辅助遍历temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找的,将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环,temp就指向链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)</span></span><br><span class="line">        <span class="comment">//因为单链表,我们找的temp是位于添加位置的前一个节点,否则插入失败</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//说明已经在链表最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//说明编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(heroNode.no + <span class="string">&quot;该编号存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中, temp的后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;此节点为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要修改的节点,根据no修改</span></span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//遍历完毕</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否是要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = heroNode.name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到要修改的编号&quot;</span> + heroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路</span></span><br><span class="line"><span class="comment">    1.head不能动,需要一个辅助变量temp 辅助节点找到要删除的节点</span></span><br><span class="line"><span class="comment">    1.我们在比较的时候只需要找到temp.next.no 和要需要的no作比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找到要修改的节点,根据no修改</span></span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123; <span class="comment">//已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//遍历完毕</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要删除的节点不在&quot;</span> + no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>


  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="http://example.com/about">theme-kaze</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="http://example.com/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/">http://example.com/2020/11/10/B%E7%AB%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84004/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2020/11/13/LC031-081-153-154-二分查找扩展/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">Prev</div>
        
        <div class="nav-title">二分查找扩展(搜索旋转排序数组)-033-081-153-154 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2020/11/09/LC031-1109-下一个排序/" class="nav-link">
      <div>
        <div class="nav-label">Next</div>
        
        <div class="nav-title">下一个排序--031 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">单链表的应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%97%B6%EF%BC%8C-%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E9%83%A8"><span class="toc-text">第一种方法在添加英雄时， 直接添加到链表的尾部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%97%B6%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E5%B0%86%E8%8B%B1%E9%9B%84%E6%8F%92%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-text">第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">修改节点的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E4%B8%8D%E7%BB%9F%E8%AE%A1%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-text">获取到单链表的节点个数(不统计头节点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">查找单链表中的倒数第k个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="toc-text">逆序打印</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/Kaze.png" class="author-img">

<p class="author-name">theme-kaze</p>
<p class="author-description">designed by theme-kaze</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>138</span>
    <span>Posts</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>10</span>
    <span>Categories</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>62</span>
    <span>Tags</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">单链表的应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%97%B6%EF%BC%8C-%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E9%83%A8"><span class="toc-text">第一种方法在添加英雄时， 直接添加到链表的尾部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%97%B6%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E5%B0%86%E8%8B%B1%E9%9B%84%E6%8F%92%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-text">第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">修改节点的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E4%B8%8D%E7%BB%9F%E8%AE%A1%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-text">获取到单链表的节点个数(不统计头节点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">查找单链表中的倒数第k个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="toc-text">逆序打印</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>Categories</div>
  <div class="categories-list">
    
      <a href="/categories/-数据结构和算法-体系">
        <div class="categories-list-item">
          -数据结构和算法-体系
          <span class="categories-list-item-badge">9</span>
        </div>
      </a>
    
      <a href="/categories/-前端">
        <div class="categories-list-item">
          -前端
          <span class="categories-list-item-badge">10</span>
        </div>
      </a>
    
      <a href="/categories/-JDBC">
        <div class="categories-list-item">
          -JDBC
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/-JQuery">
        <div class="categories-list-item">
          -JQuery
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/-JavaScript">
        <div class="categories-list-item">
          -JavaScript
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/-算法">
        <div class="categories-list-item">
          -算法
          <span class="categories-list-item-badge">60</span>
        </div>
      </a>
    
      <a href="/categories/-javase">
        <div class="categories-list-item">
          -javase
          <span class="categories-list-item-badge">31</span>
        </div>
      </a>
    
      <a href="/categories/-工具栏">
        <div class="categories-list-item">
          -工具栏
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/-操作系统">
        <div class="categories-list-item">
          -操作系统
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/-计算机网络">
        <div class="categories-list-item">
          -计算机网络
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>hot tags</div>
  <div class="tags-list">
    
    <a href="\tags\LeetCode" title="LeetCode"><div class="tags-list-item">LeetCode</div></a>
    
    <a href="\tags\基础" title="基础"><div class="tags-list-item">基础</div></a>
    
    <a href="\tags\java" title="java"><div class="tags-list-item">java</div></a>
    
    <a href="\tags\面试" title="面试"><div class="tags-list-item">面试</div></a>
    
    <a href="\tags\排序" title="排序"><div class="tags-list-item">排序</div></a>
    
    <a href="\tags\十大排序" title="十大排序"><div class="tags-list-item">十大排序</div></a>
    
    <a href="\tags\数据结构" title="数据结构"><div class="tags-list-item">数据结构</div></a>
    
    <a href="\tags\网络" title="网络"><div class="tags-list-item">网络</div></a>
    
    <a href="\tags\双指针" title="双指针"><div class="tags-list-item">双指针</div></a>
    
    <a href="\tags\二叉树" title="二叉树"><div class="tags-list-item">二叉树</div></a>
    
    <a href="\tags\链表" title="链表"><div class="tags-list-item">链表</div></a>
    
    <a href="\tags\常用10种算法" title="常用10种算法"><div class="tags-list-item">常用10种算法</div></a>
    
    <a href="\tags\链表反转" title="链表反转"><div class="tags-list-item">链表反转</div></a>
    
    <a href="\tags\JavaWeb" title="JavaWeb"><div class="tags-list-item">JavaWeb</div></a>
    
    <a href="\tags\JavaScript" title="JavaScript"><div class="tags-list-item">JavaScript</div></a>
    
    <a href="\tags\CSS" title="CSS"><div class="tags-list-item">CSS</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">单链表的应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%97%B6%EF%BC%8C-%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E9%83%A8"><span class="toc-text">第一种方法在添加英雄时， 直接添加到链表的尾部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%97%B6%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E5%B0%86%E8%8B%B1%E9%9B%84%E6%8F%92%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-text">第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">修改节点的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E4%B8%8D%E7%BB%9F%E8%AE%A1%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-text">获取到单链表的节点个数(不统计头节点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">查找单链表中的倒数第k个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="toc-text">逆序打印</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>Recent Posts</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-08</div>
        <a href="/2021/01/08/JQuery-02/"><div class="recent-posts-item-content">JQuery-02JQuery选择器(重点)</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-07</div>
        <a href="/2021/01/07/JQuery-01/"><div class="recent-posts-item-content">JQuery-01概论</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-06</div>
        <a href="/2021/01/06/常用正则/"><div class="recent-posts-item-content">常用正则写法</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-05</div>
        <a href="/2021/01/05/JS-05/"><div class="recent-posts-item-content">JS-05-JavaScript 正则表达式</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2021
        </span>
        &nbsp;
        <a href="/" class="footer-link">theme-kaze demo </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>