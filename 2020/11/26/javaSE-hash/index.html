<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>javaSE-hash | WenZhao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="hash基础java" />
  
  
  
  
  <meta name="description" content="哈希表总结哈希表记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。 因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。 若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。 在此，称这个对应关系f为哈希函数，按这个思想建立的表为哈希表（又称为杂凑法或散列表。 哈希表不可避免冲突（coll">
<meta property="og:type" content="article">
<meta property="og:title" content="javaSE-hash">
<meta property="og:url" content="http://example.com/2020/11/26/javaSE-hash/index.html">
<meta property="og:site_name" content="WenZhao">
<meta property="og:description" content="哈希表总结哈希表记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。 因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。 若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。 在此，称这个对应关系f为哈希函数，按这个思想建立的表为哈希表（又称为杂凑法或散列表。 哈希表不可避免冲突（coll">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/1.webp">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/2.webp">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/4.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/222.svg">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/5.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/6.webp">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/7.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/8.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/9.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/10.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/11.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/12.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/13.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/14.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/15.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/16.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/17.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/18.png">
<meta property="og:image" content="http://example.com/2020/11/26/javaSE-hash/19.png">
<meta property="article:published_time" content="2020-11-26T10:49:45.000Z">
<meta property="article:modified_time" content="2020-11-26T11:00:13.271Z">
<meta property="article:author" content="niewenzhao">
<meta property="article:tag" content="hash">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/26/javaSE-hash/1.webp">
  
    <link rel="alternate" href="/atom.xml" title="WenZhao" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 5.2.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/pose01.jpg,https://source.unsplash.com/collection/954550/1920x1080,https://source.unsplash.com/collection/954550/1920x1081".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="WenZhao" rel="home"> WenZhao </a>
            
          </h1>
          
          
            <div class="site-description">当咸鱼,不存在!!!</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="/"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="archives"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="categories"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="tags"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="about"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-javaSE-hash" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      javaSE-hash
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/11/26/javaSE-hash/" class="article-date">
	  <time datetime="2020-11-26T10:49:45.000Z" itemprop="datePublished">November 26, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/javase/">-javase</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="哈希表总结"><a href="#哈希表总结" class="headerlink" title="哈希表总结"></a>哈希表总结</h1><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。</p>
<p>因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。</p>
<p>若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。</p>
<p>在此，称这个对应关系f为哈希函数，按这个思想建立的表为哈希表（又称为杂凑法或散列表。</p>
<h3 id="哈希表不可避免冲突（collision）现象："><a href="#哈希表不可避免冲突（collision）现象：" class="headerlink" title="哈希表不可避免冲突（collision）现象："></a>哈希表不可避免冲突（collision）现象：</h3><ul>
<li><p>对不同的关键字可能得到同一哈希地址 即key1≠key2，而hash(key1)=hash(key2）。</p>
</li>
<li><p>具有相同函数值的关键字对该哈希函数来说称为同义词（synonym）。</p>
<a id="more"></a> 
</li>
<li><p>因此，在建造哈希表时不仅要设定一个好的哈希函数，而且要设定一种处理冲突的方法。</p>
</li>
<li><p>可如下描述哈希表：根据设定的哈希函数H(key）和所选中的处理冲突的方法，</p>
</li>
<li><p>将一组关键字<strong>映象</strong>到一个有限的、地址连续的地址集（区间）上并以关键字在地址集中的“象”作为相应记录在表中的存储位置，这种表被称为哈希表。</p>
</li>
</ul>
<img src="/2020/11/26/javaSE-hash/1.webp" alt="1" style="zoom:80%;">

<h2 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h2><p>散列表(也叫哈希表,Hash table) ,是根据关键码的值进行访问的数据结构.散列表的实现常常叫做<strong>散列（hasing）</strong>,散列是一种用于以<strong>常数平均时间</strong>执行插入,删除和查找的技术</p>
<p>整个散列过程分为两步</p>
<ol>
<li><p>通过散列函数计算记录的散列地址,并按照散列地址储存该记录</p>
<p>无论什么记录我们都需要用<strong>同一个散列函数</strong>计算地址，然后再存储。</p>
</li>
<li><p>查找通过同样的散列函数计算记录的散列地址,按此散列地址访问该记录.因为我们存和取的时候用的都是一个散列函数，因此结果肯定相同。</p>
</li>
</ol>
<p>散列函数是什么呢？</p>
<ul>
<li>假设某个函数为 <strong>f</strong>，使得 <strong>存储位置 = f (key)</strong> 那样我们就能通过查找关键字<strong>不需要比较</strong>就可获得需要的记录的存储位置。这种存储技术被称为散列技术。散列技术是在通过记录的存储位置和它的关键字之间建立一个确定的对应关系 f ,使得每个关键字 key 都对应一个存储位置 f(key)</li>
</ul>
<p>这里的<strong>f</strong>就是我们所描述的哈希函数(散列函数),我们利用散列技术将记录储存在一块连续的储存空间中,这块连续的储存空间就是—-(哈希)散列</p>
<p>对不同的关键字可能得到同一散列地址，即<strong>k1≠k2</strong>，而**f(k1)=f(k2)**，这种现象称为冲（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。对于这种情况我们能找到有效的方法解决</p>
<h3 id="哈希函数的特殊性"><a href="#哈希函数的特殊性" class="headerlink" title="哈希函数的特殊性:"></a>哈希函数的特殊性:</h3><p>创建哈希函数是必须遵循一下原则:</p>
<ol>
<li><p>必须一致性</p>
<p>无论什么记录我们都需要用<strong>同一个散列函数</strong>计算地址</p>
</li>
<li><p>计算简单</p>
<p>在保证不哈希冲突的情况下,使得计算简单,如果这个算法计算复杂，会耗费很多时间.<strong>散列函数的计算时间不应该超过其他查找技术与关键字的比较时间</strong>，不然的话我们干嘛使用哈希技术了</p>
</li>
<li><p>散列地址分布均匀</p>
<p>让散列地址尽量均匀分布在储存空间中,这样既保证了空间的有效性,有减少了处理冲突而消耗的时间</p>
</li>
</ol>
<hr>

<h3 id="散列函数构造方法"><a href="#散列函数构造方法" class="headerlink" title="散列函数构造方法"></a>散列函数构造方法</h3><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法:"></a>直接定址法:</h4><ol>
<li>取关键字或关键字的某个线性函数值为散列地址。</li>
<li>即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。</li>
<li>若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</li>
</ol>
<p><img src="/2020/11/26/javaSE-hash/2.webp" alt="2"></p>
<p><strong>优点</strong>:</p>
<ul>
<li>简单,均匀,无冲突</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>需要事先知道关键字的分布情况，适合查找表较小且连续的情况</li>
</ul>
<hr>

<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><ol>
<li>该方法也是十分简单的方法，就是分析我们的关键字，取其中一段，或对其位移，叠加，用作地址</li>
<li>比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成<strong>散列地址</strong>，则冲突的几率会明显降低。</li>
<li>因此<strong>数字分析法就是找出数字的规律</strong>，尽可能利用这些数据来构造冲突几率较低的散列地址。</li>
</ol>
<p>优点：</p>
<ul>
<li>简单、均匀、适用于关键字位数较大的情况</li>
</ul>
<p>应用场景：</p>
<ul>
<li>关键字位数较大，知道关键字分布情况且关键字的若干位较均匀</li>
</ul>
<hr>

<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><ol>
<li>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。</li>
<li>比如我们的关键字是123456789，则我们分为三部分 123 ，456 ，789 然后将其相加得 1368 然后我们再取其后三位 368 作为我们的散列地址。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>事先不需要知道关键字情况</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适合关键字位数较多的情况</li>
</ul>
<hr>

<h4 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h4><ol>
<li>在用来设计散列函数的除法散列法中,通过取key除p的余数,将关键字映射到某一个上,对于散列表长度为 m 的散列函数公式为</li>
<li><strong>f(k) = k mod p  (p &lt;= m)</strong></li>
</ol>
<p><strong>如</strong></p>
<p>如果散列表长度为 12，即 m = 12 ，我们的参数 p 也设为12，那 k = 100时 f(k) = 100 % 12 = 4</p>
<p>我们只需要做一次除法操作,所以除法散列法非常快</p>
<p>由上面的公式可以看出，该方法的重点在于 p 的取值，如果 p 值选的不好，就可能会容易产生同义词(<strong>哈希冲突</strong>)。见下面这种情况。我们哈希表长度为6，我们选择6为p值，则有可能产生这种情况，所有关键字都得到了0这个地址数。</p>
<img src="/2020/11/26/javaSE-hash/4.png" alt="4" style="zoom:80%;">

<p>那我们在选用除法散列法时选取 p 值时应该遵循怎样的规则呢？</p>
<ol>
<li>m 不应为 2 的幂，因为如果 m = 2^p ，则 f(k) 就是 k 的 p 个最低位数字。例 12 % 8 = 4 ，12的二进制表示位1100，后三位为100。</li>
<li>若散列表的长度为m,通常p为小于或者等于表长(接近)的最小质数或者包含不小于20质因子的合数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">合数：合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。</span><br><span class="line"></span><br><span class="line">质因子：质因子（或质因数）在数论里是指能整除给定正整数的质数。</span><br></pre></td></tr></table></figure>





<img src="/2020/11/26/javaSE-hash/222.svg" alt="222" style="zoom:80%;">

<p><em>注：这里的2，3，5为质因子</em></p>
<p>根据规则选择 5 为 p 值，我们再来看。这时我们发现只有 6 和 36 冲突，相对来说就好了很多。</p>
<img src="/2020/11/26/javaSE-hash/5.png" alt="5" style="zoom:80%;">

<p>优点:</p>
<ul>
<li>计算效率高,灵活</li>
</ul>
<p>应用场景:</p>
<ul>
<li>不知道关键字分布情况</li>
</ul>
<hr>

<h4 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h4><p>构造散列函数的乘法散列法主要包含两个步骤</p>
<ul>
<li>用关键字 k 乘上常数 A(0 &lt; A &lt; 1)，并提取 k A 的小数部分</li>
<li>用 m 乘以这个值，再向下取整</li>
</ul>
<p>散列函数为:</p>
<p><strong>f (k) = ⌊ m(kA mod 1) ⌋</strong></p>
<p>这里的 <strong>kA mod 1</strong> 的含义是取 keyA 的小数部分，即 <strong>kA - ⌊kA⌋</strong> 。</p>
<p>优点：对 m 的选择不是特别关键一般选择它为 2 的某个幂次（m = 2 ^ p ,p为某个整数）</p>
<p>应用场景：不知道关键字情况</p>
<hr>

<h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><ul>
<li>这个方法就比较简单了，假设关键字是 321，那么他的平方就是 103041，再抽取中间的 3 位就是 030 或 304 用作散列地址。</li>
<li>再比如关键字是 1234  那么它的平方就是 1522756 ，抽取中间 3 位就是 227 用作散列地址.</li>
</ul>
<p><strong>优点</strong>：</p>
<p>灵活，适用范围广泛</p>
<p><strong>适用场景</strong>：</p>
<p>不知道关键字分布，而位数又不是很大的情况</p>
<hr>



<h4 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h4><p>选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。</p>
<h3 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h3><p>hash 函数之后发现关键字 key1 不等于 key2 ，但是 f(key1) = f(key2)，即有冲突，</p>
<h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>一旦发生冲突,就会寻找下一个空的散列地址,只要列表足够大,空的散列地址总能找到,并将记录存入,为了使用开放寻址法插入一个元素,需要连续检查散列表,称为<strong>探查</strong>,我们常用的有<strong>线性探测，二次探测，随机探测</strong>。</p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><img src="/2020/11/26/javaSE-hash/6.webp" alt="6" style="zoom:80%;">



<p>我们来看一个例子，我们的关键字集合为{12，67，56，16，25，37，22，29，15，47，48，21}，表长为12，我们再用散列函数 <strong>f(key) =  key mod 12。</strong></p>
<p>我们求出每个 key 的 f(key)见下表</p>
<img src="/2020/11/26/javaSE-hash/7.png" alt="7" style="zoom:80%;">



<p>我们查看上表发现，前五位的 <strong>f(key)</strong> 都不相同，即没有冲突，可以直接存入，但是到了第六位 <strong>f(37) = f(25) = 1</strong>,那我们就需要利用上面的公式 <strong>f(37)  = f (f(37) + 1 ) mod 12 = 2</strong>，这其实就是我们的订包间的做法。下面我们看一下将上面的所有数存入哈希表是什么情况吧。</p>
<p>注：蓝色为计算哈希值，红色为存入哈希表</p>
<img src="/2020/11/26/javaSE-hash/8.png" alt="8" style="zoom:80%;">



<p>他第一次会落在下标为 10 的位置，那么如果继续使用线性探测的话，则需要通过不断取余后得到结果，数据量小还好，要是很大的话那也太慢了吧，但是明明他的前面就有一个空房间呀，如果向前移动只需移动一次即可。</p>
<img src="/2020/11/26/javaSE-hash/9.png" alt="9" style="zoom:80%;">

<h5 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h5><p>其实理解了我们的上个例子之后，这个一下就能整明白了，根本不用费脑子，这个方法就是更改了一下di的取值</p>
<img src="/2020/11/26/javaSE-hash/10.png" alt="10" style="zoom:80%;">

<p>注：这里的是 -1^2  为负值 而不是 （-1)^2</p>
<p>所以对于我们的34来说，当di = -1时，就可以找到空位置了。<img src="/2020/11/26/javaSE-hash/11.png" alt="11"></p>
<p>二次探测法的目的就是为了不让关键字聚集在某一块区域。另外还有一种有趣的方法，位移量采用随机函数计算得到，接着往下看吧.</p>
<h5 id="随机探测法"><a href="#随机探测法" class="headerlink" title="随机探测法"></a>随机探测法</h5><p>大家看到这是不又有新问题了，刚才我们在散列函数构造规则的第一条中说</p>
<p>（1）<strong>必须是一致的</strong></p>
<p>我们 di 是随机生成的呀，这里的随机其实是伪随机数，伪随机数含义为，我们设置<strong>随机种子</strong>相同，则不断调用随机函数可以生成<strong>不会重复的数列</strong>，我们在查找时，<strong>用同样的随机种子</strong>，<strong>它每次得到的数列是相同的</strong>，那么相同的 di 就能得到<strong>相同的散列地址</strong>。</p>
<img src="/2020/11/26/javaSE-hash/12.png" alt="12" style="zoom:80%;">



<img src="/2020/11/26/javaSE-hash/13.png" alt="13" style="zoom:80%;">



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">随机种子（Random Seed）是计算机专业术语，一种以随机数作为对象的以真随机数（种子）为初始条件的随机数。一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数</span><br></pre></td></tr></table></figure>



<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>这个方法其实也特别简单，利用不同的哈希函数再求得一个哈希地址，直到不出现冲突为止。</p>
<p><strong>f,(key) = RH,( key )   (i = 1,2,3,4…..k)</strong></p>
<p>这里的RH就是不同的散列函数,可以把我们之前说的那些散列函数都用上,每当发生哈希冲突时就换一个散列函数，相信总有一个能够解决冲突的。这样的代价就是增加了计算时间</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><ol>
<li>key 不同 f(key) 相同的情况,我们将这些同义词储存在一个单链表,这种表叫做同义词子表.散列表中只储存同义词表的头指针….</li>
<li>关键字集合为{12，67，56，16，25，37，22，29，15，47，48，21}，表长为12，</li>
<li>我们再用散列函数 <strong>f(key) =  key mod 12</strong></li>
<li>用了链地址法之后就在也不冲突,无论有多少冲突，我们只需在同义词子表中添加结点即可。下面我们看下链地址法的存储情况。</li>
</ol>
<img src="/2020/11/26/javaSE-hash/14.png" alt="14" style="zoom:80%;">



<p>链地址法虽然不能够产生冲突,但是查找时需要遍历单链表的性能.</p>
<h4 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h4><p>将有冲突的,,放入到别的地方(溢出表),这样你就有地方住了。我们为所有冲突的关键字建立了一个公共的溢出区来存放。</p>
<img src="/2020/11/26/javaSE-hash/15.png" alt="15" style="zoom:67%;">

<p>怎样查找: 通过散列函数计算出散列地址后,先于基本表对比,如果不相等就到溢出表中顺序查找.,,,,,,对于冲突很少的情况性能还是非常高的</p>
<h3 id="散列表查找算法-线性探测法"><a href="#散列表查找算法-线性探测法" class="headerlink" title="散列表查找算法(线性探测法)"></a>散列表查找算法(线性探测法)</h3><p>首先需要定义散列列表的结构以及一些相关常数，</p>
<ul>
<li>elem代表散列表数据存储数组</li>
<li>count代表的是当前插入元素个数</li>
<li>size代表哈希表容量</li>
<li>NULLKEY散列表初始值</li>
<li>然后我们如果查找成功就返回索引，如果不存在该元素就返回元素不存在。</li>
<li>我们将哈希表初始化，为数组元素赋初值。</li>
</ul>
<img src="/2020/11/26/javaSE-hash/16.png" alt="16" style="zoom:67%;">



<p>插入操作的具体步骤</p>
<ol>
<li>通过哈希函数(除法散列法),将key转化为数组下标</li>
<li>如果该下标中没有元素,则插入,否则说明冲突,则利用线性探测法处理冲突</li>
</ol>
<img src="/2020/11/26/javaSE-hash/17.png" alt="17" style="zoom:67%;">



<p>查找</p>
<ol>
<li>通过哈希函数(同输入时一样),将key转化成为数组下标</li>
<li>通过数组下标找到key值,如果key一致,则查找成功,否则利用线性探测法继续查找</li>
</ol>
<img src="/2020/11/26/javaSE-hash/18.png" alt="18" style="zoom:67%;">

<p>完整代码</p>
<img src="/2020/11/26/javaSE-hash/19.png" alt="19" style="zoom:67%;">

<h3 id="散列表性能分析"><a href="#散列表性能分析" class="headerlink" title="散列表性能分析"></a>散列表性能分析</h3><p>如果没有冲突的话,散列表查找是效率最高的,时间复杂度为O(1),</p>
<p>散列查找的平均查找长度取决于哪些方面呢</p>
<ol>
<li><p><strong>散列函数是否均匀</strong></p>
</li>
<li><p><strong>处理冲突的方法</strong></p>
<p>比如我们线性探测有时会堆积，则不如二次探测法好，因为链地址法处理冲突时不会产生任何堆积，因而具有最佳的平均查找性能</p>
</li>
<li><p>散列表的填装因子</p>
<p>装填因子 α  =  填入表中的记录数  /  散列表长度</p>
</li>
</ol>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>什么是文件的hash值呢?</p>
<p>MD5-Hash-文件的数字文摘通过Hash函数计算得到。不管文件长度如何，它的Hash函数计算结果是一个固定长度的数字。与<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">加密算法</a>不同，这一个Hash算法是一个不可逆的单向函数。采用安全性高的Hash算法，如MD5、SHA时，两个不同的文件几乎不可能得到相同的Hash结果。因此，一旦文件被修改，就可检测出来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><ul>
<li>一般的线性表、树中，记录在结构中的相对位置是随机的即和记录的关键字之间不存在确定的关系，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较”的基础上，查找的效率与比较次数密切相关。理想的情况是能直接找到需要的记录，因此必须在记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。在此，称这个对应关系f为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>，按这个思想建立的表为哈希表（又称为杂凑法或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8">散列表</a>）。</li>
<li>哈希表不可避免冲突（collision）现象：对不同的关键字可能得到同一哈希地址 即key1≠key2，而hash(key1)=hash(key2）。具有相同函数值的关键字对该<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>来说称为同义词（synonym）。因此，在建造哈希表时不仅要设定一个好的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>，而且要设定一种处理冲突的方法。可如下描述哈希表：根据设定的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>H(key）和所选中的处理冲突的方法，将一组<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a>映象到一个有限的、地址连续的地址集（区间）上并以关键字在地址集中的“象”作为相应记录在表中的存储位置，这种表被称为哈希表。</li>
<li>对于动态<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9F%A5%E6%89%BE%E8%A1%A8">查找表</a>而言，1) 表长不确定；2）在设计查找表时，只知道关键字所属范围，而不知道确切的关键字。因此，一般情况需建立一个函数关系，以f(key）作为关键字为key的录在表中的位置，通常称这个函数f(key）为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>。（注意：这个函数并不一定是数学函数）</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>是一个映象，即：将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地址集合的大小不超出允许范围即可。</li>
<li>现实中<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a>是需要构造的，并且构造的好才能使用的好。</li>
<li>用途：加密，解决冲突问题。</li>
</ul>
<hr>

<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869?fromtitle=%E6%95%A3%E5%88%97%E8%A1%A8&fromid=10027933&fr=aladdin">转载百度百科</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mg69FVTqgjryhB8NQhLaLg">袁厨的算法小屋</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/javase/">-javase</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hash/" rel="tag">hash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/28/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F04%E5%B8%8C%E5%B0%94/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          十大排序-希尔排序
        
      </div>
    </a>
  
  
    <a href="/2020/11/25/LC052/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">LC052-最大子序和</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">哈希表总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.0.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%8D%E5%8F%AF%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81%EF%BC%88collision%EF%BC%89%E7%8E%B0%E8%B1%A1%EF%BC%9A"><span class="nav-number">1.0.2.</span> <span class="nav-text">哈希表不可避免冲突（collision）现象：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.</span> <span class="nav-text">散列表查找步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">哈希函数的特殊性:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">散列函数构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">直接定址法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">数字分析法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E6%B3%95"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">折叠法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E6%95%A3%E5%88%97%E6%B3%95"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">除法散列法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E6%B3%95%E6%95%A3%E5%88%97%E6%B3%95"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">乘法散列法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">平方取中法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">随机数法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.</span> <span class="nav-text">处理散列冲突的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">开放地址法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">线性探测法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">二次探测法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">1.1.3.1.3.</span> <span class="nav-text">随机探测法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">再哈希法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">链地址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA%E6%B3%95"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">公共溢出区法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">1.1.4.</span> <span class="nav-text">散列表查找算法(线性探测法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">1.1.5.</span> <span class="nav-text">散列表性能分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">实际应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结:</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2021 WenZhao All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
